/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.1.30
 * apidoc:0.11.36 http://www.apidoc.me/flow/api/0.1.31/play_2_x_standalone_json
 */
package io.flow.v0.models {

  /**
   * Flow provides several different options for creating an authorization
   */
  sealed trait AuthorizationForm

  sealed trait Deminimus

  sealed trait Document

  sealed trait Event

  /**
   * An item function can be represented with just it's Id, or the entire model
   */
  sealed trait ExpandableItemFunction

  sealed trait ExpandableOrganization

  /**
   * A subcatalog can be represented with just it's ID, or the entire model
   */
  sealed trait ExpandableSubcatalog

  sealed trait ExpandableUser

  /**
   * Types of rules used to apply on inventory to calculate available quantity
   */
  sealed trait InventoryStrategy

  /**
   * Possible outcome types from a tier rule
   */
  sealed trait TierRuleOutcome

  /**
   * Defines structured fields for address to be used in user/form input. Either text
   * or the structured input needs to be present.
   */
  case class Address(
    text: _root_.scala.Option[String] = None,
    streets: _root_.scala.Option[Seq[String]] = None,
    city: _root_.scala.Option[String] = None,
    province: _root_.scala.Option[String] = None,
    postal: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None,
    latitude: _root_.scala.Option[String] = None,
    longitude: _root_.scala.Option[String] = None
  )

  /**
   * Rule outcome where shipping surfaced in quote is actual cost plus a predefined
   * margin price
   */
  case class AmountMargin(
    addition: io.flow.v0.models.Price
  ) extends TierRuleOutcome

  /**
   * Rule outcome where shipping surfaced in quote is actual cost of the service
   */
  case class AtCost(
    ignore: _root_.scala.Option[String] = None
  ) extends TierRuleOutcome

  /**
   * An attribute can be configured to be used in different ways throughout Flow. A
   * common example is to identify a meaningful attribute (e.g. brand) that can then
   * be displayed throughout the Flow console.
   */
  case class Attribute(
    id: String,
    key: String,
    options: io.flow.v0.models.Options,
    label: _root_.scala.Option[String] = None
  )

  case class AttributeForm(
    key: String,
    options: io.flow.v0.models.Options,
    label: _root_.scala.Option[String] = None
  )

  /**
   * Retrieve journaled history of an attribute
   */
  case class AttributeVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    attribute: io.flow.v0.models.Attribute
  )

  case class AuthenticationForm(
    email: String,
    password: String
  )

  /**
   * An authorization is used to check and reserve funds w/ a given payment method.
   * No funds are actually transferred; once you have you an authorization, you can
   * capture up to the amount of the authorization.
   */
  case class Authorization(
    id: String,
    key: String,
    card: io.flow.v0.models.CardReference,
    amount: BigDecimal,
    currency: String,
    customer: io.flow.v0.models.Customer,
    attributes: Map[String, String],
    destination: _root_.scala.Option[io.flow.v0.models.Address] = None,
    ip: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    result: io.flow.v0.models.AuthorizationResult
  )

  case class AuthorizationReference(
    id: String
  )

  /**
   * Contains the result of the authorization. If an immediate response is not
   * available, the state will be 'pending' - this usually indicates fraud review
   * requires additional time / verification (or a potential network issue with the
   * issuing bank).
   */
  case class AuthorizationResult(
    status: io.flow.v0.models.AuthorizationStatus,
    declineCode: _root_.scala.Option[io.flow.v0.models.AuthorizationDeclineCode] = None,
    avs: _root_.scala.Option[io.flow.v0.models.Avs] = None,
    cvv: _root_.scala.Option[io.flow.v0.models.Cvv] = None
  )

  case class AuthorizationVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    authorization: io.flow.v0.models.Authorization
  )

  /**
   * Representation of a service level available at a center, including misc
   * attributes. Only ID for now, more attributes will be added in the future.
   */
  case class AvailableService(
    service: String
  )

  /**
   * Represents the address verification results
   */
  case class Avs(
    code: io.flow.v0.models.AvsCode,
    name: _root_.scala.Option[Boolean] = None,
    address: _root_.scala.Option[Boolean] = None,
    postal: _root_.scala.Option[Boolean] = None,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Capture actually transfers funds. You can capture as many times as you'd like up
   * until the total amount of the authorization has been captured or the
   * authorization otherwise becomes unavailable (e.g. expires).
   */
  case class Capture(
    id: String,
    key: String,
    authorization: io.flow.v0.models.AuthorizationReference,
    amount: BigDecimal,
    currency: String
  )

  /**
   * Capture actually transfers funds. You can capture as many times as you'd like up
   * until the total amount of the authorization has been captured or the
   * authorization otherwise becomes unavailable (e.g. expires).
   */
  case class CaptureForm(
    authorizationId: String,
    key: _root_.scala.Option[String] = None,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None
  )

  case class CaptureVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    capture: io.flow.v0.models.Capture
  )

  /**
   * Card represents the metadata about a secure, tokenized card. The card 'token' is
   * a unique, cryptographically secure token by which this card can be identified in
   * the future.
   */
  case class Card(
    id: String,
    token: String,
    `type`: io.flow.v0.models.CardType,
    expiration: io.flow.v0.models.Expiration,
    last4: String,
    name: String,
    address: _root_.scala.Option[io.flow.v0.models.Address] = None
  )

  case class CardForm(
    number: _root_.scala.Option[String] = None,
    cipher: _root_.scala.Option[String] = None,
    expirationMonth: Int,
    expirationYear: Int,
    name: String,
    cvv: _root_.scala.Option[String] = None,
    address: _root_.scala.Option[io.flow.v0.models.Address] = None,
    challengeText: _root_.scala.Option[String] = None,
    challengeCipher: _root_.scala.Option[String] = None
  )

  case class CardReference(
    id: String,
    token: String
  )

  case class CardVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    card: io.flow.v0.models.Card
  )

  /**
   * Partner that actually take a shipment between places (ex: FedEx, DHL, SF
   * Express)
   */
  case class Carrier(
    id: String,
    name: String,
    facilities: Seq[io.flow.v0.models.ShippingAddress],
    visibility: io.flow.v0.models.Visibility
  )

  case class CarrierReference(
    id: String
  )

  case class Catalog(
    id: String
  )

  case class CatalogDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    catalog: String
  ) extends Event

  case class CatalogItemDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    catalog: String
  ) extends Event

  case class CatalogItemDocument(
    number: String,
    name: String,
    categories: Seq[String],
    experiences: Seq[io.flow.v0.models.ExperienceSummary],
    attributes: Map[String, String],
    images: io.flow.v0.models.CatalogItemDocumentImages
  ) extends Document

  case class CatalogItemDocumentImage(
    url: String
  )

  case class CatalogItemDocumentImages(
    thumbnail: _root_.scala.Option[io.flow.v0.models.CatalogItemDocumentImage] = None
  )

  case class CatalogItemUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    catalog: String,
    locale: String,
    name: String,
    currency: String,
    price: Double,
    categories: Seq[String],
    description: _root_.scala.Option[String] = None,
    attributes: Map[String, String],
    dimensions: _root_.play.api.libs.json.JsObject,
    images: Seq[_root_.play.api.libs.json.JsObject]
  ) extends Event

  /**
   * Statistics covering product catalog item information, including total catalog
   * item count, number of distinct categories, etc.
   */
  case class CatalogStatistics(
    items: Long,
    categories: Long
  )

  case class CatalogUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    catalog: String
  ) extends Event

  case class CatalogVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    catalog: io.flow.v0.models.Catalog
  )

  case class CategorySummary(
    name: _root_.scala.Option[String] = None,
    count: Long
  )

  /**
   * Represents a facility capable of fulfilling a shipment
   */
  case class Center(
    id: String,
    key: String,
    address: io.flow.v0.models.ShippingAddress,
    packaging: Seq[io.flow.v0.models.Packaging],
    name: String,
    services: Seq[io.flow.v0.models.AvailableService],
    schedule: io.flow.v0.models.Schedule,
    timezone: String
  )

  case class CenterForm(
    address: io.flow.v0.models.ShippingAddress,
    packaging: Seq[io.flow.v0.models.Packaging],
    name: String,
    services: Seq[io.flow.v0.models.AvailableService],
    schedule: io.flow.v0.models.Schedule,
    timezone: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None
  )

  case class CenterReference(
    id: String
  )

  case class CenterVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    center: io.flow.v0.models.Center
  )

  /**
   * The actual value of the API token. This is modeled as a separate resource as it
   * is fetched only on demand.
   */
  case class Cleartext(
    value: String
  )

  /**
   * Defines structured fields for a contact person. Typically used for specifying
   * contact person for an account, shipment, or organization representative
   */
  case class Contact(
    name: io.flow.v0.models.Name,
    company: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None,
    phone: _root_.scala.Option[String] = None
  )

  case class ContractedRateUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organizationId: String,
    base: String,
    target: String,
    effectiveAt: _root_.org.joda.time.DateTime,
    value: BigDecimal
  ) extends Event

  /**
   * Describes conversion information from a base currency to a target currency.
   */
  case class Conversion(
    base: String,
    target: String,
    rate: BigDecimal
  )

  case class Country(
    name: String,
    iso31662: String,
    iso31663: String,
    languages: Seq[String],
    measurementSystem: String,
    defaultCurrency: _root_.scala.Option[String] = None,
    timezones: Seq[String]
  )

  /**
   * Provides country level default settings for currency, language, etc.
   */
  case class CountryDefaults(
    country: String,
    currency: String,
    language: String
  )

  /**
   * ISO 4217 3-character currency code. See https://api.flow.io/reference/currencies
   */
  case class Currency(
    name: String,
    iso42173: String,
    numberDecimals: Int
  )

  /**
   * A customer represents the actual person purchasing from you. This information is
   * needed primarily to support logistics (delivery to this person), fraud
   * management (verification of who the person is), and reporting. We also recommend
   * including your customer number whenever possible as doing so will allow Flow to
   * link up transactions for this customer making customer service easier.
   */
  case class Customer(
    name: io.flow.v0.models.Name,
    number: _root_.scala.Option[String] = None,
    phone: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None
  )

  /**
   * Represents the card verification results
   */
  case class Cvv(
    code: io.flow.v0.models.CvvCode,
    description: _root_.scala.Option[String] = None
  )

  case class DatetimeRange(
    from: _root_.org.joda.time.DateTime,
    to: _root_.org.joda.time.DateTime
  )

  /**
   * Represents a collection of items, the available delivery option tier for that
   * collection of items, and metadata about those options
   */
  case class Delivery(
    id: String,
    items: Seq[io.flow.v0.models.LineItem],
    options: Seq[io.flow.v0.models.DeliveryOption]
  )

  /**
   * Represents a collection of items, the available delivery option tier for that
   * collection of items, and metadata about those options
   */
  case class DeliveryForm(
    quote: String,
    items: Seq[io.flow.v0.models.LineItem],
    destination: io.flow.v0.models.ShippingAddress
  )

  /**
   * Represents a way to fulfill a delivery, including an estimates for the date
   * range and cost
   */
  case class DeliveryOption(
    id: String,
    cost: io.flow.v0.models.Price,
    deliveredDuty: io.flow.v0.models.DeliveredDuty,
    price: io.flow.v0.models.Price,
    service: io.flow.v0.models.ServiceSummary,
    tier: io.flow.v0.models.TierSummary,
    window: io.flow.v0.models.DatetimeRange
  )

  /**
   * Represents a way to fulfill a delivery, including an estimates for the date
   * range and cost
   */
  case class DeliveryOptionForm(
    delivery: String,
    items: Seq[io.flow.v0.models.LineItem],
    destination: io.flow.v0.models.ShippingAddress
  )

  case class DeliveryOptionReference(
    id: String
  )

  case class DeliveryOptionSummary(
    id: String,
    cost: io.flow.v0.models.Price,
    deliveredDuty: io.flow.v0.models.DeliveredDuty,
    price: io.flow.v0.models.Price,
    service: io.flow.v0.models.ServiceReference,
    tier: io.flow.v0.models.TierReference,
    window: io.flow.v0.models.DatetimeRange
  )

  case class DeliveryOptionVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    deliveryOption: io.flow.v0.models.DeliveryOptionSummary
  )

  case class DeliverySummary(
    id: String,
    items: Seq[io.flow.v0.models.LineItem]
  )

  case class DeliveryVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    delivery: io.flow.v0.models.DeliverySummary
  )

  case class DeliveryWindow(
    from: _root_.org.joda.time.DateTime,
    to: _root_.org.joda.time.DateTime
  )

  case class DeminimusSimple(
    value: BigDecimal,
    currency: String,
    components: Seq[io.flow.v0.models.LevyComponent],
    minimum: BigDecimal
  ) extends Deminimus

  case class Dimension(
    depth: _root_.scala.Option[io.flow.v0.models.Measurement] = None,
    diameter: _root_.scala.Option[io.flow.v0.models.Measurement] = None,
    length: _root_.scala.Option[io.flow.v0.models.Measurement] = None,
    weight: _root_.scala.Option[io.flow.v0.models.Measurement] = None,
    width: _root_.scala.Option[io.flow.v0.models.Measurement] = None
  )

  case class Dimensions(
    product: _root_.scala.Option[io.flow.v0.models.Dimension] = None,
    packaging: _root_.scala.Option[io.flow.v0.models.Dimension] = None
  )

  /**
   * Creates an authorization for a transaction in which you remain the merchant of
   * record. An authorization is used to check and reserve funds w/ a given payment
   * method. No funds are actually transferred; once you have you an authorization,
   * you can capture up to the amount of the authorization.
   */
  case class DirectAuthorizationForm(
    token: String,
    amount: BigDecimal,
    currency: String,
    customer: io.flow.v0.models.Customer,
    key: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    destination: _root_.scala.Option[io.flow.v0.models.Address] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm

  /**
   * Represents a duration of time.
   */
  case class Duration(
    unit: io.flow.v0.models.UnitOfTime,
    value: Long
  )

  /**
   * Represents a simple model of duties that apply to a given item / trade lane.
   */
  case class Duty(
    rate: BigDecimal,
    components: Seq[io.flow.v0.models.LevyComponent],
    deminimus: _root_.scala.Option[io.flow.v0.models.Deminimus] = None
  )

  /**
   * Represents the successful response of an email verification token. We return the
   * email address in this case to allow the UI to display which email address was
   * verified.
   */
  case class EmailVerification(
    email: String
  )

  /**
   * Represents an error of some sort (e.g. invalid input). Each error will contain a
   * code and a specific message describing the failure.
   */
  case class Error(
    code: String,
    message: String
  )

  /**
   * Range of time given a from and to number and the unit. For example: 1-4 hours or
   * 4-7 days
   */
  case class EstimatedWindow(
    from: Long,
    to: Long,
    unit: io.flow.v0.models.UnitOfTime
  )

  /**
   * Represents an exception to the schedule of a center.
   */
  case class Exception(
    `type`: io.flow.v0.models.ExceptionType,
    datetimeRange: io.flow.v0.models.DatetimeRange
  )

  /**
   * Experiences define a local experience for a given geographic region
   */
  case class Experience(
    id: String,
    key: String,
    name: String,
    deliveredDuty: io.flow.v0.models.DeliveredDuty,
    region: io.flow.v0.models.RegionReference,
    country: String,
    currency: String,
    language: String,
    measurementSystem: io.flow.v0.models.MeasurementSystem,
    subcatalog: io.flow.v0.models.SubcatalogReference,
    position: Long
  )

  case class ExperienceDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    key: String,
    subcatalogId: String
  ) extends Event

  /**
   * Experiences define a local experience for a given geographic region
   */
  case class ExperienceForm(
    regionId: String,
    name: String,
    deliveredDuty: _root_.scala.Option[io.flow.v0.models.DeliveredDuty] = None,
    country: _root_.scala.Option[String] = None,
    currency: _root_.scala.Option[String] = None,
    language: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    measurementSystem: _root_.scala.Option[io.flow.v0.models.MeasurementSystem] = None,
    subcatalogId: _root_.scala.Option[String] = None,
    position: _root_.scala.Option[Long] = None
  )

  case class ExperienceReference(
    id: String
  )

  /**
   * Some important fields related to experiences used in various APIs
   */
  case class ExperienceSummary(
    id: String,
    key: String,
    name: String,
    currency: _root_.scala.Option[String] = None,
    country: _root_.scala.Option[String] = None
  )

  case class ExperienceUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    key: String,
    name: String,
    deliveredDuty: String,
    subcatalogId: String,
    regionId: String,
    country: String,
    currency: String,
    language: String,
    measurementSystem: String,
    position: Long
  ) extends Event

  case class ExperienceVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    experience: io.flow.v0.models.Experience
  )

  /**
   * The month and year at which a card expires
   */
  case class Expiration(
    month: Int,
    year: Int
  )

  /**
   * Rule outcome where shipping surfaced in quote is pre-defined flat rate
   */
  case class FlatRate(
    price: io.flow.v0.models.Price
  ) extends TierRuleOutcome

  case class FlowCurrencySettingDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    flowCurrencySettingId: String
  ) extends Event

  case class FlowCurrencySettingUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    flowCurrencySettingId: String,
    organizationId: String,
    base: String,
    target: String,
    margin: BigDecimal,
    rateLockUnit: String,
    rateLockValue: Long
  ) extends Event

  case class FlowItemIndexMetadata(
    status: io.flow.v0.models.SubcatalogItemStatus
  )

  /**
   * Rule outcome where shipping surfaced in quote is free
   */
  case class FreeShipping(
    ignore: _root_.scala.Option[String] = None
  ) extends TierRuleOutcome

  case class FulfillmentExperienceReference(
    id: String,
    currency: String
  )

  case class HarmonizationDocument(
    code: String,
    categories: Seq[io.flow.v0.models.CategorySummary],
    origin: _root_.scala.Option[String] = None
  ) extends Document

  /**
   * Organization level settings.
   */
  case class HarmonizationSettings(
    dutyStrategy: io.flow.v0.models.LevyStrategy = io.flow.v0.models.LevyStrategy.Maximum,
    taxStrategy: io.flow.v0.models.LevyStrategy = io.flow.v0.models.LevyStrategy.Maximum
  )

  case class HarmonizationSettingsForm(
    dutyStrategy: _root_.scala.Option[io.flow.v0.models.LevyStrategy] = None,
    taxStrategy: _root_.scala.Option[io.flow.v0.models.LevyStrategy] = None
  )

  /**
   * Categories optimized for harmonization
   */
  case class HarmonizedCategory(
    id: String,
    name: String,
    parent: _root_.scala.Option[io.flow.v0.models.HarmonizedCategoryReference] = None
  )

  case class HarmonizedCategoryReference(
    id: String
  )

  /**
   * A harmonized item stores explicit information about this item for the purposes
   * of harmonization / classification. The harmonization process begins by creating
   * a harmonized item; this kicks off the internal processes. Once assigned, codes
   * will be available via the hs6 and hs10 resources
   */
  case class HarmonizedItem(
    id: String,
    number: String,
    name: String,
    description: _root_.scala.Option[String] = None,
    categories: Seq[String] = Nil,
    attributes: Map[String, String] = Map.empty
  )

  /**
   * Used to specifically set an item's duty rate for a given trade lane.
   */
  case class HarmonizedItemDuty(
    id: String,
    item: io.flow.v0.models.HarmonizedItemReference,
    origin: String,
    destination: String,
    rate: BigDecimal
  )

  case class HarmonizedItemDutyForm(
    number: String,
    origin: String,
    destination: String,
    rate: BigDecimal
  )

  case class HarmonizedItemDutyVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    harmonizedItemDuty: io.flow.v0.models.HarmonizedItemDuty
  )

  case class HarmonizedItemForm(
    name: String,
    number: String,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  case class HarmonizedItemPutForm(
    name: String,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None
  )

  case class HarmonizedItemReference(
    id: String,
    number: String
  )

  case class HarmonizedItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    harmonizedItem: io.flow.v0.models.HarmonizedItem
  )

  /**
   * Summary of landed cost data (taxes and duties) for 1 or more items going to a
   * single destination country. Records are unique based on (item.number, country of
   * origin).
   */
  case class HarmonizedLandedCost(
    address: io.flow.v0.models.Address,
    items: Seq[io.flow.v0.models.HarmonizedLandedCostItem]
  )

  /**
   * Allows calculation of duty and tax for multiple items in one API call for items
   * going to a specific destination country
   */
  case class HarmonizedLandedCostForm(
    address: io.flow.v0.models.Address,
    itemNumbers: Seq[String]
  )

  /**
   * Duty and tax information for a given item. Note that the internal implementation
   * supports multiple countries of origin.
   */
  case class HarmonizedLandedCostItem(
    item: io.flow.v0.models.HarmonizedItemReference,
    duty: io.flow.v0.models.Duty,
    tax: io.flow.v0.models.Tax
  )

  case class Header(
    name: String,
    value: String
  )

  case class Healthcheck(
    status: String
  )

  /**
   * The (Harmonized System) HS-10 code assigned to an item with a given
   * origin/destination pair.
   */
  case class Hs10(
    id: String,
    item: io.flow.v0.models.HarmonizedItemReference,
    origin: String,
    destination: String,
    code: String
  )

  /**
   * Event raised whenever an HS-10 code is unassigned from an item
   */
  case class Hs10CodeDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    origin: String,
    destination: String
  ) extends Event

  /**
   * Event raised whenever an HS-10 code is assigned to an item
   */
  case class Hs10CodeUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    origin: String,
    destination: String,
    code: String
  ) extends Event

  case class Hs10Version(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    hs10: io.flow.v0.models.Hs10
  )

  /**
   * The (Harmonized System) HS-6 code assigned to an item.
   */
  case class Hs6(
    id: String,
    item: io.flow.v0.models.HarmonizedItemReference,
    code: String
  )

  /**
   * Event raised whenever an HS-6 code is deleted
   */
  case class Hs6CodeDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String
  ) extends Event

  /**
   * Event raised whenever an HS-6 code is assigned to an item
   */
  case class Hs6CodeUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    code: String
  ) extends Event

  case class Hs6Version(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    hs6: io.flow.v0.models.Hs6
  )

  /**
   * The URL to an image, with optional tags. Flow Commerce primarily uses images to
   * enhance the administrative tools (e.g. showing an item image in console)
   */
  case class Image(
    url: String,
    tags: Seq[String] = Nil
  )

  /**
   * Image form defines the data needed to create an image
   */
  case class ImageForm(
    url: String,
    tags: _root_.scala.Option[Seq[String]] = None
  )

  /**
   * Enables backorders, setting an optional number of units that we allow for
   * backorder. For example, a backorder w/ quantity 10 will enable selling until the
   * actual inventory quantity is -10.
   */
  case class InventoryBackorder(
    quantity: Long
  ) extends InventoryStrategy

  case class InventoryCenterReference(
    key: String
  )

  case class InventoryItemReference(
    number: String
  )

  /**
   * Ordered list of rules to apply, from first to last, to get available quantity.
   * This is unique per organization
   */
  case class InventoryRule(
    id: String,
    position: Long,
    query: String,
    strategy: io.flow.v0.models.InventoryStrategy
  )

  case class InventoryRuleForm(
    position: Long,
    query: String,
    strategy: io.flow.v0.models.InventoryStrategy
  )

  case class InventoryRuleVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    inventoryRule: io.flow.v0.models.InventoryRule
  )

  /**
   * Inventory snapshot reflects the current quantity and available number of units
   * for a given center / item
   */
  case class InventorySnapshot(
    id: String,
    available: Long,
    center: io.flow.v0.models.InventoryCenterReference,
    item: io.flow.v0.models.InventoryItemReference,
    quantity: Long
  )

  case class InventorySnapshotVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    inventorySnapshot: io.flow.v0.models.InventorySnapshot
  )

  /**
   * Treats inventory as available as long as the actual inventory quantity is > the
   * specified quantity. A common use case is to set quantity to zero to indicate
   * availability as long as there is at least 1 unit available.
   */
  case class InventoryStock(
    quantity: Long
  ) extends InventoryStrategy

  /**
   * Items affected with rules pursuing an unlimited strategy will always be
   * available
   */
  case class InventoryUnlimited(
    quantity: String = "unlimited"
  ) extends InventoryStrategy

  /**
   * Represents a single update on inventory quantity
   */
  case class InventoryUpdate(
    id: String,
    idempotencyKey: String,
    center: io.flow.v0.models.InventoryCenterReference,
    item: io.flow.v0.models.InventoryItemReference,
    notes: _root_.play.api.libs.json.JsObject,
    quantity: Long,
    `type`: io.flow.v0.models.UpdateType
  )

  /**
   * Form used to create an update on inventory. If inventory for center/item has not
   * been previously created, a new row is created for the center/item tuple.
   */
  case class InventoryUpdateForm(
    center: String,
    idempotencyKey: String,
    itemNumber: String,
    quantity: Long,
    `type`: io.flow.v0.models.UpdateType,
    notes: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None
  )

  case class InventoryUpdateVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    inventoryUpdate: io.flow.v0.models.InventoryUpdate
  )

  /**
   * An invitation via email to a user to join this organization. The user will then
   * walk through a user login/registration process and will immediately become a
   * member of the organization.
   */
  case class Invitation(
    id: String,
    organization: io.flow.v0.models.ExpandableOrganization,
    email: String,
    name: io.flow.v0.models.Name,
    role: io.flow.v0.models.Role,
    expiration: _root_.org.joda.time.DateTime
  )

  case class InvitationAcceptsForm(
    userId: String
  )

  case class InvitationForm(
    organization: String,
    email: String,
    name: _root_.scala.Option[io.flow.v0.models.Name] = None,
    role: io.flow.v0.models.Role = io.flow.v0.models.Role.Member
  )

  case class InvitationVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    invitation: io.flow.v0.models.Invitation
  )

  /**
   * The Flow item defines a specific item that can be purchased by a consumer. For
   * many clients, this will map to a Sku.
   */
  case class Item(
    id: String,
    number: String,
    locale: String,
    name: String,
    price: io.flow.v0.models.Price,
    categories: Seq[String] = Nil,
    description: _root_.scala.Option[String] = None,
    attributes: Map[String, String] = Map.empty,
    dimensions: io.flow.v0.models.Dimensions,
    images: Seq[io.flow.v0.models.Image] = Nil,
    local: _root_.scala.Option[io.flow.v0.models.Local] = None
  )

  /**
   * The item form defines the data required to create an item.
   */
  case class ItemForm(
    number: String,
    locale: String,
    name: String,
    currency: String,
    price: Double,
    categories: _root_.scala.Option[Seq[String]] = None,
    description: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    dimensions: _root_.scala.Option[io.flow.v0.models.Dimensions] = None,
    images: _root_.scala.Option[Seq[io.flow.v0.models.ImageForm]] = None
  )

  /**
   * Item Functions are javascript code used to calculate the localized price of an
   * additional item. Each function can be associated with an optional query
   * identifying the products to which the function applies. Flow selects the first
   * function matching an item, then uses that function to calculate local prices
   * whenever any data relevant to the item changes (e.g. on update in master
   * catalog, on change in relevant exchange rate, etc.). Item functions are
   * immutable once created.
   */
  case class ItemFunction(
    id: String,
    key: String,
    description: String,
    code: String
  ) extends ExpandableItemFunction

  /**
   * Item Functions are javascript code used to calculate the localized price of an
   * additional item. Each function can be associated with an optional query
   * identifying the products to which the function applies. Flow selects the first
   * function matching an item, then uses that function to calculate local prices
   * whenever any data relevant to the item changes (e.g. on update in master
   * catalog, on change in relevant exchange rate, etc.). Item functions are
   * immutable once created.
   */
  case class ItemFunctionPostForm(
    description: String,
    code: String,
    key: _root_.scala.Option[String] = None
  )

  /**
   * Item Functions are javascript code used to calculate the localized price of an
   * additional item. Each function can be associated with an optional query
   * identifying the products to which the function applies. Flow selects the first
   * function matching an item, then uses that function to calculate local prices
   * whenever any data relevant to the item changes (e.g. on update in master
   * catalog, on change in relevant exchange rate, etc.). Item functions are
   * immutable once created.
   */
  case class ItemFunctionPutForm(
    description: String,
    code: String
  )

  case class ItemFunctionReference(
    id: String
  ) extends ExpandableItemFunction

  case class ItemFunctionVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    itemFunction: io.flow.v0.models.ItemFunction
  )

  /**
   * A list of margin to apply to items based on query.
   */
  case class ItemMargin(
    id: String,
    name: String,
    q: String,
    margin: io.flow.v0.models.Margin,
    position: Long
  )

  case class ItemMarginDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    itemMarginId: String
  ) extends Event

  /**
   * A list of margin to apply to items based on query.
   */
  case class ItemMarginForm(
    name: String,
    margin: io.flow.v0.models.Margin,
    q: String,
    position: _root_.scala.Option[Long] = None
  )

  case class ItemMarginUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    itemMarginId: String,
    organizationId: String,
    experienceKey: String,
    name: String,
    q: String,
    marginType: String,
    marginValue: BigDecimal,
    position: Long
  ) extends Event

  case class ItemMarginVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    itemMargin: io.flow.v0.models.ItemMargin
  )

  /**
   * Statistics covering product catalog item information, including total catalog
   * item count, number of distinct categories, etc.
   */
  case class ItemStatistics(
    items: Long,
    categories: Long
  )

  case class ItemVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    item: io.flow.v0.models.Item
  )

  /**
   * Represents a specific label being tracked as part of the tracking bucket
   */
  case class Label(
    id: String,
    tracking: io.flow.v0.models.TrackingSummary,
    status: io.flow.v0.models.TrackingStatus,
    carrier: String,
    trackingNumber: String,
    timestamp: _root_.org.joda.time.DateTime,
    deliveryEstimate: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    description: _root_.scala.Option[String] = None
  )

  case class LabelEvent(
    id: String,
    label: io.flow.v0.models.LabelSummary,
    address: io.flow.v0.models.Address,
    status: io.flow.v0.models.TrackingStatus,
    timestamp: _root_.org.joda.time.DateTime,
    description: _root_.scala.Option[String] = None
  )

  case class LabelEventForm(
    labelId: String,
    timestamp: _root_.org.joda.time.DateTime,
    status: io.flow.v0.models.TrackingStatus,
    description: _root_.scala.Option[String] = None,
    address: _root_.scala.Option[String] = None
  )

  case class LabelEventSummary(
    id: String,
    status: io.flow.v0.models.TrackingStatus,
    timestamp: _root_.org.joda.time.DateTime
  )

  case class LabelEventVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    labelEvent: io.flow.v0.models.LabelEventSummary
  )

  /**
   * Represents a specific label being tracked as part of the tracking bucket
   */
  case class LabelForm(
    trackingId: String,
    status: io.flow.v0.models.TrackingStatus = io.flow.v0.models.TrackingStatus.Pending,
    carrier: String,
    trackingNumber: String,
    deliveryEstimate: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    description: _root_.scala.Option[String] = None,
    timestamp: _root_.scala.Option[_root_.org.joda.time.DateTime] = None
  )

  case class LabelSummary(
    id: String,
    tracking: io.flow.v0.models.TrackingSummary,
    status: io.flow.v0.models.TrackingStatus,
    carrier: String,
    trackingNumber: String
  )

  case class LabelVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    label: io.flow.v0.models.LabelSummary
  )

  /**
   * ISO 639 2-character language code. See https://api.flow.io/reference/languages
   */
  case class Language(
    name: String,
    iso6392: String
  )

  /**
   * Line items represent the items a consumer is purchasing, including additional
   * information to complete the transaction. Note that you may pass in as many line
   * items as you like - including repeating item numbers across line items.
   */
  case class LineItem(
    number: String,
    quantity: Long,
    center: _root_.scala.Option[String] = None,
    price: _root_.scala.Option[io.flow.v0.models.Money] = None,
    discount: _root_.scala.Option[io.flow.v0.models.Money] = None
  )

  case class Local(
    prices: Seq[io.flow.v0.models.LocalizedPrice]
  )

  case class LocalizedItemDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    catalog: String
  ) extends Event

  case class LocalizedItemUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    catalog: String,
    locale: String,
    name: String,
    currency: String,
    price: Double,
    categories: Seq[String],
    description: _root_.scala.Option[String] = None,
    attributes: Map[String, String],
    dimensions: _root_.play.api.libs.json.JsObject,
    images: Seq[_root_.play.api.libs.json.JsObject],
    local: _root_.play.api.libs.json.JsObject
  ) extends Event

  /**
   * Line items on the order, with localized pricing information
   */
  case class LocalizedLineItem(
    number: String,
    quantity: Long,
    center: _root_.scala.Option[String] = None,
    price: _root_.scala.Option[io.flow.v0.models.Money] = None,
    discount: _root_.scala.Option[io.flow.v0.models.Money] = None,
    local: io.flow.v0.models.Local
  )

  case class LocalizedPrice(
    key: io.flow.v0.models.LocalizedPriceKey,
    currency: String,
    amount: Double,
    label: String
  )

  case class Margin(
    `type`: io.flow.v0.models.MarginType,
    value: BigDecimal
  )

  case class Measurement(
    value: String,
    units: io.flow.v0.models.UnitOfMeasurement
  )

  /**
   * Represents the users that are part of this organization. Primary purpose is to
   * manage which users have access to the organization's data and to provide a
   * simple user interface to assign roles and permissions to each member of the
   * organization
   */
  case class Membership(
    id: String,
    organization: io.flow.v0.models.ExpandableOrganization,
    user: io.flow.v0.models.ExpandableUser,
    role: io.flow.v0.models.Role
  )

  /**
   * Top level resource to create a membership.
   */
  case class MembershipForm(
    organization: String,
    user: String,
    role: io.flow.v0.models.Role = io.flow.v0.models.Role.Member
  )

  /**
   * Top level resource to create a membership.
   */
  case class MembershipPutForm(
    role: io.flow.v0.models.Role = io.flow.v0.models.Role.Member
  )

  case class MembershipVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    membership: io.flow.v0.models.Membership
  )

  /**
   * Creates an authorization for a transaction for which Flow is the merchant of
   * record. In this case, you must provide your order number for a valid Flow order.
   * An authorization is used to check and reserve funds w/ a given payment method.
   * No funds are actually transferred; once you have you an authorization, you can
   * capture up to the amount of the authorization
   */
  case class MerchantOfRecordAuthorizationForm(
    token: String,
    orderNumber: String,
    key: _root_.scala.Option[String] = None,
    cvv: _root_.scala.Option[String] = None,
    attributes: _root_.scala.Option[Map[String, String]] = None,
    ip: _root_.scala.Option[String] = None
  ) extends AuthorizationForm

  /**
   * Money represents an amount in a given currency
   */
  case class Money(
    amount: Double,
    currency: String
  )

  case class Name(
    first: _root_.scala.Option[String] = None,
    last: _root_.scala.Option[String] = None
  )

  case class NameForm(
    first: _root_.scala.Option[String] = None,
    last: _root_.scala.Option[String] = None
  )

  /**
   * Flags to indicate whether a feature is enabled/disabled on a particular model
   * (e.g. show/do not show attribute as a column in harmonization table view of
   * items)
   */
  case class Options(
    required: Boolean = false,
    showInCatalog: Boolean = false,
    showInHarmonization: Boolean = false
  )

  /**
   * An order represents all of the information about a particular line item,
   * including pricing, currency rates, delivery options, etc. All information in an
   * order is guaranteed by Flow - if an order is booked before its expiration. The
   * intended use case is to create an order as a consumer enters checkout, then to
   * book that order in order processing.
   */
  case class Order(
    id: String,
    number: String,
    customer: io.flow.v0.models.Customer,
    expiresAt: _root_.org.joda.time.DateTime,
    items: Seq[io.flow.v0.models.LocalizedLineItem],
    destination: io.flow.v0.models.Address,
    deliveries: Seq[io.flow.v0.models.Delivery],
    selections: Seq[String],
    prices: Seq[io.flow.v0.models.LocalizedPrice],
    total: io.flow.v0.models.LocalizedPrice
  )

  /**
   * Represents an order that has been booked. Booked orders can no longer be deleted
   * as they represent transactions in the real world.
   */
  case class OrderBooking(
    id: String,
    order: io.flow.v0.models.OrderReference,
    createdAt: _root_.org.joda.time.DateTime
  )

  /**
   * The order form is used to create an open order, providing the details on pricing
   * and delivery options for destination and items/quantities specified
   */
  case class OrderForm(
    number: String,
    customer: io.flow.v0.models.Customer,
    destination: io.flow.v0.models.Address,
    items: Seq[io.flow.v0.models.LineItem],
    discount: _root_.scala.Option[io.flow.v0.models.Money] = None
  )

  /**
   * The order put form is used to upsert an order, providing the details on pricing
   * and delivery options for destination and items/quantities specified.
   */
  case class OrderPutForm(
    customer: io.flow.v0.models.Customer,
    destination: io.flow.v0.models.Address,
    items: Seq[io.flow.v0.models.LineItem],
    selections: _root_.scala.Option[Seq[String]] = None,
    discount: _root_.scala.Option[io.flow.v0.models.Money] = None
  )

  case class OrderReference(
    id: String
  )

  case class OrderVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    order: io.flow.v0.models.Order
  )

  /**
   * Represents a single organization in the system, and what environment it is
   * currently operating in.
   */
  case class Organization(
    id: String,
    name: String,
    environment: io.flow.v0.models.Environment,
    parent: _root_.scala.Option[io.flow.v0.models.OrganizationReference] = None
  ) extends ExpandableOrganization

  /**
   * Defines the data used for broad authorization of user access to org level data
   */
  case class OrganizationAuthorization(
    role: io.flow.v0.models.Role,
    environment: io.flow.v0.models.Environment
  )

  /**
   * Represents organization-specific currency conversion adjustments.
   */
  case class OrganizationCurrencySetting(
    id: String,
    base: String,
    target: String,
    margin: BigDecimal
  )

  case class OrganizationCurrencySettingDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organizationCurrencySettingId: String
  ) extends Event

  /**
   * Represents the parts of an organization setting that can be updated.
   */
  case class OrganizationCurrencySettingForm(
    base: String,
    target: String,
    margin: BigDecimal
  )

  case class OrganizationCurrencySettingUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organizationCurrencySettingId: String,
    organizationId: String,
    base: String,
    target: String,
    margin: BigDecimal
  ) extends Event

  case class OrganizationCurrencySettingVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    organizationCurrencySetting: io.flow.v0.models.OrganizationCurrencySetting
  )

  case class OrganizationDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    id: String
  ) extends Event

  /**
   * Either id or name is required.
   */
  case class OrganizationForm(
    id: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    environment: io.flow.v0.models.Environment = io.flow.v0.models.Environment.Production,
    parentId: _root_.scala.Option[String] = None
  )

  /**
   * Data required to upsert an organization.
   */
  case class OrganizationPutForm(
    name: _root_.scala.Option[String] = None,
    environment: _root_.scala.Option[io.flow.v0.models.Environment] = None,
    parentId: _root_.scala.Option[String] = None
  )

  case class OrganizationReference(
    id: String
  ) extends ExpandableOrganization

  case class OrganizationSummary(
    id: String,
    name: String
  )

  case class OrganizationUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    id: String,
    name: String,
    environment: String,
    currencies: Seq[String],
    parentId: _root_.scala.Option[String] = None
  ) extends Event

  case class OrganizationVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    organization: io.flow.v0.models.Organization
  )

  /**
   * Represents packaging available to ship items
   */
  case class Packaging(
    dimensions: io.flow.v0.models.Dimensions,
    name: _root_.scala.Option[String] = None,
    number: _root_.scala.Option[String] = None
  )

  case class PasswordChangeForm(
    current: String,
    `new`: String
  )

  case class PasswordResetForm(
    token: String,
    password: String
  )

  case class PasswordResetRequestForm(
    email: String
  )

  /**
   * Rule outcome where shipping surfaced in quote is actual cost plus a predefined
   * margin percentage
   */
  case class PercentMargin(
    percentage: Double
  ) extends TierRuleOutcome

  /**
   * Represents an amount-currency pair for a basic price
   */
  case class Price(
    amount: Double,
    currency: String,
    label: String
  )

  /**
   * Detailed information for the pricing of a given item within an experience
   */
  case class PriceDetails(
    base: io.flow.v0.models.Price,
    local: io.flow.v0.models.Price,
    currencyMargin: io.flow.v0.models.Price,
    margin: io.flow.v0.models.Price,
    vat: io.flow.v0.models.Price,
    duty: io.flow.v0.models.Price,
    rounding: io.flow.v0.models.Price,
    total: io.flow.v0.models.Price
  )

  case class PriceEquation(
    basePrice: BigDecimal,
    contractedRate: BigDecimal,
    rate: BigDecimal,
    insurance: BigDecimal,
    freight: BigDecimal,
    margins: Seq[io.flow.v0.models.Margin],
    duty: _root_.scala.Option[io.flow.v0.models.Duty] = None,
    tax: _root_.scala.Option[io.flow.v0.models.Tax] = None,
    rounding: _root_.scala.Option[io.flow.v0.models.Rounding] = None
  )

  /**
   * Amount-currency paid for a basic price to be used in model forms, before a price
   * label is created. Label in the main price model is created by the implementing
   * api.
   */
  case class PriceForm(
    amount: Double,
    currency: String
  )

  /**
   * Pricing determines how the item price is calculated when items are requests via
   * the experience.
   */
  case class Pricing(
    vat: io.flow.v0.models.PricingLevySetting,
    duty: io.flow.v0.models.PricingLevySetting,
    rounding: _root_.scala.Option[io.flow.v0.models.Rounding] = None
  )

  /**
   * A public key is used to encrypt cards client side prior to submitting to the
   * Flow vault.
   */
  case class PublicKey(
    id: String
  )

  /**
   * Represents a typed query to indicate which items to include or exclude in a
   * subcatalog
   */
  case class Query(
    id: String,
    q: String,
    `type`: io.flow.v0.models.QueryType
  )

  /**
   * Defines a query specifying items to be included or excluded in a subcatalog
   */
  case class QueryForm(
    q: String,
    `type`: io.flow.v0.models.QueryType
  )

  /**
   * Represents a collection of deliveries and available options for fulfillment of
   * that delivery
   */
  case class Quote(
    id: String,
    destination: io.flow.v0.models.ShippingAddress,
    deliveries: Seq[io.flow.v0.models.Delivery],
    selections: Seq[io.flow.v0.models.DeliveryOptionReference]
  )

  case class QuoteForm(
    destination: io.flow.v0.models.ShippingAddress,
    experience: String,
    items: Seq[io.flow.v0.models.LineItem]
  )

  case class QuoteSummary(
    id: String,
    destination: io.flow.v0.models.ShippingAddress
  )

  case class QuoteVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    quote: io.flow.v0.models.QuoteSummary
  )

  /**
   * Represents an organization-specific currency conversion rate at a point in time.
   */
  case class Rate(
    id: String,
    base: String,
    target: String,
    effectiveAt: _root_.org.joda.time.DateTime,
    value: BigDecimal
  )

  case class RateDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    rateId: String
  ) extends Event

  /**
   * Represents the parts of an organization rate that can be updated.
   */
  case class RateForm(
    base: String,
    target: String,
    effectiveAt: _root_.org.joda.time.DateTime
  )

  case class RateUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    rateId: String,
    organizationId: String,
    base: String,
    target: String,
    effectiveAt: _root_.org.joda.time.DateTime,
    value: BigDecimal
  ) extends Event

  case class RateVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    rate: io.flow.v0.models.Rate
  )

  /**
   * Refunds are used to issue refunds against a prior capture.
   */
  case class Refund(
    id: String,
    key: String,
    capture: io.flow.v0.models.Capture,
    amount: BigDecimal,
    currency: String
  )

  /**
   * Refund actually transfers funds. You can refund as many times as you'd like up
   * until the total amount of the capture has been refunded.
   */
  case class RefundForm(
    captureId: String,
    key: _root_.scala.Option[String] = None,
    amount: _root_.scala.Option[BigDecimal] = None,
    currency: _root_.scala.Option[String] = None
  )

  case class RefundVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    refund: io.flow.v0.models.Refund
  )

  /**
   * A region represents a geographic area of the world. Regions can be countries,
   * continents or other political areas (like the Eurozone).
   */
  case class Region(
    id: String,
    name: String,
    countries: Seq[String],
    currencies: Seq[String],
    languages: Seq[String],
    measurementSystems: Seq[String],
    timezones: Seq[String]
  )

  case class RegionReference(
    id: String
  )

  case class Rounding(
    `type`: io.flow.v0.models.RoundingType,
    method: io.flow.v0.models.RoundingMethod,
    value: BigDecimal
  )

  /**
   * Represents operating calendar and holidays of a center
   */
  case class Schedule(
    calendar: _root_.scala.Option[io.flow.v0.models.Calendar] = None,
    holiday: io.flow.v0.models.HolidayCalendar,
    exception: Seq[io.flow.v0.models.Exception],
    cutoff: _root_.scala.Option[String] = None
  )

  /**
   * Specific service rendered by the carrier (fedex ground saturday, ups overnight
   * weekend, etc)
   */
  case class Service(
    id: String,
    carrier: io.flow.v0.models.Carrier,
    name: String
  )

  case class ServiceReference(
    id: String
  )

  case class ServiceSummary(
    id: String,
    carrier: io.flow.v0.models.CarrierReference,
    name: String
  )

  case class ShippingAddress(
    contact: io.flow.v0.models.Contact,
    location: io.flow.v0.models.Address
  )

  /**
   * Represents information about a carrier-generated shipping label used by a
   * shipper to transport a package from a given origin to destination
   */
  case class ShippingLabel(
    id: String,
    carrierTrackingNumber: String,
    commercialInvoice: String,
    data: String,
    destination: io.flow.v0.models.ShippingAddress,
    flowTrackingNumber: String,
    origin: io.flow.v0.models.ShippingAddress,
    service: io.flow.v0.models.ServiceSummary,
    window: io.flow.v0.models.DatetimeRange,
    pdf: _root_.scala.Option[String] = None,
    png: _root_.scala.Option[String] = None
  )

  case class ShippingLabelForm(
    service: String,
    deliveredDuty: io.flow.v0.models.DeliveredDuty,
    destination: io.flow.v0.models.ShippingAddress,
    origin: io.flow.v0.models.ShippingAddress,
    packages: Seq[io.flow.v0.models.ShippingLabelPackage],
    insurance: _root_.scala.Option[io.flow.v0.models.Price] = None
  )

  /**
   * Describes a package to be shipped, including dimensions and items included
   */
  case class ShippingLabelPackage(
    dimensions: io.flow.v0.models.Dimension,
    items: Seq[io.flow.v0.models.LineItem]
  )

  case class ShippingLabelVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    shippingLabel: io.flow.v0.models.ShippingLabel
  )

  case class SpotRate(
    id: String,
    effectiveAt: _root_.org.joda.time.DateTime,
    base: String,
    target: String,
    value: BigDecimal
  )

  case class SpotRateDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    spotRateId: String
  ) extends Event

  case class SpotRateForm(
    effectiveAt: _root_.org.joda.time.DateTime,
    base: String,
    target: String,
    value: BigDecimal
  )

  case class SpotRateUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    spotRateId: String,
    base: String,
    target: String,
    value: BigDecimal,
    effectiveAt: _root_.org.joda.time.DateTime
  ) extends Event

  case class SpotRateVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    spotRate: io.flow.v0.models.SpotRate
  )

  /**
   * A configuration with custom query to select a subset of master catalog items for
   * a localized experience
   */
  case class Subcatalog(
    id: String,
    catalog: io.flow.v0.models.Catalog,
    settings: io.flow.v0.models.SubcatalogSettings
  ) extends ExpandableSubcatalog

  case class SubcatalogDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    catalog: String,
    subcatalogId: String
  ) extends Event

  case class SubcatalogForm(
    settings: _root_.scala.Option[io.flow.v0.models.SubcatalogSettingsForm] = None
  )

  case class SubcatalogFunction(
    id: String,
    itemFunction: io.flow.v0.models.ItemFunction,
    q: String,
    position: Long
  )

  case class SubcatalogFunctionForm(
    itemFunctionId: String,
    q: _root_.scala.Option[String] = None,
    position: _root_.scala.Option[Long] = None
  )

  case class SubcatalogFunctionVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    subcatalogFunction: io.flow.v0.models.SubcatalogFunction
  )

  /**
   * Represents information specific to an item in a given subcatalog
   */
  case class SubcatalogItem(
    id: String,
    item: io.flow.v0.models.Item,
    itemFunction: _root_.scala.Option[io.flow.v0.models.ExpandableItemFunction] = None,
    itemStatus: io.flow.v0.models.SubcatalogItemStatus
  )

  case class SubcatalogItemDeleted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    catalog: String,
    subcatalogId: String
  ) extends Event

  case class SubcatalogItemUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    number: String,
    catalog: String,
    subcatalogId: String,
    status: String,
    functionId: _root_.scala.Option[String] = None
  ) extends Event

  case class SubcatalogReference(
    id: String
  ) extends ExpandableSubcatalog

  case class SubcatalogSettings(
    updatePolicy: io.flow.v0.models.UpdatePolicy = io.flow.v0.models.UpdatePolicy.Auto
  )

  case class SubcatalogSettingsForm(
    updatePolicy: _root_.scala.Option[io.flow.v0.models.UpdatePolicy] = None
  )

  /**
   * Statistics related to the items in this subcatalog, including item count, number
   * of distinct categories, etc.
   */
  case class SubcatalogStatistics(
    excluded: io.flow.v0.models.ItemStatistics,
    included: io.flow.v0.models.ItemStatistics,
    restricted: io.flow.v0.models.ItemStatistics,
    queue: io.flow.v0.models.ItemStatistics,
    catalog: io.flow.v0.models.CatalogStatistics
  )

  case class SubcatalogUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    catalog: String,
    subcatalogId: String
  ) extends Event

  case class SubcatalogVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    subcatalog: io.flow.v0.models.Subcatalog
  )

  case class Suggestion(
    label: String,
    count: Long
  )

  /**
   * Represents a simple model of taxes that apply to a given item / destination.
   */
  case class Tax(
    name: String,
    rate: BigDecimal,
    components: Seq[io.flow.v0.models.LevyComponent],
    deminimus: _root_.scala.Option[io.flow.v0.models.Deminimus] = None
  )

  /**
   * Service shipping tier available in this tier gorup. e.g. Standard tier, Express
   * tier, Economy tier
   */
  case class Tier(
    id: String,
    experience: io.flow.v0.models.FulfillmentExperienceReference,
    integration: io.flow.v0.models.ShipmentIntegrationType,
    name: String,
    rules: Seq[io.flow.v0.models.TierRule],
    services: Seq[io.flow.v0.models.Service],
    strategy: io.flow.v0.models.TierStrategy,
    visibility: io.flow.v0.models.Visibility
  )

  /**
   * Grouping of shipping tiers by experience to provide logical default
   * functionality.
   */
  case class TierDefault(
    id: String,
    defaultTier: io.flow.v0.models.TierReference,
    experience: io.flow.v0.models.FulfillmentExperienceReference
  )

  /**
   * Form to set the defualt tier for a given experience
   */
  case class TierDefaultForm(
    defaultTier: String,
    currency: String,
    experience: String
  )

  case class TierDefaultVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    tierDefault: io.flow.v0.models.TierDefault
  )

  /**
   * Service shipping tier available in this tier gorup. e.g. Standard tier, Express
   * tier, Economy tier
   */
  case class TierForm(
    currency: String,
    experience: String,
    integration: io.flow.v0.models.ShipmentIntegrationType,
    name: String,
    rules: Seq[io.flow.v0.models.TierRuleForm],
    services: Seq[String],
    strategy: io.flow.v0.models.TierStrategy,
    visibility: io.flow.v0.models.Visibility
  )

  case class TierReference(
    id: String
  )

  /**
   * System to filter incoming quote for a shipment request based on a query and
   * output corresponding outcomes.
   */
  case class TierRule(
    id: String,
    position: Long,
    query: String,
    outcome: io.flow.v0.models.TierRuleOutcome
  )

  case class TierRuleForm(
    position: _root_.scala.Option[Long] = None,
    query: String,
    outcome: io.flow.v0.models.TierRuleOutcome
  )

  case class TierRuleVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    tierRule: io.flow.v0.models.TierRule
  )

  case class TierSummary(
    id: String,
    experience: io.flow.v0.models.FulfillmentExperienceReference,
    integration: io.flow.v0.models.ShipmentIntegrationType,
    name: String,
    services: Seq[String],
    strategy: io.flow.v0.models.TierStrategy,
    visibility: io.flow.v0.models.Visibility
  )

  case class TierVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    tier: io.flow.v0.models.TierSummary
  )

  /**
   * Time zone data is provided by the public IANA time zone database. See
   * http://www.iana.org/time-zones
   */
  case class Timezone(
    name: String,
    description: String,
    offset: Int
  )

  /**
   * All of the metadata associated with a given token.
   */
  case class Token(
    id: String,
    user: io.flow.v0.models.UserReference,
    partial: String,
    createdAt: _root_.org.joda.time.DateTime,
    description: _root_.scala.Option[String] = None
  )

  /**
   * Used to authenticate a given token.
   */
  case class TokenAuthenticationForm(
    token: String
  )

  /**
   * Used to create a new token for the user authorized by the request. You can only
   * create an API token for your own account.
   */
  case class TokenForm(
    description: _root_.scala.Option[String] = None
  )

  /**
   * Summary data for a given token
   */
  case class TokenReference(
    id: String,
    user: io.flow.v0.models.UserReference
  )

  case class TokenVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    token: io.flow.v0.models.Token
  )

  /**
   * Top level tracking information which contains labels. In cases where shipments
   * are re-labeled, you will see multiple labels for each tracking allowing simple
   * access to see where a shipment is - with which carrier and with the local
   * tracking number
   */
  case class Tracking(
    id: String,
    status: io.flow.v0.models.TrackingStatus,
    metadata: _root_.play.api.libs.json.JsObject
  )

  /**
   * Top level tracking information which contains labels. In cases where shipments
   * are re-labeled, you will see multiple labels for each tracking allowing simple
   * access to see where a shipment is - with which carrier and with the local
   * tracking number
   */
  case class TrackingForm(
    status: _root_.scala.Option[io.flow.v0.models.TrackingStatus] = None,
    metadata: _root_.scala.Option[_root_.play.api.libs.json.JsObject] = None
  )

  case class TrackingLabelEventUpserted(
    eventId: String,
    timestamp: _root_.org.joda.time.DateTime,
    organization: String,
    address: _root_.play.api.libs.json.JsObject,
    carrier: String,
    carrierTimestamp: _root_.org.joda.time.DateTime,
    carrierTrackingNumber: String,
    flowTrackingNumnber: String,
    status: String,
    deliveryEstimate: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    description: _root_.scala.Option[String] = None
  ) extends Event

  case class TrackingSummary(
    id: String,
    status: io.flow.v0.models.TrackingStatus
  )

  case class TrackingVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    tracking: io.flow.v0.models.TrackingSummary
  )

  /**
   * Represents a single user in the system
   */
  case class User(
    id: String,
    email: _root_.scala.Option[String] = None,
    name: io.flow.v0.models.Name
  ) extends ExpandableUser

  case class UserForm(
    email: _root_.scala.Option[String] = None,
    password: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[io.flow.v0.models.NameForm] = None
  )

  case class UserPutForm(
    email: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[io.flow.v0.models.NameForm] = None
  )

  case class UserReference(
    id: String
  ) extends ExpandableUser

  case class UserSummary(
    id: String,
    email: _root_.scala.Option[String] = None,
    name: String
  )

  case class UserVersion(
    id: String,
    timestamp: _root_.org.joda.time.DateTime,
    `type`: io.flow.v0.models.ChangeType,
    user: io.flow.v0.models.User
  )

  /**
   * Model used to report whether or not a given token is valid
   */
  case class Validation(
    status: String
  )

  /**
   * Defines the payload of a request to validate a token, with primary goal of
   * preventing the token from being included in an HTTP GET.
   */
  case class ValidationForm(
    token: String
  )

  case class Webhook(
    id: String,
    url: String,
    events: Seq[io.flow.v0.models.EventType]
  )

  case class WebhookForm(
    url: String,
    events: Seq[io.flow.v0.models.EventType]
  )

  case class WebhookReference(
    id: String
  )

  case class WebhookRequest(
    id: String,
    webhook: io.flow.v0.models.WebhookReference,
    headers: Seq[io.flow.v0.models.Header],
    method: io.flow.v0.models.Method,
    body: String,
    status: io.flow.v0.models.WebhookRequestStatus,
    startedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    completedAt: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    durationMs: _root_.scala.Option[Long] = None,
    response: _root_.scala.Option[io.flow.v0.models.WebhookResponse] = None,
    error: _root_.scala.Option[String] = None
  )

  case class WebhookRequestReference(
    id: String
  )

  case class WebhookResponse(
    id: String,
    request: io.flow.v0.models.WebhookRequestReference,
    headers: Seq[io.flow.v0.models.Header],
    body: String,
    status: Int
  )

  case class Zone(
    province: _root_.scala.Option[String] = None,
    country: String
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AuthorizationForm, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   */
  case class AuthorizationFormUndefinedType(
    description: String
  ) extends AuthorizationForm

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Deminimus, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   */
  case class DeminimusUndefinedType(
    description: String
  ) extends Deminimus

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Document, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   */
  case class DocumentUndefinedType(
    description: String
  ) extends Document

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Event, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   */
  case class EventUndefinedType(
    description: String
  ) extends Event

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableItemFunction, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   */
  case class ExpandableItemFunctionUndefinedType(
    description: String
  ) extends ExpandableItemFunction

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableOrganization, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   */
  case class ExpandableOrganizationUndefinedType(
    description: String
  ) extends ExpandableOrganization

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableSubcatalog, it will need to be handled in the client
   * code. This implementation will deserialize these future types as an instance of
   * this class.
   */
  case class ExpandableSubcatalogUndefinedType(
    description: String
  ) extends ExpandableSubcatalog

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ExpandableUser, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   */
  case class ExpandableUserUndefinedType(
    description: String
  ) extends ExpandableUser

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union InventoryStrategy, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   */
  case class InventoryStrategyUndefinedType(
    description: String
  ) extends InventoryStrategy

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union TierRuleOutcome, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   */
  case class TierRuleOutcomeUndefinedType(
    description: String
  ) extends TierRuleOutcome

  /**
   * Contains more detail related to the reason for which an authorization was
   * declined.
   */
  sealed trait AuthorizationDeclineCode

  object AuthorizationDeclineCode {

    /**
     * Payment method has expired
     */
    case object Expired extends AuthorizationDeclineCode { override def toString = "expired" }
    /**
     * Invalid payment number
     */
    case object InvalidNumber extends AuthorizationDeclineCode { override def toString = "invalid_number" }
    /**
     * Invalid expiration date
     */
    case object InvalidExpiration extends AuthorizationDeclineCode { override def toString = "invalid_expiration" }
    /**
     * The provided payment method is not known by the issuing bank (the account does
     * not exist)
     */
    case object NoAccount extends AuthorizationDeclineCode { override def toString = "no_account" }
    /**
     * Declined due to avs mismatch)
     */
    case object Avs extends AuthorizationDeclineCode { override def toString = "avs" }
    /**
     * Declined due to cvv mismatch)
     */
    case object Cvv extends AuthorizationDeclineCode { override def toString = "cvv" }
    /**
     * Declined due to suspected fraud
     */
    case object Fraud extends AuthorizationDeclineCode { override def toString = "fraud" }
    /**
     * Declined due to suspected duplicate transaction
     */
    case object Duplicate extends AuthorizationDeclineCode { override def toString = "duplicate" }
    /**
     * Declined due to another reason (details not known)
     */
    case object Unknown extends AuthorizationDeclineCode { override def toString = "unknown" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends AuthorizationDeclineCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Expired, InvalidNumber, InvalidExpiration, NoAccount, Avs, Cvv, Fraud, Duplicate, Unknown)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationDeclineCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationDeclineCode] = byName.get(value.toLowerCase)

  }

  sealed trait AuthorizationStatus

  object AuthorizationStatus {

    /**
     * If an immediate response is not available, the state will be 'pending' - this
     * usually indicates fraud review requires additional time / verification (or a
     * potential network issue with the issuing bank)
     */
    case object Pending extends AuthorizationStatus { override def toString = "pending" }
    /**
     * Bank is requesting consumer contact them directly to authorize the transaction
     */
    case object PendingCallBank extends AuthorizationStatus { override def toString = "pending_call_bank" }
    /**
     * Authorization was successful
     */
    case object Authorized extends AuthorizationStatus { override def toString = "authorized" }
    /**
     * Indicates the authorization has been declined by the issuing bank. See the
     * authorization decline code for more details as to the reason for decline.
     */
    case object Declined extends AuthorizationStatus { override def toString = "declined" }
    /**
     * Indicates the authorization has been voided. You can void an authorization up
     * until the moment you capture funds; once you have captured funds you must create
     * refunds.
     */
    case object Voided extends AuthorizationStatus { override def toString = "voided" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends AuthorizationStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Pending, PendingCallBank, Authorized, Declined, Voided)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthorizationStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthorizationStatus] = byName.get(value.toLowerCase)

  }

  sealed trait AvsCode

  object AvsCode {

    /**
     * Full match
     */
    case object Match extends AvsCode { override def toString = "match" }
    /**
     * Partial match; see details in 'avs' model to undestand which components matched
     */
    case object Partial extends AvsCode { override def toString = "partial" }
    /**
     * Issuer does not support address verification
     */
    case object Unsupported extends AvsCode { override def toString = "unsupported" }
    /**
     * Address does not match expected card values
     */
    case object NoMatch extends AvsCode { override def toString = "no_match" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends AvsCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Match, Partial, Unsupported, NoMatch)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AvsCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AvsCode] = byName.get(value.toLowerCase)

  }

  sealed trait Calendar

  object Calendar {

    /**
     * Mon - Fri
     */
    case object Weekdays extends Calendar { override def toString = "weekdays" }
    /**
     * 7 days per week
     */
    case object Everyday extends Calendar { override def toString = "everyday" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Calendar

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Weekdays, Everyday)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Calendar = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Calendar] = byName.get(value.toLowerCase)

  }

  sealed trait Capability

  object Capability {

    case object Crossdock extends Capability { override def toString = "crossdock" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Capability

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Crossdock)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Capability = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Capability] = byName.get(value.toLowerCase)

  }

  sealed trait CardType

  object CardType {

    case object AmericanExpress extends CardType { override def toString = "american_express" }
    case object ChinaUnionPay extends CardType { override def toString = "china_union_pay" }
    case object Dankort extends CardType { override def toString = "dankort" }
    case object DinersClub extends CardType { override def toString = "diners_club" }
    case object Discover extends CardType { override def toString = "discover" }
    case object Jcb extends CardType { override def toString = "jcb" }
    case object Maestro extends CardType { override def toString = "maestro" }
    case object Mastercard extends CardType { override def toString = "mastercard" }
    case object Visa extends CardType { override def toString = "visa" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends CardType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(AmericanExpress, ChinaUnionPay, Dankort, DinersClub, Discover, Jcb, Maestro, Mastercard, Visa)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CardType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CardType] = byName.get(value.toLowerCase)

  }

  sealed trait ChangeType

  object ChangeType {

    case object Insert extends ChangeType { override def toString = "insert" }
    case object Update extends ChangeType { override def toString = "update" }
    case object Delete extends ChangeType { override def toString = "delete" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ChangeType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Insert, Update, Delete)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ChangeType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ChangeType] = byName.get(value.toLowerCase)

  }

  sealed trait CvvCode

  object CvvCode {

    /**
     * CVV matches
     */
    case object Match extends CvvCode { override def toString = "match" }
    /**
     * CVV did not match; Transaction is possibly fraudulent
     */
    case object Suspicious extends CvvCode { override def toString = "suspicious" }
    /**
     * CVV did not match; Issuer does not support card verification numbers
     */
    case object Unsupported extends CvvCode { override def toString = "unsupported" }
    /**
     * CVV did not match; Specific reason not available
     */
    case object NoMatch extends CvvCode { override def toString = "no_match" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends CvvCode

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Match, Suspicious, Unsupported, NoMatch)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): CvvCode = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[CvvCode] = byName.get(value.toLowerCase)

  }

  sealed trait DeliveredDuty

  object DeliveredDuty {

    /**
     * DDP
     */
    case object Paid extends DeliveredDuty { override def toString = "paid" }
    /**
     * DDU
     */
    case object Unpaid extends DeliveredDuty { override def toString = "unpaid" }
    case object Choice extends DeliveredDuty { override def toString = "choice" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends DeliveredDuty

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Paid, Unpaid, Choice)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DeliveredDuty = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DeliveredDuty] = byName.get(value.toLowerCase)

  }

  sealed trait Environment

  object Environment {

    /**
     * In sandbox, no external services (e.g. payments, logistics) will generate real
     * transactions
     */
    case object Sandbox extends Environment { override def toString = "sandbox" }
    /**
     * In production, all external services are live and will generate real
     * transactions
     */
    case object Production extends Environment { override def toString = "production" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Environment

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Sandbox, Production)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Environment = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Environment] = byName.get(value.toLowerCase)

  }

  sealed trait EventType

  object EventType {

    case object CatalogUpserted extends EventType { override def toString = "catalog_upserted" }
    case object CatalogDeleted extends EventType { override def toString = "catalog_deleted" }
    case object SubcatalogUpserted extends EventType { override def toString = "subcatalog_upserted" }
    case object SubcatalogDeleted extends EventType { override def toString = "subcatalog_deleted" }
    case object CatalogItemUpserted extends EventType { override def toString = "catalog_item_upserted" }
    case object CatalogItemDeleted extends EventType { override def toString = "catalog_item_deleted" }
    case object SubcatalogItemUpserted extends EventType { override def toString = "subcatalog_item_upserted" }
    case object SubcatalogItemDeleted extends EventType { override def toString = "subcatalog_item_deleted" }
    case object FlowCurrencySettingDeleted extends EventType { override def toString = "flow_currency_setting_deleted" }
    case object FlowCurrencySettingUpserted extends EventType { override def toString = "flow_currency_setting_upserted" }
    case object RateDeleted extends EventType { override def toString = "rate_deleted" }
    case object RateUpserted extends EventType { override def toString = "rate_upserted" }
    case object SpotRateDeleted extends EventType { override def toString = "spot_rate_deleted" }
    case object SpotRateUpserted extends EventType { override def toString = "spot_rate_upserted" }
    case object OrganizationCurrencySettingDeleted extends EventType { override def toString = "organization_currency_setting_deleted" }
    case object OrganizationCurrencySettingUpserted extends EventType { override def toString = "organization_currency_setting_upserted" }
    case object ContractedRateUpserted extends EventType { override def toString = "contracted_rate_upserted" }
    case object ExperienceDeleted extends EventType { override def toString = "experience_deleted" }
    case object ExperienceUpserted extends EventType { override def toString = "experience_upserted" }
    case object ItemMarginDeleted extends EventType { override def toString = "item_margin_deleted" }
    case object ItemMarginUpserted extends EventType { override def toString = "item_margin_upserted" }
    case object Hs6CodeUpserted extends EventType { override def toString = "hs6_code_upserted" }
    case object Hs6CodeDeleted extends EventType { override def toString = "hs6_code_deleted" }
    case object Hs10CodeUpserted extends EventType { override def toString = "hs10_code_upserted" }
    case object Hs10CodeDeleted extends EventType { override def toString = "hs10_code_deleted" }
    case object LocalizedItemUpserted extends EventType { override def toString = "localized_item_upserted" }
    case object LocalizedItemDeleted extends EventType { override def toString = "localized_item_deleted" }
    case object OrganizationUpserted extends EventType { override def toString = "organization_upserted" }
    case object OrganizationDeleted extends EventType { override def toString = "organization_deleted" }
    case object TrackingLabelEventUpserted extends EventType { override def toString = "tracking_label_event_upserted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends EventType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(CatalogUpserted, CatalogDeleted, SubcatalogUpserted, SubcatalogDeleted, CatalogItemUpserted, CatalogItemDeleted, SubcatalogItemUpserted, SubcatalogItemDeleted, FlowCurrencySettingDeleted, FlowCurrencySettingUpserted, RateDeleted, RateUpserted, SpotRateDeleted, SpotRateUpserted, OrganizationCurrencySettingDeleted, OrganizationCurrencySettingUpserted, ContractedRateUpserted, ExperienceDeleted, ExperienceUpserted, ItemMarginDeleted, ItemMarginUpserted, Hs6CodeUpserted, Hs6CodeDeleted, Hs10CodeUpserted, Hs10CodeDeleted, LocalizedItemUpserted, LocalizedItemDeleted, OrganizationUpserted, OrganizationDeleted, TrackingLabelEventUpserted)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): EventType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[EventType] = byName.get(value.toLowerCase)

  }

  sealed trait ExceptionType

  object ExceptionType {

    case object Open extends ExceptionType { override def toString = "open" }
    case object Closed extends ExceptionType { override def toString = "closed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ExceptionType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Open, Closed)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ExceptionType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ExceptionType] = byName.get(value.toLowerCase)

  }

  sealed trait HolidayCalendar

  object HolidayCalendar {

    case object UsBankHolidays extends HolidayCalendar { override def toString = "us_bank_holidays" }
    case object JewishHolidays extends HolidayCalendar { override def toString = "jewish_holidays" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends HolidayCalendar

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(UsBankHolidays, JewishHolidays)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): HolidayCalendar = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[HolidayCalendar] = byName.get(value.toLowerCase)

  }

  sealed trait LevyComponent

  object LevyComponent {

    /**
     * The value of goods
     */
    case object Goods extends LevyComponent { override def toString = "goods" }
    case object Duty extends LevyComponent { override def toString = "duty" }
    case object Insurance extends LevyComponent { override def toString = "insurance" }
    case object Freight extends LevyComponent { override def toString = "freight" }
    /**
     * Value-Added Tax
     */
    case object Vat extends LevyComponent { override def toString = "vat" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LevyComponent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Goods, Duty, Insurance, Freight, Vat)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LevyComponent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LevyComponent] = byName.get(value.toLowerCase)

  }

  sealed trait LevyStrategy

  object LevyStrategy {

    case object Minimum extends LevyStrategy { override def toString = "minimum" }
    case object Average extends LevyStrategy { override def toString = "average" }
    case object Maximum extends LevyStrategy { override def toString = "maximum" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LevyStrategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Minimum, Average, Maximum)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LevyStrategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LevyStrategy] = byName.get(value.toLowerCase)

  }

  /**
   * The localized prices for an item are returned as a list - the key of each
   * element is defined here
   */
  sealed trait LocalizedPriceKey

  object LocalizedPriceKey {

    /**
     * The calculated price, taking into account pricing settings. For example, if vat
     * is set to be included in the price, this value will be equal to subtotal + vat,
     * rounded per the settings. This is the price you should lead with when displaying
     * to consumers
     */
    case object Price extends LocalizedPriceKey { override def toString = "price" }
    case object Subtotal extends LocalizedPriceKey { override def toString = "subtotal" }
    case object Vat extends LocalizedPriceKey { override def toString = "vat" }
    case object Duty extends LocalizedPriceKey { override def toString = "duty" }
    case object Discount extends LocalizedPriceKey { override def toString = "discount" }
    case object Shipping extends LocalizedPriceKey { override def toString = "shipping" }
    case object Total extends LocalizedPriceKey { override def toString = "total" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends LocalizedPriceKey

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Price, Subtotal, Vat, Duty, Discount, Shipping, Total)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): LocalizedPriceKey = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[LocalizedPriceKey] = byName.get(value.toLowerCase)

  }

  /**
   * Either a fixed or percent adjustment applied to some amount.
   */
  sealed trait MarginType

  object MarginType {

    /**
     * A fixed amount to add, e.g $1.25.
     */
    case object Fixed extends MarginType { override def toString = "fixed" }
    /**
     * A percent of the base cost to add, e.g. 0.52 (52%).
     */
    case object Percent extends MarginType { override def toString = "percent" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends MarginType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Fixed, Percent)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): MarginType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[MarginType] = byName.get(value.toLowerCase)

  }

  sealed trait MeasurementSystem

  object MeasurementSystem {

    case object Imperial extends MeasurementSystem { override def toString = "imperial" }
    case object Metric extends MeasurementSystem { override def toString = "metric" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends MeasurementSystem

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Imperial, Metric)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): MeasurementSystem = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[MeasurementSystem] = byName.get(value.toLowerCase)

  }

  /**
   * The available methods by which we deliver each webhook event
   */
  sealed trait Method

  object Method {

    case object Post extends Method { override def toString = "post" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Method

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Post)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Method = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Method] = byName.get(value.toLowerCase)

  }

  sealed trait PricingLevySetting

  object PricingLevySetting {

    case object Included extends PricingLevySetting { override def toString = "included" }
    case object Displayed extends PricingLevySetting { override def toString = "displayed" }
    case object Ignored extends PricingLevySetting { override def toString = "ignored" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends PricingLevySetting

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Included, Displayed, Ignored)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): PricingLevySetting = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[PricingLevySetting] = byName.get(value.toLowerCase)

  }

  /**
   * Type to indicate whether query is an inclusion or exclusion
   */
  sealed trait QueryType

  object QueryType {

    /**
     * Exclude items satisfied by the associated query
     */
    case object Exclusion extends QueryType { override def toString = "exclusion" }
    /**
     * Include items satisfied by the associated query
     */
    case object Inclusion extends QueryType { override def toString = "inclusion" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends QueryType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Exclusion, Inclusion)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): QueryType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[QueryType] = byName.get(value.toLowerCase)

  }

  /**
   * A user's role within an organization
   */
  sealed trait Role

  object Role {

    case object Admin extends Role { override def toString = "admin" }
    case object Member extends Role { override def toString = "member" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Role

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Admin, Member)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Role = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Role] = byName.get(value.toLowerCase)

  }

  /**
   * Direction to round localized price
   */
  sealed trait RoundingMethod

  object RoundingMethod {

    /**
     * Round up to the specified rounding.value
     */
    case object Up extends RoundingMethod { override def toString = "up" }
    /**
     * Round down to the specified rounding.value
     */
    case object Down extends RoundingMethod { override def toString = "down" }
    /**
     * Round to the nearest specified rounding.value. If equidistant, will round up.
     */
    case object Nearest extends RoundingMethod { override def toString = "nearest" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends RoundingMethod

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Up, Down, Nearest)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RoundingMethod = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RoundingMethod] = byName.get(value.toLowerCase)

  }

  /**
   * The type of rounding to perform.
   */
  sealed trait RoundingType

  object RoundingType {

    /**
     * Rounds a value to an amount ending with a pattern, e.g. an amount ending in
     * '.99'.
     */
    case object Pattern extends RoundingType { override def toString = "pattern" }
    /**
     * Rounds a value to an amount that is the multiple of a value, e.g. rounding to
     * the nearest 1000.
     */
    case object Multiple extends RoundingType { override def toString = "multiple" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends RoundingType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Pattern, Multiple)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): RoundingType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[RoundingType] = byName.get(value.toLowerCase)

  }

  /**
   * Pending better name
   */
  sealed trait ScheduleExceptionStatus

  object ScheduleExceptionStatus {

    case object Open extends ScheduleExceptionStatus { override def toString = "Open" }
    case object Closed extends ScheduleExceptionStatus { override def toString = "Closed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ScheduleExceptionStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Open, Closed)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ScheduleExceptionStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ScheduleExceptionStatus] = byName.get(value.toLowerCase)

  }

  /**
   * Type of shipping integration for a given shipping tier
   */
  sealed trait ShipmentIntegrationType

  object ShipmentIntegrationType {

    /**
     * Always generate a label for the chosen delivery option.
     */
    case object Direct extends ShipmentIntegrationType { override def toString = "direct" }
    /**
     * Booking and label generation is not available. Just use Flow to calculate
     * delivery window estimates and shipment prices to display.
     */
    case object Information extends ShipmentIntegrationType { override def toString = "information" }
    /**
     * A generic label will be provided by the client organization when available as
     * pre-advice shipment notification to carrier partner.
     */
    case object Preadvice extends ShipmentIntegrationType { override def toString = "preadvice" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ShipmentIntegrationType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Direct, Information, Preadvice)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ShipmentIntegrationType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ShipmentIntegrationType] = byName.get(value.toLowerCase)

  }

  sealed trait SortDirection

  object SortDirection {

    case object Ascending extends SortDirection { override def toString = "ascending" }
    case object Descending extends SortDirection { override def toString = "descending" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends SortDirection

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Ascending, Descending)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SortDirection = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SortDirection] = byName.get(value.toLowerCase)

  }

  sealed trait Strategy

  object Strategy {

    /**
     * Tightest range
     */
    case object Range extends Strategy { override def toString = "range" }
    /**
     * Lowest minimum of the ranges
     */
    case object From extends Strategy { override def toString = "from" }
    /**
     * Lowest maximum of the ranges
     */
    case object To extends Strategy { override def toString = "to" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Strategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Range, From, To)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Strategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Strategy] = byName.get(value.toLowerCase)

  }

  /**
   * Status indicating availability of a subcatalog item in an experience.
   */
  sealed trait SubcatalogItemStatus

  object SubcatalogItemStatus {

    /**
     * Item is excluded based on targeting query.  This is separate from an item marked
     * as restricted.
     */
    case object Excluded extends SubcatalogItemStatus { override def toString = "excluded" }
    /**
     * Item is included
     */
    case object Included extends SubcatalogItemStatus { override def toString = "included" }
    /**
     * Item is restricted and will be treated as excluded
     */
    case object Restricted extends SubcatalogItemStatus { override def toString = "restricted" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends SubcatalogItemStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Excluded, Included, Restricted)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): SubcatalogItemStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[SubcatalogItemStatus] = byName.get(value.toLowerCase)

  }

  /**
   * Strategy to apply when there are multiple rates available for a tier
   */
  sealed trait TierStrategy

  object TierStrategy {

    /**
     * Optimize for fastest first, then cheapest
     */
    case object Fastest extends TierStrategy { override def toString = "fastest" }
    /**
     * Optimize for lowest cost first, then fastest
     */
    case object LowestCost extends TierStrategy { override def toString = "lowest_cost" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends TierStrategy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Fastest, LowestCost)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TierStrategy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TierStrategy] = byName.get(value.toLowerCase)

  }

  sealed trait TrackingStatus

  object TrackingStatus {

    case object Pending extends TrackingStatus { override def toString = "pending" }
    case object InfoReceived extends TrackingStatus { override def toString = "info_received" }
    case object InTransit extends TrackingStatus { override def toString = "in_transit" }
    case object OutForDelivery extends TrackingStatus { override def toString = "out_for_delivery" }
    case object AttemptFail extends TrackingStatus { override def toString = "attempt_fail" }
    case object Delivered extends TrackingStatus { override def toString = "delivered" }
    case object Exception extends TrackingStatus { override def toString = "exception" }
    case object Expired extends TrackingStatus { override def toString = "expired" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends TrackingStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Pending, InfoReceived, InTransit, OutForDelivery, AttemptFail, Delivered, Exception, Expired)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TrackingStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TrackingStatus] = byName.get(value.toLowerCase)

  }

  /**
   * Defines the units of measurement that we support. As units are added, we conform
   * with the standard units provided by jscience as part of JSR 363 - see
   * http://jscience.org/api/javax/measure/unit/SI.html and
   * http://jscience.org/api/javax/measure/unit/NonSI.html
   */
  sealed trait UnitOfMeasurement

  object UnitOfMeasurement {

    /**
     * Equivalent to MILLI(METRE).
     */
    case object Millimeter extends UnitOfMeasurement { override def toString = "millimeter" }
    /**
     * Equivalent to CENTI(METRE).
     */
    case object Centimeter extends UnitOfMeasurement { override def toString = "centimeter" }
    /**
     * A unit of length equal to 0.01004 m (standard name in).
     */
    case object Inch extends UnitOfMeasurement { override def toString = "inch" }
    /**
     * A unit of length equal to 0.3048 m (standard name ft).
     */
    case object Foot extends UnitOfMeasurement { override def toString = "foot" }
    /**
     * A unit of volume equal to one cubic inch (in).
     */
    case object CubicInch extends UnitOfMeasurement { override def toString = "cubic_inch" }
    /**
     * The metric unit for volume quantities (m).
     */
    case object CubicMeter extends UnitOfMeasurement { override def toString = "cubic_meter" }
    /**
     * A unit of mass equal to 1 / 1000 kilogram (standard name g).
     */
    case object Gram extends UnitOfMeasurement { override def toString = "gram" }
    /**
     * The base unit for mass quantities (kg).
     */
    case object Kilogram extends UnitOfMeasurement { override def toString = "kilogram" }
    /**
     * The base unit for length quantities (m).
     */
    case object Meter extends UnitOfMeasurement { override def toString = "meter" }
    /**
     * A unit of mass equal to 1 / 16 POUND (standard name oz).
     */
    case object Ounce extends UnitOfMeasurement { override def toString = "ounce" }
    /**
     * A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
     */
    case object Pound extends UnitOfMeasurement { override def toString = "pound" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends UnitOfMeasurement

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Millimeter, Centimeter, Inch, Foot, CubicInch, CubicMeter, Gram, Kilogram, Meter, Ounce, Pound)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UnitOfMeasurement = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UnitOfMeasurement] = byName.get(value.toLowerCase)

  }

  /**
   * Defines the units of time that we support. We confirm with the standard set of
   * units of time from
   * http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html
   */
  sealed trait UnitOfTime

  object UnitOfTime {

    case object Day extends UnitOfTime { override def toString = "day" }
    case object Hour extends UnitOfTime { override def toString = "hour" }
    case object Minute extends UnitOfTime { override def toString = "minute" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends UnitOfTime

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Day, Hour, Minute)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UnitOfTime = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UnitOfTime] = byName.get(value.toLowerCase)

  }

  sealed trait UpdatePolicy

  object UpdatePolicy {

    case object Auto extends UpdatePolicy { override def toString = "auto" }
    /**
     * Queue item update for approval.
     */
    case object Queue extends UpdatePolicy { override def toString = "queue" }
    case object Discard extends UpdatePolicy { override def toString = "discard" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends UpdatePolicy

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Auto, Queue, Discard)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UpdatePolicy = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UpdatePolicy] = byName.get(value.toLowerCase)

  }

  /**
   * Types of updates that can be made on quantity of inventory
   */
  sealed trait UpdateType

  object UpdateType {

    /**
     * Long value to increment or decrement. Positive quantities are added to inventory
     * while negative quantities are decrement from inventory.
     */
    case object Change extends UpdateType { override def toString = "change" }
    /**
     * Set aboluste quantity to new value with no regard for previous updates
     */
    case object Set extends UpdateType { override def toString = "set" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends UpdateType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Change, Set)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): UpdateType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[UpdateType] = byName.get(value.toLowerCase)

  }

  sealed trait ValueAddedService

  object ValueAddedService {

    /**
     * See https://en.wikipedia.org/wiki/ORM-D
     */
    case object HazardousMaterial extends ValueAddedService { override def toString = "Hazardous Material" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends ValueAddedService

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(HazardousMaterial)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ValueAddedService = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ValueAddedService] = byName.get(value.toLowerCase)

  }

  sealed trait Visibility

  object Visibility {

    case object Public extends Visibility { override def toString = "public" }
    case object Private extends Visibility { override def toString = "private" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends Visibility

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Public, Private)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Visibility = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Visibility] = byName.get(value.toLowerCase)

  }

  sealed trait WebhookRequestStatus

  object WebhookRequestStatus {

    case object Pending extends WebhookRequestStatus { override def toString = "pending" }
    case object Success extends WebhookRequestStatus { override def toString = "success" }
    case object Failure extends WebhookRequestStatus { override def toString = "failure" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    case class UNDEFINED(override val toString: String) extends WebhookRequestStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all = Seq(Pending, Success, Failure)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): WebhookRequestStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[WebhookRequestStatus] = byName.get(value.toLowerCase)

  }

}

package io.flow.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsApiAuthorizationDeclineCode = new play.api.libs.json.Reads[io.flow.v0.models.AuthorizationDeclineCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.AuthorizationDeclineCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.AuthorizationDeclineCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.AuthorizationDeclineCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiAuthorizationDeclineCode(obj: io.flow.v0.models.AuthorizationDeclineCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationDeclineCode(obj: io.flow.v0.models.AuthorizationDeclineCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiAuthorizationDeclineCode: play.api.libs.json.Writes[AuthorizationDeclineCode] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthorizationDeclineCode] {
        def writes(obj: io.flow.v0.models.AuthorizationDeclineCode) = {
          jsonWritesApiAuthorizationDeclineCode(obj)
        }
      }
    }

    implicit val jsonReadsApiAuthorizationStatus = new play.api.libs.json.Reads[io.flow.v0.models.AuthorizationStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.AuthorizationStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.AuthorizationStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.AuthorizationStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiAuthorizationStatus(obj: io.flow.v0.models.AuthorizationStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthorizationStatus(obj: io.flow.v0.models.AuthorizationStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiAuthorizationStatus: play.api.libs.json.Writes[AuthorizationStatus] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthorizationStatus] {
        def writes(obj: io.flow.v0.models.AuthorizationStatus) = {
          jsonWritesApiAuthorizationStatus(obj)
        }
      }
    }

    implicit val jsonReadsApiAvsCode = new play.api.libs.json.Reads[io.flow.v0.models.AvsCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.AvsCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.AvsCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.AvsCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiAvsCode(obj: io.flow.v0.models.AvsCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAvsCode(obj: io.flow.v0.models.AvsCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiAvsCode: play.api.libs.json.Writes[AvsCode] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AvsCode] {
        def writes(obj: io.flow.v0.models.AvsCode) = {
          jsonWritesApiAvsCode(obj)
        }
      }
    }

    implicit val jsonReadsApiCalendar = new play.api.libs.json.Reads[io.flow.v0.models.Calendar] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Calendar] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Calendar(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Calendar(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiCalendar(obj: io.flow.v0.models.Calendar) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCalendar(obj: io.flow.v0.models.Calendar) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiCalendar: play.api.libs.json.Writes[Calendar] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Calendar] {
        def writes(obj: io.flow.v0.models.Calendar) = {
          jsonWritesApiCalendar(obj)
        }
      }
    }

    implicit val jsonReadsApiCapability = new play.api.libs.json.Reads[io.flow.v0.models.Capability] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Capability] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Capability(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Capability(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiCapability(obj: io.flow.v0.models.Capability) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCapability(obj: io.flow.v0.models.Capability) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiCapability: play.api.libs.json.Writes[Capability] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Capability] {
        def writes(obj: io.flow.v0.models.Capability) = {
          jsonWritesApiCapability(obj)
        }
      }
    }

    implicit val jsonReadsApiCardType = new play.api.libs.json.Reads[io.flow.v0.models.CardType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.CardType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.CardType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.CardType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiCardType(obj: io.flow.v0.models.CardType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCardType(obj: io.flow.v0.models.CardType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiCardType: play.api.libs.json.Writes[CardType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CardType] {
        def writes(obj: io.flow.v0.models.CardType) = {
          jsonWritesApiCardType(obj)
        }
      }
    }

    implicit val jsonReadsApiChangeType = new play.api.libs.json.Reads[io.flow.v0.models.ChangeType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.ChangeType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.ChangeType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.ChangeType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiChangeType(obj: io.flow.v0.models.ChangeType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectChangeType(obj: io.flow.v0.models.ChangeType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiChangeType: play.api.libs.json.Writes[ChangeType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ChangeType] {
        def writes(obj: io.flow.v0.models.ChangeType) = {
          jsonWritesApiChangeType(obj)
        }
      }
    }

    implicit val jsonReadsApiCvvCode = new play.api.libs.json.Reads[io.flow.v0.models.CvvCode] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.CvvCode] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.CvvCode(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.CvvCode(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiCvvCode(obj: io.flow.v0.models.CvvCode) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectCvvCode(obj: io.flow.v0.models.CvvCode) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiCvvCode: play.api.libs.json.Writes[CvvCode] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CvvCode] {
        def writes(obj: io.flow.v0.models.CvvCode) = {
          jsonWritesApiCvvCode(obj)
        }
      }
    }

    implicit val jsonReadsApiDeliveredDuty = new play.api.libs.json.Reads[io.flow.v0.models.DeliveredDuty] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.DeliveredDuty] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.DeliveredDuty(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.DeliveredDuty(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiDeliveredDuty(obj: io.flow.v0.models.DeliveredDuty) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDeliveredDuty(obj: io.flow.v0.models.DeliveredDuty) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiDeliveredDuty: play.api.libs.json.Writes[DeliveredDuty] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveredDuty] {
        def writes(obj: io.flow.v0.models.DeliveredDuty) = {
          jsonWritesApiDeliveredDuty(obj)
        }
      }
    }

    implicit val jsonReadsApiEnvironment = new play.api.libs.json.Reads[io.flow.v0.models.Environment] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Environment] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Environment(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Environment(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiEnvironment(obj: io.flow.v0.models.Environment) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectEnvironment(obj: io.flow.v0.models.Environment) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiEnvironment: play.api.libs.json.Writes[Environment] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Environment] {
        def writes(obj: io.flow.v0.models.Environment) = {
          jsonWritesApiEnvironment(obj)
        }
      }
    }

    implicit val jsonReadsApiEventType = new play.api.libs.json.Reads[io.flow.v0.models.EventType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.EventType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.EventType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.EventType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiEventType(obj: io.flow.v0.models.EventType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectEventType(obj: io.flow.v0.models.EventType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiEventType: play.api.libs.json.Writes[EventType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.EventType] {
        def writes(obj: io.flow.v0.models.EventType) = {
          jsonWritesApiEventType(obj)
        }
      }
    }

    implicit val jsonReadsApiExceptionType = new play.api.libs.json.Reads[io.flow.v0.models.ExceptionType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.ExceptionType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.ExceptionType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.ExceptionType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiExceptionType(obj: io.flow.v0.models.ExceptionType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectExceptionType(obj: io.flow.v0.models.ExceptionType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiExceptionType: play.api.libs.json.Writes[ExceptionType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExceptionType] {
        def writes(obj: io.flow.v0.models.ExceptionType) = {
          jsonWritesApiExceptionType(obj)
        }
      }
    }

    implicit val jsonReadsApiHolidayCalendar = new play.api.libs.json.Reads[io.flow.v0.models.HolidayCalendar] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.HolidayCalendar] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.HolidayCalendar(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.HolidayCalendar(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiHolidayCalendar(obj: io.flow.v0.models.HolidayCalendar) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectHolidayCalendar(obj: io.flow.v0.models.HolidayCalendar) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiHolidayCalendar: play.api.libs.json.Writes[HolidayCalendar] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HolidayCalendar] {
        def writes(obj: io.flow.v0.models.HolidayCalendar) = {
          jsonWritesApiHolidayCalendar(obj)
        }
      }
    }

    implicit val jsonReadsApiLevyComponent = new play.api.libs.json.Reads[io.flow.v0.models.LevyComponent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.LevyComponent] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.LevyComponent(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.LevyComponent(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiLevyComponent(obj: io.flow.v0.models.LevyComponent) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLevyComponent(obj: io.flow.v0.models.LevyComponent) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiLevyComponent: play.api.libs.json.Writes[LevyComponent] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LevyComponent] {
        def writes(obj: io.flow.v0.models.LevyComponent) = {
          jsonWritesApiLevyComponent(obj)
        }
      }
    }

    implicit val jsonReadsApiLevyStrategy = new play.api.libs.json.Reads[io.flow.v0.models.LevyStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.LevyStrategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.LevyStrategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.LevyStrategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiLevyStrategy(obj: io.flow.v0.models.LevyStrategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLevyStrategy(obj: io.flow.v0.models.LevyStrategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiLevyStrategy: play.api.libs.json.Writes[LevyStrategy] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LevyStrategy] {
        def writes(obj: io.flow.v0.models.LevyStrategy) = {
          jsonWritesApiLevyStrategy(obj)
        }
      }
    }

    implicit val jsonReadsApiLocalizedPriceKey = new play.api.libs.json.Reads[io.flow.v0.models.LocalizedPriceKey] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.LocalizedPriceKey] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.LocalizedPriceKey(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.LocalizedPriceKey(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiLocalizedPriceKey(obj: io.flow.v0.models.LocalizedPriceKey) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectLocalizedPriceKey(obj: io.flow.v0.models.LocalizedPriceKey) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiLocalizedPriceKey: play.api.libs.json.Writes[LocalizedPriceKey] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LocalizedPriceKey] {
        def writes(obj: io.flow.v0.models.LocalizedPriceKey) = {
          jsonWritesApiLocalizedPriceKey(obj)
        }
      }
    }

    implicit val jsonReadsApiMarginType = new play.api.libs.json.Reads[io.flow.v0.models.MarginType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.MarginType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.MarginType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.MarginType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiMarginType(obj: io.flow.v0.models.MarginType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectMarginType(obj: io.flow.v0.models.MarginType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiMarginType: play.api.libs.json.Writes[MarginType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.MarginType] {
        def writes(obj: io.flow.v0.models.MarginType) = {
          jsonWritesApiMarginType(obj)
        }
      }
    }

    implicit val jsonReadsApiMeasurementSystem = new play.api.libs.json.Reads[io.flow.v0.models.MeasurementSystem] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.MeasurementSystem] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.MeasurementSystem(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.MeasurementSystem(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiMeasurementSystem(obj: io.flow.v0.models.MeasurementSystem) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectMeasurementSystem(obj: io.flow.v0.models.MeasurementSystem) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiMeasurementSystem: play.api.libs.json.Writes[MeasurementSystem] = {
      new play.api.libs.json.Writes[io.flow.v0.models.MeasurementSystem] {
        def writes(obj: io.flow.v0.models.MeasurementSystem) = {
          jsonWritesApiMeasurementSystem(obj)
        }
      }
    }

    implicit val jsonReadsApiMethod = new play.api.libs.json.Reads[io.flow.v0.models.Method] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Method] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Method(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Method(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiMethod(obj: io.flow.v0.models.Method) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectMethod(obj: io.flow.v0.models.Method) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiMethod: play.api.libs.json.Writes[Method] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Method] {
        def writes(obj: io.flow.v0.models.Method) = {
          jsonWritesApiMethod(obj)
        }
      }
    }

    implicit val jsonReadsApiPricingLevySetting = new play.api.libs.json.Reads[io.flow.v0.models.PricingLevySetting] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.PricingLevySetting] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.PricingLevySetting(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.PricingLevySetting(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiPricingLevySetting(obj: io.flow.v0.models.PricingLevySetting) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectPricingLevySetting(obj: io.flow.v0.models.PricingLevySetting) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiPricingLevySetting: play.api.libs.json.Writes[PricingLevySetting] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PricingLevySetting] {
        def writes(obj: io.flow.v0.models.PricingLevySetting) = {
          jsonWritesApiPricingLevySetting(obj)
        }
      }
    }

    implicit val jsonReadsApiQueryType = new play.api.libs.json.Reads[io.flow.v0.models.QueryType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.QueryType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.QueryType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.QueryType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiQueryType(obj: io.flow.v0.models.QueryType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectQueryType(obj: io.flow.v0.models.QueryType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiQueryType: play.api.libs.json.Writes[QueryType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.QueryType] {
        def writes(obj: io.flow.v0.models.QueryType) = {
          jsonWritesApiQueryType(obj)
        }
      }
    }

    implicit val jsonReadsApiRole = new play.api.libs.json.Reads[io.flow.v0.models.Role] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Role] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Role(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Role(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiRole(obj: io.flow.v0.models.Role) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRole(obj: io.flow.v0.models.Role) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiRole: play.api.libs.json.Writes[Role] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Role] {
        def writes(obj: io.flow.v0.models.Role) = {
          jsonWritesApiRole(obj)
        }
      }
    }

    implicit val jsonReadsApiRoundingMethod = new play.api.libs.json.Reads[io.flow.v0.models.RoundingMethod] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.RoundingMethod] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.RoundingMethod(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.RoundingMethod(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiRoundingMethod(obj: io.flow.v0.models.RoundingMethod) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRoundingMethod(obj: io.flow.v0.models.RoundingMethod) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiRoundingMethod: play.api.libs.json.Writes[RoundingMethod] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RoundingMethod] {
        def writes(obj: io.flow.v0.models.RoundingMethod) = {
          jsonWritesApiRoundingMethod(obj)
        }
      }
    }

    implicit val jsonReadsApiRoundingType = new play.api.libs.json.Reads[io.flow.v0.models.RoundingType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.RoundingType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.RoundingType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.RoundingType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiRoundingType(obj: io.flow.v0.models.RoundingType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectRoundingType(obj: io.flow.v0.models.RoundingType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiRoundingType: play.api.libs.json.Writes[RoundingType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RoundingType] {
        def writes(obj: io.flow.v0.models.RoundingType) = {
          jsonWritesApiRoundingType(obj)
        }
      }
    }

    implicit val jsonReadsApiScheduleExceptionStatus = new play.api.libs.json.Reads[io.flow.v0.models.ScheduleExceptionStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.ScheduleExceptionStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.ScheduleExceptionStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.ScheduleExceptionStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiScheduleExceptionStatus(obj: io.flow.v0.models.ScheduleExceptionStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectScheduleExceptionStatus(obj: io.flow.v0.models.ScheduleExceptionStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiScheduleExceptionStatus: play.api.libs.json.Writes[ScheduleExceptionStatus] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ScheduleExceptionStatus] {
        def writes(obj: io.flow.v0.models.ScheduleExceptionStatus) = {
          jsonWritesApiScheduleExceptionStatus(obj)
        }
      }
    }

    implicit val jsonReadsApiShipmentIntegrationType = new play.api.libs.json.Reads[io.flow.v0.models.ShipmentIntegrationType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.ShipmentIntegrationType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.ShipmentIntegrationType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.ShipmentIntegrationType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiShipmentIntegrationType(obj: io.flow.v0.models.ShipmentIntegrationType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectShipmentIntegrationType(obj: io.flow.v0.models.ShipmentIntegrationType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiShipmentIntegrationType: play.api.libs.json.Writes[ShipmentIntegrationType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ShipmentIntegrationType] {
        def writes(obj: io.flow.v0.models.ShipmentIntegrationType) = {
          jsonWritesApiShipmentIntegrationType(obj)
        }
      }
    }

    implicit val jsonReadsApiSortDirection = new play.api.libs.json.Reads[io.flow.v0.models.SortDirection] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.SortDirection] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.SortDirection(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.SortDirection(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiSortDirection(obj: io.flow.v0.models.SortDirection) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSortDirection(obj: io.flow.v0.models.SortDirection) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiSortDirection: play.api.libs.json.Writes[SortDirection] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SortDirection] {
        def writes(obj: io.flow.v0.models.SortDirection) = {
          jsonWritesApiSortDirection(obj)
        }
      }
    }

    implicit val jsonReadsApiStrategy = new play.api.libs.json.Reads[io.flow.v0.models.Strategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Strategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Strategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Strategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiStrategy(obj: io.flow.v0.models.Strategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectStrategy(obj: io.flow.v0.models.Strategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiStrategy: play.api.libs.json.Writes[Strategy] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Strategy] {
        def writes(obj: io.flow.v0.models.Strategy) = {
          jsonWritesApiStrategy(obj)
        }
      }
    }

    implicit val jsonReadsApiSubcatalogItemStatus = new play.api.libs.json.Reads[io.flow.v0.models.SubcatalogItemStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.SubcatalogItemStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.SubcatalogItemStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.SubcatalogItemStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiSubcatalogItemStatus(obj: io.flow.v0.models.SubcatalogItemStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectSubcatalogItemStatus(obj: io.flow.v0.models.SubcatalogItemStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiSubcatalogItemStatus: play.api.libs.json.Writes[SubcatalogItemStatus] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogItemStatus] {
        def writes(obj: io.flow.v0.models.SubcatalogItemStatus) = {
          jsonWritesApiSubcatalogItemStatus(obj)
        }
      }
    }

    implicit val jsonReadsApiTierStrategy = new play.api.libs.json.Reads[io.flow.v0.models.TierStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.TierStrategy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.TierStrategy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.TierStrategy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiTierStrategy(obj: io.flow.v0.models.TierStrategy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTierStrategy(obj: io.flow.v0.models.TierStrategy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiTierStrategy: play.api.libs.json.Writes[TierStrategy] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierStrategy] {
        def writes(obj: io.flow.v0.models.TierStrategy) = {
          jsonWritesApiTierStrategy(obj)
        }
      }
    }

    implicit val jsonReadsApiTrackingStatus = new play.api.libs.json.Reads[io.flow.v0.models.TrackingStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.TrackingStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.TrackingStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.TrackingStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiTrackingStatus(obj: io.flow.v0.models.TrackingStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTrackingStatus(obj: io.flow.v0.models.TrackingStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiTrackingStatus: play.api.libs.json.Writes[TrackingStatus] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TrackingStatus] {
        def writes(obj: io.flow.v0.models.TrackingStatus) = {
          jsonWritesApiTrackingStatus(obj)
        }
      }
    }

    implicit val jsonReadsApiUnitOfMeasurement = new play.api.libs.json.Reads[io.flow.v0.models.UnitOfMeasurement] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.UnitOfMeasurement] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.UnitOfMeasurement(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.UnitOfMeasurement(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiUnitOfMeasurement(obj: io.flow.v0.models.UnitOfMeasurement) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUnitOfMeasurement(obj: io.flow.v0.models.UnitOfMeasurement) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiUnitOfMeasurement: play.api.libs.json.Writes[UnitOfMeasurement] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UnitOfMeasurement] {
        def writes(obj: io.flow.v0.models.UnitOfMeasurement) = {
          jsonWritesApiUnitOfMeasurement(obj)
        }
      }
    }

    implicit val jsonReadsApiUnitOfTime = new play.api.libs.json.Reads[io.flow.v0.models.UnitOfTime] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.UnitOfTime] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.UnitOfTime(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.UnitOfTime(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiUnitOfTime(obj: io.flow.v0.models.UnitOfTime) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUnitOfTime(obj: io.flow.v0.models.UnitOfTime) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiUnitOfTime: play.api.libs.json.Writes[UnitOfTime] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UnitOfTime] {
        def writes(obj: io.flow.v0.models.UnitOfTime) = {
          jsonWritesApiUnitOfTime(obj)
        }
      }
    }

    implicit val jsonReadsApiUpdatePolicy = new play.api.libs.json.Reads[io.flow.v0.models.UpdatePolicy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.UpdatePolicy] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.UpdatePolicy(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.UpdatePolicy(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiUpdatePolicy(obj: io.flow.v0.models.UpdatePolicy) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUpdatePolicy(obj: io.flow.v0.models.UpdatePolicy) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiUpdatePolicy: play.api.libs.json.Writes[UpdatePolicy] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UpdatePolicy] {
        def writes(obj: io.flow.v0.models.UpdatePolicy) = {
          jsonWritesApiUpdatePolicy(obj)
        }
      }
    }

    implicit val jsonReadsApiUpdateType = new play.api.libs.json.Reads[io.flow.v0.models.UpdateType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.UpdateType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.UpdateType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.UpdateType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiUpdateType(obj: io.flow.v0.models.UpdateType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectUpdateType(obj: io.flow.v0.models.UpdateType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiUpdateType: play.api.libs.json.Writes[UpdateType] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UpdateType] {
        def writes(obj: io.flow.v0.models.UpdateType) = {
          jsonWritesApiUpdateType(obj)
        }
      }
    }

    implicit val jsonReadsApiValueAddedService = new play.api.libs.json.Reads[io.flow.v0.models.ValueAddedService] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.ValueAddedService] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.ValueAddedService(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.ValueAddedService(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiValueAddedService(obj: io.flow.v0.models.ValueAddedService) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectValueAddedService(obj: io.flow.v0.models.ValueAddedService) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiValueAddedService: play.api.libs.json.Writes[ValueAddedService] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ValueAddedService] {
        def writes(obj: io.flow.v0.models.ValueAddedService) = {
          jsonWritesApiValueAddedService(obj)
        }
      }
    }

    implicit val jsonReadsApiVisibility = new play.api.libs.json.Reads[io.flow.v0.models.Visibility] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.Visibility] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.Visibility(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.Visibility(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiVisibility(obj: io.flow.v0.models.Visibility) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectVisibility(obj: io.flow.v0.models.Visibility) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiVisibility: play.api.libs.json.Writes[Visibility] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Visibility] {
        def writes(obj: io.flow.v0.models.Visibility) = {
          jsonWritesApiVisibility(obj)
        }
      }
    }

    implicit val jsonReadsApiWebhookRequestStatus = new play.api.libs.json.Reads[io.flow.v0.models.WebhookRequestStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.v0.models.WebhookRequestStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.v0.models.WebhookRequestStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.v0.models.WebhookRequestStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesApiWebhookRequestStatus(obj: io.flow.v0.models.WebhookRequestStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectWebhookRequestStatus(obj: io.flow.v0.models.WebhookRequestStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesApiWebhookRequestStatus: play.api.libs.json.Writes[WebhookRequestStatus] = {
      new play.api.libs.json.Writes[io.flow.v0.models.WebhookRequestStatus] {
        def writes(obj: io.flow.v0.models.WebhookRequestStatus) = {
          jsonWritesApiWebhookRequestStatus(obj)
        }
      }
    }

    implicit def jsonReadsApiAddress: play.api.libs.json.Reads[Address] = {
      (
        (__ \ "text").readNullable[String] and
        (__ \ "streets").readNullable[Seq[String]] and
        (__ \ "city").readNullable[String] and
        (__ \ "province").readNullable[String] and
        (__ \ "postal").readNullable[String] and
        (__ \ "country").readNullable[String] and
        (__ \ "latitude").readNullable[String] and
        (__ \ "longitude").readNullable[String]
      )(Address.apply _)
    }

    def jsObjectAddress(obj: io.flow.v0.models.Address) = {
      (obj.text match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.streets match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("streets" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.city match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("city" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.province match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("province" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.latitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("latitude" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.longitude match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("longitude" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiAddress: play.api.libs.json.Writes[Address] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Address] {
        def writes(obj: io.flow.v0.models.Address) = {
          jsObjectAddress(obj)
        }
      }
    }

    implicit def jsonReadsApiAmountMargin: play.api.libs.json.Reads[AmountMargin] = {
      (__ \ "addition").read[io.flow.v0.models.Price].map { x => new AmountMargin(addition = x) }
    }

    def jsObjectAmountMargin(obj: io.flow.v0.models.AmountMargin) = {
      play.api.libs.json.Json.obj(
        "addition" -> jsObjectPrice(obj.addition)
      )
    }

    implicit def jsonReadsApiAtCost: play.api.libs.json.Reads[AtCost] = {
      (__ \ "ignore").readNullable[String].map { x => new AtCost(ignore = x) }
    }

    def jsObjectAtCost(obj: io.flow.v0.models.AtCost) = {
      (obj.ignore match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ignore" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiAttribute: play.api.libs.json.Reads[Attribute] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "options").read[io.flow.v0.models.Options] and
        (__ \ "label").readNullable[String]
      )(Attribute.apply _)
    }

    def jsObjectAttribute(obj: io.flow.v0.models.Attribute) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "options" -> jsObjectOptions(obj.options)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiAttribute: play.api.libs.json.Writes[Attribute] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Attribute] {
        def writes(obj: io.flow.v0.models.Attribute) = {
          jsObjectAttribute(obj)
        }
      }
    }

    implicit def jsonReadsApiAttributeForm: play.api.libs.json.Reads[AttributeForm] = {
      (
        (__ \ "key").read[String] and
        (__ \ "options").read[io.flow.v0.models.Options] and
        (__ \ "label").readNullable[String]
      )(AttributeForm.apply _)
    }

    def jsObjectAttributeForm(obj: io.flow.v0.models.AttributeForm) = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "options" -> jsObjectOptions(obj.options)
      ) ++ (obj.label match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("label" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiAttributeForm: play.api.libs.json.Writes[AttributeForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AttributeForm] {
        def writes(obj: io.flow.v0.models.AttributeForm) = {
          jsObjectAttributeForm(obj)
        }
      }
    }

    implicit def jsonReadsApiAttributeVersion: play.api.libs.json.Reads[AttributeVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "attribute").read[io.flow.v0.models.Attribute]
      )(AttributeVersion.apply _)
    }

    def jsObjectAttributeVersion(obj: io.flow.v0.models.AttributeVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "attribute" -> jsObjectAttribute(obj.attribute)
      )
    }

    implicit def jsonWritesApiAttributeVersion: play.api.libs.json.Writes[AttributeVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AttributeVersion] {
        def writes(obj: io.flow.v0.models.AttributeVersion) = {
          jsObjectAttributeVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiAuthenticationForm: play.api.libs.json.Reads[AuthenticationForm] = {
      (
        (__ \ "email").read[String] and
        (__ \ "password").read[String]
      )(AuthenticationForm.apply _)
    }

    def jsObjectAuthenticationForm(obj: io.flow.v0.models.AuthenticationForm) = {
      play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.JsString(obj.email),
        "password" -> play.api.libs.json.JsString(obj.password)
      )
    }

    implicit def jsonWritesApiAuthenticationForm: play.api.libs.json.Writes[AuthenticationForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthenticationForm] {
        def writes(obj: io.flow.v0.models.AuthenticationForm) = {
          jsObjectAuthenticationForm(obj)
        }
      }
    }

    implicit def jsonReadsApiAuthorization: play.api.libs.json.Reads[Authorization] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "card").read[io.flow.v0.models.CardReference] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "currency").read[String] and
        (__ \ "customer").read[io.flow.v0.models.Customer] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "destination").readNullable[io.flow.v0.models.Address] and
        (__ \ "ip").readNullable[String] and
        (__ \ "cvv").readNullable[String] and
        (__ \ "result").read[io.flow.v0.models.AuthorizationResult]
      )(Authorization.apply _)
    }

    def jsObjectAuthorization(obj: io.flow.v0.models.Authorization) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "card" -> jsObjectCardReference(obj.card),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "customer" -> jsObjectCustomer(obj.customer),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "result" -> jsObjectAuthorizationResult(obj.result)
      ) ++ (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectAddress(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiAuthorization: play.api.libs.json.Writes[Authorization] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Authorization] {
        def writes(obj: io.flow.v0.models.Authorization) = {
          jsObjectAuthorization(obj)
        }
      }
    }

    implicit def jsonReadsApiAuthorizationReference: play.api.libs.json.Reads[AuthorizationReference] = {
      (__ \ "id").read[String].map { x => new AuthorizationReference(id = x) }
    }

    def jsObjectAuthorizationReference(obj: io.flow.v0.models.AuthorizationReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiAuthorizationReference: play.api.libs.json.Writes[AuthorizationReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthorizationReference] {
        def writes(obj: io.flow.v0.models.AuthorizationReference) = {
          jsObjectAuthorizationReference(obj)
        }
      }
    }

    implicit def jsonReadsApiAuthorizationResult: play.api.libs.json.Reads[AuthorizationResult] = {
      (
        (__ \ "status").read[io.flow.v0.models.AuthorizationStatus] and
        (__ \ "decline_code").readNullable[io.flow.v0.models.AuthorizationDeclineCode] and
        (__ \ "avs").readNullable[io.flow.v0.models.Avs] and
        (__ \ "cvv").readNullable[io.flow.v0.models.Cvv]
      )(AuthorizationResult.apply _)
    }

    def jsObjectAuthorizationResult(obj: io.flow.v0.models.AuthorizationResult) = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.declineCode match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("decline_code" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.avs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avs" -> jsObjectAvs(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> jsObjectCvv(x))
      })
    }

    implicit def jsonWritesApiAuthorizationResult: play.api.libs.json.Writes[AuthorizationResult] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthorizationResult] {
        def writes(obj: io.flow.v0.models.AuthorizationResult) = {
          jsObjectAuthorizationResult(obj)
        }
      }
    }

    implicit def jsonReadsApiAuthorizationVersion: play.api.libs.json.Reads[AuthorizationVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "authorization").read[io.flow.v0.models.Authorization]
      )(AuthorizationVersion.apply _)
    }

    def jsObjectAuthorizationVersion(obj: io.flow.v0.models.AuthorizationVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "authorization" -> jsObjectAuthorization(obj.authorization)
      )
    }

    implicit def jsonWritesApiAuthorizationVersion: play.api.libs.json.Writes[AuthorizationVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthorizationVersion] {
        def writes(obj: io.flow.v0.models.AuthorizationVersion) = {
          jsObjectAuthorizationVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiAvailableService: play.api.libs.json.Reads[AvailableService] = {
      (__ \ "service").read[String].map { x => new AvailableService(service = x) }
    }

    def jsObjectAvailableService(obj: io.flow.v0.models.AvailableService) = {
      play.api.libs.json.Json.obj(
        "service" -> play.api.libs.json.JsString(obj.service)
      )
    }

    implicit def jsonWritesApiAvailableService: play.api.libs.json.Writes[AvailableService] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AvailableService] {
        def writes(obj: io.flow.v0.models.AvailableService) = {
          jsObjectAvailableService(obj)
        }
      }
    }

    implicit def jsonReadsApiAvs: play.api.libs.json.Reads[Avs] = {
      (
        (__ \ "code").read[io.flow.v0.models.AvsCode] and
        (__ \ "name").readNullable[Boolean] and
        (__ \ "address").readNullable[Boolean] and
        (__ \ "postal").readNullable[Boolean] and
        (__ \ "description").readNullable[String]
      )(Avs.apply _)
    }

    def jsObjectAvs(obj: io.flow.v0.models.Avs) = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.postal match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postal" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiAvs: play.api.libs.json.Writes[Avs] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Avs] {
        def writes(obj: io.flow.v0.models.Avs) = {
          jsObjectAvs(obj)
        }
      }
    }

    implicit def jsonReadsApiCapture: play.api.libs.json.Reads[Capture] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "authorization").read[io.flow.v0.models.AuthorizationReference] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "currency").read[String]
      )(Capture.apply _)
    }

    def jsObjectCapture(obj: io.flow.v0.models.Capture) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "authorization" -> jsObjectAuthorizationReference(obj.authorization),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonWritesApiCapture: play.api.libs.json.Writes[Capture] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Capture] {
        def writes(obj: io.flow.v0.models.Capture) = {
          jsObjectCapture(obj)
        }
      }
    }

    implicit def jsonReadsApiCaptureForm: play.api.libs.json.Reads[CaptureForm] = {
      (
        (__ \ "authorization_id").read[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "amount").readNullable[BigDecimal] and
        (__ \ "currency").readNullable[String]
      )(CaptureForm.apply _)
    }

    def jsObjectCaptureForm(obj: io.flow.v0.models.CaptureForm) = {
      play.api.libs.json.Json.obj(
        "authorization_id" -> play.api.libs.json.JsString(obj.authorizationId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCaptureForm: play.api.libs.json.Writes[CaptureForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CaptureForm] {
        def writes(obj: io.flow.v0.models.CaptureForm) = {
          jsObjectCaptureForm(obj)
        }
      }
    }

    implicit def jsonReadsApiCaptureVersion: play.api.libs.json.Reads[CaptureVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "capture").read[io.flow.v0.models.Capture]
      )(CaptureVersion.apply _)
    }

    def jsObjectCaptureVersion(obj: io.flow.v0.models.CaptureVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "capture" -> jsObjectCapture(obj.capture)
      )
    }

    implicit def jsonWritesApiCaptureVersion: play.api.libs.json.Writes[CaptureVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CaptureVersion] {
        def writes(obj: io.flow.v0.models.CaptureVersion) = {
          jsObjectCaptureVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiCard: play.api.libs.json.Reads[Card] = {
      (
        (__ \ "id").read[String] and
        (__ \ "token").read[String] and
        (__ \ "type").read[io.flow.v0.models.CardType] and
        (__ \ "expiration").read[io.flow.v0.models.Expiration] and
        (__ \ "last4").read[String] and
        (__ \ "name").read[String] and
        (__ \ "address").readNullable[io.flow.v0.models.Address]
      )(Card.apply _)
    }

    def jsObjectCard(obj: io.flow.v0.models.Card) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "token" -> play.api.libs.json.JsString(obj.token),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "expiration" -> jsObjectExpiration(obj.expiration),
        "last4" -> play.api.libs.json.JsString(obj.last4),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> jsObjectAddress(x))
      })
    }

    implicit def jsonWritesApiCard: play.api.libs.json.Writes[Card] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Card] {
        def writes(obj: io.flow.v0.models.Card) = {
          jsObjectCard(obj)
        }
      }
    }

    implicit def jsonReadsApiCardForm: play.api.libs.json.Reads[CardForm] = {
      (
        (__ \ "number").readNullable[String] and
        (__ \ "cipher").readNullable[String] and
        (__ \ "expiration_month").read[Int] and
        (__ \ "expiration_year").read[Int] and
        (__ \ "name").read[String] and
        (__ \ "cvv").readNullable[String] and
        (__ \ "address").readNullable[io.flow.v0.models.Address] and
        (__ \ "challenge_text").readNullable[String] and
        (__ \ "challenge_cipher").readNullable[String]
      )(CardForm.apply _)
    }

    def jsObjectCardForm(obj: io.flow.v0.models.CardForm) = {
      play.api.libs.json.Json.obj(
        "expiration_month" -> play.api.libs.json.JsNumber(obj.expirationMonth),
        "expiration_year" -> play.api.libs.json.JsNumber(obj.expirationYear),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cipher match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cipher" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> jsObjectAddress(x))
      }) ++
      (obj.challengeText match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("challenge_text" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.challengeCipher match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("challenge_cipher" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCardForm: play.api.libs.json.Writes[CardForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CardForm] {
        def writes(obj: io.flow.v0.models.CardForm) = {
          jsObjectCardForm(obj)
        }
      }
    }

    implicit def jsonReadsApiCardReference: play.api.libs.json.Reads[CardReference] = {
      (
        (__ \ "id").read[String] and
        (__ \ "token").read[String]
      )(CardReference.apply _)
    }

    def jsObjectCardReference(obj: io.flow.v0.models.CardReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesApiCardReference: play.api.libs.json.Writes[CardReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CardReference] {
        def writes(obj: io.flow.v0.models.CardReference) = {
          jsObjectCardReference(obj)
        }
      }
    }

    implicit def jsonReadsApiCardVersion: play.api.libs.json.Reads[CardVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "card").read[io.flow.v0.models.Card]
      )(CardVersion.apply _)
    }

    def jsObjectCardVersion(obj: io.flow.v0.models.CardVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "card" -> jsObjectCard(obj.card)
      )
    }

    implicit def jsonWritesApiCardVersion: play.api.libs.json.Writes[CardVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CardVersion] {
        def writes(obj: io.flow.v0.models.CardVersion) = {
          jsObjectCardVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiCarrier: play.api.libs.json.Reads[Carrier] = {
      (
        (__ \ "id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "facilities").read[Seq[io.flow.v0.models.ShippingAddress]] and
        (__ \ "visibility").read[io.flow.v0.models.Visibility]
      )(Carrier.apply _)
    }

    def jsObjectCarrier(obj: io.flow.v0.models.Carrier) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "facilities" -> play.api.libs.json.Json.toJson(obj.facilities),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString)
      )
    }

    implicit def jsonWritesApiCarrier: play.api.libs.json.Writes[Carrier] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Carrier] {
        def writes(obj: io.flow.v0.models.Carrier) = {
          jsObjectCarrier(obj)
        }
      }
    }

    implicit def jsonReadsApiCarrierReference: play.api.libs.json.Reads[CarrierReference] = {
      (__ \ "id").read[String].map { x => new CarrierReference(id = x) }
    }

    def jsObjectCarrierReference(obj: io.flow.v0.models.CarrierReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiCarrierReference: play.api.libs.json.Writes[CarrierReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CarrierReference] {
        def writes(obj: io.flow.v0.models.CarrierReference) = {
          jsObjectCarrierReference(obj)
        }
      }
    }

    implicit def jsonReadsApiCatalog: play.api.libs.json.Reads[Catalog] = {
      (__ \ "id").read[String].map { x => new Catalog(id = x) }
    }

    def jsObjectCatalog(obj: io.flow.v0.models.Catalog) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiCatalog: play.api.libs.json.Writes[Catalog] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Catalog] {
        def writes(obj: io.flow.v0.models.Catalog) = {
          jsObjectCatalog(obj)
        }
      }
    }

    implicit def jsonReadsApiCatalogDeleted: play.api.libs.json.Reads[CatalogDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "catalog").read[String]
      )(CatalogDeleted.apply _)
    }

    def jsObjectCatalogDeleted(obj: io.flow.v0.models.CatalogDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "catalog" -> play.api.libs.json.JsString(obj.catalog)
      )
    }

    implicit def jsonReadsApiCatalogItemDeleted: play.api.libs.json.Reads[CatalogItemDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "catalog").read[String]
      )(CatalogItemDeleted.apply _)
    }

    def jsObjectCatalogItemDeleted(obj: io.flow.v0.models.CatalogItemDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "catalog" -> play.api.libs.json.JsString(obj.catalog)
      )
    }

    implicit def jsonReadsApiCatalogItemDocument: play.api.libs.json.Reads[CatalogItemDocument] = {
      (
        (__ \ "number").read[String] and
        (__ \ "name").read[String] and
        (__ \ "categories").read[Seq[String]] and
        (__ \ "experiences").read[Seq[io.flow.v0.models.ExperienceSummary]] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "images").read[io.flow.v0.models.CatalogItemDocumentImages]
      )(CatalogItemDocument.apply _)
    }

    def jsObjectCatalogItemDocument(obj: io.flow.v0.models.CatalogItemDocument) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "experiences" -> play.api.libs.json.Json.toJson(obj.experiences),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "images" -> jsObjectCatalogItemDocumentImages(obj.images)
      )
    }

    implicit def jsonReadsApiCatalogItemDocumentImage: play.api.libs.json.Reads[CatalogItemDocumentImage] = {
      (__ \ "url").read[String].map { x => new CatalogItemDocumentImage(url = x) }
    }

    def jsObjectCatalogItemDocumentImage(obj: io.flow.v0.models.CatalogItemDocumentImage) = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url)
      )
    }

    implicit def jsonWritesApiCatalogItemDocumentImage: play.api.libs.json.Writes[CatalogItemDocumentImage] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CatalogItemDocumentImage] {
        def writes(obj: io.flow.v0.models.CatalogItemDocumentImage) = {
          jsObjectCatalogItemDocumentImage(obj)
        }
      }
    }

    implicit def jsonReadsApiCatalogItemDocumentImages: play.api.libs.json.Reads[CatalogItemDocumentImages] = {
      (__ \ "thumbnail").readNullable[io.flow.v0.models.CatalogItemDocumentImage].map { x => new CatalogItemDocumentImages(thumbnail = x) }
    }

    def jsObjectCatalogItemDocumentImages(obj: io.flow.v0.models.CatalogItemDocumentImages) = {
      (obj.thumbnail match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("thumbnail" -> jsObjectCatalogItemDocumentImage(x))
      })
    }

    implicit def jsonWritesApiCatalogItemDocumentImages: play.api.libs.json.Writes[CatalogItemDocumentImages] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CatalogItemDocumentImages] {
        def writes(obj: io.flow.v0.models.CatalogItemDocumentImages) = {
          jsObjectCatalogItemDocumentImages(obj)
        }
      }
    }

    implicit def jsonReadsApiCatalogItemUpserted: play.api.libs.json.Reads[CatalogItemUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "catalog").read[String] and
        (__ \ "locale").read[String] and
        (__ \ "name").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "price").read[Double] and
        (__ \ "categories").read[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "dimensions").read[_root_.play.api.libs.json.JsObject] and
        (__ \ "images").read[Seq[_root_.play.api.libs.json.JsObject]]
      )(CatalogItemUpserted.apply _)
    }

    def jsObjectCatalogItemUpserted(obj: io.flow.v0.models.CatalogItemUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "catalog" -> play.api.libs.json.JsString(obj.catalog),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "dimensions" -> obj.dimensions,
        "images" -> play.api.libs.json.Json.toJson(obj.images)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiCatalogStatistics: play.api.libs.json.Reads[CatalogStatistics] = {
      (
        (__ \ "items").read[Long] and
        (__ \ "categories").read[Long]
      )(CatalogStatistics.apply _)
    }

    def jsObjectCatalogStatistics(obj: io.flow.v0.models.CatalogStatistics) = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.JsNumber(obj.items),
        "categories" -> play.api.libs.json.JsNumber(obj.categories)
      )
    }

    implicit def jsonWritesApiCatalogStatistics: play.api.libs.json.Writes[CatalogStatistics] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CatalogStatistics] {
        def writes(obj: io.flow.v0.models.CatalogStatistics) = {
          jsObjectCatalogStatistics(obj)
        }
      }
    }

    implicit def jsonReadsApiCatalogUpserted: play.api.libs.json.Reads[CatalogUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "catalog").read[String]
      )(CatalogUpserted.apply _)
    }

    def jsObjectCatalogUpserted(obj: io.flow.v0.models.CatalogUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "catalog" -> play.api.libs.json.JsString(obj.catalog)
      )
    }

    implicit def jsonReadsApiCatalogVersion: play.api.libs.json.Reads[CatalogVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "catalog").read[io.flow.v0.models.Catalog]
      )(CatalogVersion.apply _)
    }

    def jsObjectCatalogVersion(obj: io.flow.v0.models.CatalogVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "catalog" -> jsObjectCatalog(obj.catalog)
      )
    }

    implicit def jsonWritesApiCatalogVersion: play.api.libs.json.Writes[CatalogVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CatalogVersion] {
        def writes(obj: io.flow.v0.models.CatalogVersion) = {
          jsObjectCatalogVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiCategorySummary: play.api.libs.json.Reads[CategorySummary] = {
      (
        (__ \ "name").readNullable[String] and
        (__ \ "count").read[Long]
      )(CategorySummary.apply _)
    }

    def jsObjectCategorySummary(obj: io.flow.v0.models.CategorySummary) = {
      play.api.libs.json.Json.obj(
        "count" -> play.api.libs.json.JsNumber(obj.count)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCategorySummary: play.api.libs.json.Writes[CategorySummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CategorySummary] {
        def writes(obj: io.flow.v0.models.CategorySummary) = {
          jsObjectCategorySummary(obj)
        }
      }
    }

    implicit def jsonReadsApiCenter: play.api.libs.json.Reads[Center] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "address").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "packaging").read[Seq[io.flow.v0.models.Packaging]] and
        (__ \ "name").read[String] and
        (__ \ "services").read[Seq[io.flow.v0.models.AvailableService]] and
        (__ \ "schedule").read[io.flow.v0.models.Schedule] and
        (__ \ "timezone").read[String]
      )(Center.apply _)
    }

    def jsObjectCenter(obj: io.flow.v0.models.Center) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "address" -> jsObjectShippingAddress(obj.address),
        "packaging" -> play.api.libs.json.Json.toJson(obj.packaging),
        "name" -> play.api.libs.json.JsString(obj.name),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "schedule" -> jsObjectSchedule(obj.schedule),
        "timezone" -> play.api.libs.json.JsString(obj.timezone)
      )
    }

    implicit def jsonWritesApiCenter: play.api.libs.json.Writes[Center] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Center] {
        def writes(obj: io.flow.v0.models.Center) = {
          jsObjectCenter(obj)
        }
      }
    }

    implicit def jsonReadsApiCenterForm: play.api.libs.json.Reads[CenterForm] = {
      (
        (__ \ "address").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "packaging").read[Seq[io.flow.v0.models.Packaging]] and
        (__ \ "name").read[String] and
        (__ \ "services").read[Seq[io.flow.v0.models.AvailableService]] and
        (__ \ "schedule").read[io.flow.v0.models.Schedule] and
        (__ \ "timezone").readNullable[String] and
        (__ \ "key").readNullable[String]
      )(CenterForm.apply _)
    }

    def jsObjectCenterForm(obj: io.flow.v0.models.CenterForm) = {
      play.api.libs.json.Json.obj(
        "address" -> jsObjectShippingAddress(obj.address),
        "packaging" -> play.api.libs.json.Json.toJson(obj.packaging),
        "name" -> play.api.libs.json.JsString(obj.name),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "schedule" -> jsObjectSchedule(obj.schedule)
      ) ++ (obj.timezone match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("timezone" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCenterForm: play.api.libs.json.Writes[CenterForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CenterForm] {
        def writes(obj: io.flow.v0.models.CenterForm) = {
          jsObjectCenterForm(obj)
        }
      }
    }

    implicit def jsonReadsApiCenterReference: play.api.libs.json.Reads[CenterReference] = {
      (__ \ "id").read[String].map { x => new CenterReference(id = x) }
    }

    def jsObjectCenterReference(obj: io.flow.v0.models.CenterReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiCenterReference: play.api.libs.json.Writes[CenterReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CenterReference] {
        def writes(obj: io.flow.v0.models.CenterReference) = {
          jsObjectCenterReference(obj)
        }
      }
    }

    implicit def jsonReadsApiCenterVersion: play.api.libs.json.Reads[CenterVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "center").read[io.flow.v0.models.Center]
      )(CenterVersion.apply _)
    }

    def jsObjectCenterVersion(obj: io.flow.v0.models.CenterVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "center" -> jsObjectCenter(obj.center)
      )
    }

    implicit def jsonWritesApiCenterVersion: play.api.libs.json.Writes[CenterVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CenterVersion] {
        def writes(obj: io.flow.v0.models.CenterVersion) = {
          jsObjectCenterVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiCleartext: play.api.libs.json.Reads[Cleartext] = {
      (__ \ "value").read[String].map { x => new Cleartext(value = x) }
    }

    def jsObjectCleartext(obj: io.flow.v0.models.Cleartext) = {
      play.api.libs.json.Json.obj(
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesApiCleartext: play.api.libs.json.Writes[Cleartext] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Cleartext] {
        def writes(obj: io.flow.v0.models.Cleartext) = {
          jsObjectCleartext(obj)
        }
      }
    }

    implicit def jsonReadsApiContact: play.api.libs.json.Reads[Contact] = {
      (
        (__ \ "name").read[io.flow.v0.models.Name] and
        (__ \ "company").readNullable[String] and
        (__ \ "email").readNullable[String] and
        (__ \ "phone").readNullable[String]
      )(Contact.apply _)
    }

    def jsObjectContact(obj: io.flow.v0.models.Contact) = {
      play.api.libs.json.Json.obj(
        "name" -> jsObjectName(obj.name)
      ) ++ (obj.company match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("company" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.phone match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("phone" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiContact: play.api.libs.json.Writes[Contact] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Contact] {
        def writes(obj: io.flow.v0.models.Contact) = {
          jsObjectContact(obj)
        }
      }
    }

    implicit def jsonReadsApiContractedRateUpserted: play.api.libs.json.Reads[ContractedRateUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization_id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "value").read[BigDecimal]
      )(ContractedRateUpserted.apply _)
    }

    def jsObjectContractedRateUpserted(obj: io.flow.v0.models.ContractedRateUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization_id" -> play.api.libs.json.JsString(obj.organizationId),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt)),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonReadsApiConversion: play.api.libs.json.Reads[Conversion] = {
      (
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "rate").read[BigDecimal]
      )(Conversion.apply _)
    }

    def jsObjectConversion(obj: io.flow.v0.models.Conversion) = {
      play.api.libs.json.Json.obj(
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "rate" -> play.api.libs.json.JsNumber(obj.rate)
      )
    }

    implicit def jsonWritesApiConversion: play.api.libs.json.Writes[Conversion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Conversion] {
        def writes(obj: io.flow.v0.models.Conversion) = {
          jsObjectConversion(obj)
        }
      }
    }

    implicit def jsonReadsApiCountry: play.api.libs.json.Reads[Country] = {
      (
        (__ \ "name").read[String] and
        (__ \ "iso_3166_2").read[String] and
        (__ \ "iso_3166_3").read[String] and
        (__ \ "languages").read[Seq[String]] and
        (__ \ "measurement_system").read[String] and
        (__ \ "default_currency").readNullable[String] and
        (__ \ "timezones").read[Seq[String]]
      )(Country.apply _)
    }

    def jsObjectCountry(obj: io.flow.v0.models.Country) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "iso_3166_2" -> play.api.libs.json.JsString(obj.iso31662),
        "iso_3166_3" -> play.api.libs.json.JsString(obj.iso31663),
        "languages" -> play.api.libs.json.Json.toJson(obj.languages),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem),
        "timezones" -> play.api.libs.json.Json.toJson(obj.timezones)
      ) ++ (obj.defaultCurrency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("default_currency" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCountry: play.api.libs.json.Writes[Country] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Country] {
        def writes(obj: io.flow.v0.models.Country) = {
          jsObjectCountry(obj)
        }
      }
    }

    implicit def jsonReadsApiCountryDefaults: play.api.libs.json.Reads[CountryDefaults] = {
      (
        (__ \ "country").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "language").read[String]
      )(CountryDefaults.apply _)
    }

    def jsObjectCountryDefaults(obj: io.flow.v0.models.CountryDefaults) = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language)
      )
    }

    implicit def jsonWritesApiCountryDefaults: play.api.libs.json.Writes[CountryDefaults] = {
      new play.api.libs.json.Writes[io.flow.v0.models.CountryDefaults] {
        def writes(obj: io.flow.v0.models.CountryDefaults) = {
          jsObjectCountryDefaults(obj)
        }
      }
    }

    implicit def jsonReadsApiCurrency: play.api.libs.json.Reads[Currency] = {
      (
        (__ \ "name").read[String] and
        (__ \ "iso_4217_3").read[String] and
        (__ \ "number_decimals").read[Int]
      )(Currency.apply _)
    }

    def jsObjectCurrency(obj: io.flow.v0.models.Currency) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "iso_4217_3" -> play.api.libs.json.JsString(obj.iso42173),
        "number_decimals" -> play.api.libs.json.JsNumber(obj.numberDecimals)
      )
    }

    implicit def jsonWritesApiCurrency: play.api.libs.json.Writes[Currency] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Currency] {
        def writes(obj: io.flow.v0.models.Currency) = {
          jsObjectCurrency(obj)
        }
      }
    }

    implicit def jsonReadsApiCustomer: play.api.libs.json.Reads[Customer] = {
      (
        (__ \ "name").read[io.flow.v0.models.Name] and
        (__ \ "number").readNullable[String] and
        (__ \ "phone").readNullable[String] and
        (__ \ "email").readNullable[String]
      )(Customer.apply _)
    }

    def jsObjectCustomer(obj: io.flow.v0.models.Customer) = {
      play.api.libs.json.Json.obj(
        "name" -> jsObjectName(obj.name)
      ) ++ (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.phone match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("phone" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCustomer: play.api.libs.json.Writes[Customer] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Customer] {
        def writes(obj: io.flow.v0.models.Customer) = {
          jsObjectCustomer(obj)
        }
      }
    }

    implicit def jsonReadsApiCvv: play.api.libs.json.Reads[Cvv] = {
      (
        (__ \ "code").read[io.flow.v0.models.CvvCode] and
        (__ \ "description").readNullable[String]
      )(Cvv.apply _)
    }

    def jsObjectCvv(obj: io.flow.v0.models.Cvv) = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code.toString)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiCvv: play.api.libs.json.Writes[Cvv] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Cvv] {
        def writes(obj: io.flow.v0.models.Cvv) = {
          jsObjectCvv(obj)
        }
      }
    }

    implicit def jsonReadsApiDatetimeRange: play.api.libs.json.Reads[DatetimeRange] = {
      (
        (__ \ "from").read[_root_.org.joda.time.DateTime] and
        (__ \ "to").read[_root_.org.joda.time.DateTime]
      )(DatetimeRange.apply _)
    }

    def jsObjectDatetimeRange(obj: io.flow.v0.models.DatetimeRange) = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.from)),
        "to" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.to))
      )
    }

    implicit def jsonWritesApiDatetimeRange: play.api.libs.json.Writes[DatetimeRange] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DatetimeRange] {
        def writes(obj: io.flow.v0.models.DatetimeRange) = {
          jsObjectDatetimeRange(obj)
        }
      }
    }

    implicit def jsonReadsApiDelivery: play.api.libs.json.Reads[Delivery] = {
      (
        (__ \ "id").read[String] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]] and
        (__ \ "options").read[Seq[io.flow.v0.models.DeliveryOption]]
      )(Delivery.apply _)
    }

    def jsObjectDelivery(obj: io.flow.v0.models.Delivery) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "options" -> play.api.libs.json.Json.toJson(obj.options)
      )
    }

    implicit def jsonWritesApiDelivery: play.api.libs.json.Writes[Delivery] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Delivery] {
        def writes(obj: io.flow.v0.models.Delivery) = {
          jsObjectDelivery(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryForm: play.api.libs.json.Reads[DeliveryForm] = {
      (
        (__ \ "quote").read[String] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]] and
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress]
      )(DeliveryForm.apply _)
    }

    def jsObjectDeliveryForm(obj: io.flow.v0.models.DeliveryForm) = {
      play.api.libs.json.Json.obj(
        "quote" -> play.api.libs.json.JsString(obj.quote),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectShippingAddress(obj.destination)
      )
    }

    implicit def jsonWritesApiDeliveryForm: play.api.libs.json.Writes[DeliveryForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryForm] {
        def writes(obj: io.flow.v0.models.DeliveryForm) = {
          jsObjectDeliveryForm(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryOption: play.api.libs.json.Reads[DeliveryOption] = {
      (
        (__ \ "id").read[String] and
        (__ \ "cost").read[io.flow.v0.models.Price] and
        (__ \ "delivered_duty").read[io.flow.v0.models.DeliveredDuty] and
        (__ \ "price").read[io.flow.v0.models.Price] and
        (__ \ "service").read[io.flow.v0.models.ServiceSummary] and
        (__ \ "tier").read[io.flow.v0.models.TierSummary] and
        (__ \ "window").read[io.flow.v0.models.DatetimeRange]
      )(DeliveryOption.apply _)
    }

    def jsObjectDeliveryOption(obj: io.flow.v0.models.DeliveryOption) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "cost" -> jsObjectPrice(obj.cost),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "price" -> jsObjectPrice(obj.price),
        "service" -> jsObjectServiceSummary(obj.service),
        "tier" -> jsObjectTierSummary(obj.tier),
        "window" -> jsObjectDatetimeRange(obj.window)
      )
    }

    implicit def jsonWritesApiDeliveryOption: play.api.libs.json.Writes[DeliveryOption] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryOption] {
        def writes(obj: io.flow.v0.models.DeliveryOption) = {
          jsObjectDeliveryOption(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryOptionForm: play.api.libs.json.Reads[DeliveryOptionForm] = {
      (
        (__ \ "delivery").read[String] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]] and
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress]
      )(DeliveryOptionForm.apply _)
    }

    def jsObjectDeliveryOptionForm(obj: io.flow.v0.models.DeliveryOptionForm) = {
      play.api.libs.json.Json.obj(
        "delivery" -> play.api.libs.json.JsString(obj.delivery),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectShippingAddress(obj.destination)
      )
    }

    implicit def jsonWritesApiDeliveryOptionForm: play.api.libs.json.Writes[DeliveryOptionForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryOptionForm] {
        def writes(obj: io.flow.v0.models.DeliveryOptionForm) = {
          jsObjectDeliveryOptionForm(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryOptionReference: play.api.libs.json.Reads[DeliveryOptionReference] = {
      (__ \ "id").read[String].map { x => new DeliveryOptionReference(id = x) }
    }

    def jsObjectDeliveryOptionReference(obj: io.flow.v0.models.DeliveryOptionReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiDeliveryOptionReference: play.api.libs.json.Writes[DeliveryOptionReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryOptionReference] {
        def writes(obj: io.flow.v0.models.DeliveryOptionReference) = {
          jsObjectDeliveryOptionReference(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryOptionSummary: play.api.libs.json.Reads[DeliveryOptionSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "cost").read[io.flow.v0.models.Price] and
        (__ \ "delivered_duty").read[io.flow.v0.models.DeliveredDuty] and
        (__ \ "price").read[io.flow.v0.models.Price] and
        (__ \ "service").read[io.flow.v0.models.ServiceReference] and
        (__ \ "tier").read[io.flow.v0.models.TierReference] and
        (__ \ "window").read[io.flow.v0.models.DatetimeRange]
      )(DeliveryOptionSummary.apply _)
    }

    def jsObjectDeliveryOptionSummary(obj: io.flow.v0.models.DeliveryOptionSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "cost" -> jsObjectPrice(obj.cost),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "price" -> jsObjectPrice(obj.price),
        "service" -> jsObjectServiceReference(obj.service),
        "tier" -> jsObjectTierReference(obj.tier),
        "window" -> jsObjectDatetimeRange(obj.window)
      )
    }

    implicit def jsonWritesApiDeliveryOptionSummary: play.api.libs.json.Writes[DeliveryOptionSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryOptionSummary] {
        def writes(obj: io.flow.v0.models.DeliveryOptionSummary) = {
          jsObjectDeliveryOptionSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryOptionVersion: play.api.libs.json.Reads[DeliveryOptionVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "delivery_option").read[io.flow.v0.models.DeliveryOptionSummary]
      )(DeliveryOptionVersion.apply _)
    }

    def jsObjectDeliveryOptionVersion(obj: io.flow.v0.models.DeliveryOptionVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "delivery_option" -> jsObjectDeliveryOptionSummary(obj.deliveryOption)
      )
    }

    implicit def jsonWritesApiDeliveryOptionVersion: play.api.libs.json.Writes[DeliveryOptionVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryOptionVersion] {
        def writes(obj: io.flow.v0.models.DeliveryOptionVersion) = {
          jsObjectDeliveryOptionVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliverySummary: play.api.libs.json.Reads[DeliverySummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]]
      )(DeliverySummary.apply _)
    }

    def jsObjectDeliverySummary(obj: io.flow.v0.models.DeliverySummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesApiDeliverySummary: play.api.libs.json.Writes[DeliverySummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliverySummary] {
        def writes(obj: io.flow.v0.models.DeliverySummary) = {
          jsObjectDeliverySummary(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryVersion: play.api.libs.json.Reads[DeliveryVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "delivery").read[io.flow.v0.models.DeliverySummary]
      )(DeliveryVersion.apply _)
    }

    def jsObjectDeliveryVersion(obj: io.flow.v0.models.DeliveryVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "delivery" -> jsObjectDeliverySummary(obj.delivery)
      )
    }

    implicit def jsonWritesApiDeliveryVersion: play.api.libs.json.Writes[DeliveryVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryVersion] {
        def writes(obj: io.flow.v0.models.DeliveryVersion) = {
          jsObjectDeliveryVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiDeliveryWindow: play.api.libs.json.Reads[DeliveryWindow] = {
      (
        (__ \ "from").read[_root_.org.joda.time.DateTime] and
        (__ \ "to").read[_root_.org.joda.time.DateTime]
      )(DeliveryWindow.apply _)
    }

    def jsObjectDeliveryWindow(obj: io.flow.v0.models.DeliveryWindow) = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.from)),
        "to" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.to))
      )
    }

    implicit def jsonWritesApiDeliveryWindow: play.api.libs.json.Writes[DeliveryWindow] = {
      new play.api.libs.json.Writes[io.flow.v0.models.DeliveryWindow] {
        def writes(obj: io.flow.v0.models.DeliveryWindow) = {
          jsObjectDeliveryWindow(obj)
        }
      }
    }

    implicit def jsonReadsApiDeminimusSimple: play.api.libs.json.Reads[DeminimusSimple] = {
      (
        (__ \ "value").read[BigDecimal] and
        (__ \ "currency").read[String] and
        (__ \ "components").read[Seq[io.flow.v0.models.LevyComponent]] and
        (__ \ "minimum").read[BigDecimal]
      )(DeminimusSimple.apply _)
    }

    def jsObjectDeminimusSimple(obj: io.flow.v0.models.DeminimusSimple) = {
      play.api.libs.json.Json.obj(
        "value" -> play.api.libs.json.JsNumber(obj.value),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "components" -> play.api.libs.json.Json.toJson(obj.components),
        "minimum" -> play.api.libs.json.JsNumber(obj.minimum)
      )
    }

    implicit def jsonReadsApiDimension: play.api.libs.json.Reads[Dimension] = {
      (
        (__ \ "depth").readNullable[io.flow.v0.models.Measurement] and
        (__ \ "diameter").readNullable[io.flow.v0.models.Measurement] and
        (__ \ "length").readNullable[io.flow.v0.models.Measurement] and
        (__ \ "weight").readNullable[io.flow.v0.models.Measurement] and
        (__ \ "width").readNullable[io.flow.v0.models.Measurement]
      )(Dimension.apply _)
    }

    def jsObjectDimension(obj: io.flow.v0.models.Dimension) = {
      (obj.depth match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("depth" -> jsObjectMeasurement(x))
      }) ++
      (obj.diameter match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("diameter" -> jsObjectMeasurement(x))
      }) ++
      (obj.length match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("length" -> jsObjectMeasurement(x))
      }) ++
      (obj.weight match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("weight" -> jsObjectMeasurement(x))
      }) ++
      (obj.width match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("width" -> jsObjectMeasurement(x))
      })
    }

    implicit def jsonWritesApiDimension: play.api.libs.json.Writes[Dimension] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Dimension] {
        def writes(obj: io.flow.v0.models.Dimension) = {
          jsObjectDimension(obj)
        }
      }
    }

    implicit def jsonReadsApiDimensions: play.api.libs.json.Reads[Dimensions] = {
      (
        (__ \ "product").readNullable[io.flow.v0.models.Dimension] and
        (__ \ "packaging").readNullable[io.flow.v0.models.Dimension]
      )(Dimensions.apply _)
    }

    def jsObjectDimensions(obj: io.flow.v0.models.Dimensions) = {
      (obj.product match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("product" -> jsObjectDimension(x))
      }) ++
      (obj.packaging match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("packaging" -> jsObjectDimension(x))
      })
    }

    implicit def jsonWritesApiDimensions: play.api.libs.json.Writes[Dimensions] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Dimensions] {
        def writes(obj: io.flow.v0.models.Dimensions) = {
          jsObjectDimensions(obj)
        }
      }
    }

    implicit def jsonReadsApiDirectAuthorizationForm: play.api.libs.json.Reads[DirectAuthorizationForm] = {
      (
        (__ \ "token").read[String] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "currency").read[String] and
        (__ \ "customer").read[io.flow.v0.models.Customer] and
        (__ \ "key").readNullable[String] and
        (__ \ "cvv").readNullable[String] and
        (__ \ "attributes").readNullable[Map[String, String]] and
        (__ \ "destination").readNullable[io.flow.v0.models.Address] and
        (__ \ "ip").readNullable[String]
      )(DirectAuthorizationForm.apply _)
    }

    def jsObjectDirectAuthorizationForm(obj: io.flow.v0.models.DirectAuthorizationForm) = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "customer" -> jsObjectCustomer(obj.customer)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.destination match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("destination" -> jsObjectAddress(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiDuration: play.api.libs.json.Reads[Duration] = {
      (
        (__ \ "unit").read[io.flow.v0.models.UnitOfTime] and
        (__ \ "value").read[Long]
      )(Duration.apply _)
    }

    def jsObjectDuration(obj: io.flow.v0.models.Duration) = {
      play.api.libs.json.Json.obj(
        "unit" -> play.api.libs.json.JsString(obj.unit.toString),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesApiDuration: play.api.libs.json.Writes[Duration] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Duration] {
        def writes(obj: io.flow.v0.models.Duration) = {
          jsObjectDuration(obj)
        }
      }
    }

    implicit def jsonReadsApiDuty: play.api.libs.json.Reads[Duty] = {
      (
        (__ \ "rate").read[BigDecimal] and
        (__ \ "components").read[Seq[io.flow.v0.models.LevyComponent]] and
        (__ \ "deminimus").readNullable[io.flow.v0.models.Deminimus]
      )(Duty.apply _)
    }

    def jsObjectDuty(obj: io.flow.v0.models.Duty) = {
      play.api.libs.json.Json.obj(
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.deminimus match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("deminimus" -> jsObjectDeminimus(x))
      })
    }

    implicit def jsonWritesApiDuty: play.api.libs.json.Writes[Duty] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Duty] {
        def writes(obj: io.flow.v0.models.Duty) = {
          jsObjectDuty(obj)
        }
      }
    }

    implicit def jsonReadsApiEmailVerification: play.api.libs.json.Reads[EmailVerification] = {
      (__ \ "email").read[String].map { x => new EmailVerification(email = x) }
    }

    def jsObjectEmailVerification(obj: io.flow.v0.models.EmailVerification) = {
      play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.JsString(obj.email)
      )
    }

    implicit def jsonWritesApiEmailVerification: play.api.libs.json.Writes[EmailVerification] = {
      new play.api.libs.json.Writes[io.flow.v0.models.EmailVerification] {
        def writes(obj: io.flow.v0.models.EmailVerification) = {
          jsObjectEmailVerification(obj)
        }
      }
    }

    implicit def jsonReadsApiError: play.api.libs.json.Reads[Error] = {
      (
        (__ \ "code").read[String] and
        (__ \ "message").read[String]
      )(Error.apply _)
    }

    def jsObjectError(obj: io.flow.v0.models.Error) = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "message" -> play.api.libs.json.JsString(obj.message)
      )
    }

    implicit def jsonWritesApiError: play.api.libs.json.Writes[Error] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Error] {
        def writes(obj: io.flow.v0.models.Error) = {
          jsObjectError(obj)
        }
      }
    }

    implicit def jsonReadsApiEstimatedWindow: play.api.libs.json.Reads[EstimatedWindow] = {
      (
        (__ \ "from").read[Long] and
        (__ \ "to").read[Long] and
        (__ \ "unit").read[io.flow.v0.models.UnitOfTime]
      )(EstimatedWindow.apply _)
    }

    def jsObjectEstimatedWindow(obj: io.flow.v0.models.EstimatedWindow) = {
      play.api.libs.json.Json.obj(
        "from" -> play.api.libs.json.JsNumber(obj.from),
        "to" -> play.api.libs.json.JsNumber(obj.to),
        "unit" -> play.api.libs.json.JsString(obj.unit.toString)
      )
    }

    implicit def jsonWritesApiEstimatedWindow: play.api.libs.json.Writes[EstimatedWindow] = {
      new play.api.libs.json.Writes[io.flow.v0.models.EstimatedWindow] {
        def writes(obj: io.flow.v0.models.EstimatedWindow) = {
          jsObjectEstimatedWindow(obj)
        }
      }
    }

    implicit def jsonReadsApiException: play.api.libs.json.Reads[Exception] = {
      (
        (__ \ "type").read[io.flow.v0.models.ExceptionType] and
        (__ \ "datetime_range").read[io.flow.v0.models.DatetimeRange]
      )(Exception.apply _)
    }

    def jsObjectException(obj: io.flow.v0.models.Exception) = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "datetime_range" -> jsObjectDatetimeRange(obj.datetimeRange)
      )
    }

    implicit def jsonWritesApiException: play.api.libs.json.Writes[Exception] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Exception] {
        def writes(obj: io.flow.v0.models.Exception) = {
          jsObjectException(obj)
        }
      }
    }

    implicit def jsonReadsApiExperience: play.api.libs.json.Reads[Experience] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "delivered_duty").read[io.flow.v0.models.DeliveredDuty] and
        (__ \ "region").read[io.flow.v0.models.RegionReference] and
        (__ \ "country").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "language").read[String] and
        (__ \ "measurement_system").read[io.flow.v0.models.MeasurementSystem] and
        (__ \ "subcatalog").read[io.flow.v0.models.SubcatalogReference] and
        (__ \ "position").read[Long]
      )(Experience.apply _)
    }

    def jsObjectExperience(obj: io.flow.v0.models.Experience) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "region" -> jsObjectRegionReference(obj.region),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem.toString),
        "subcatalog" -> jsObjectSubcatalogReference(obj.subcatalog),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesApiExperience: play.api.libs.json.Writes[Experience] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Experience] {
        def writes(obj: io.flow.v0.models.Experience) = {
          jsObjectExperience(obj)
        }
      }
    }

    implicit def jsonReadsApiExperienceDeleted: play.api.libs.json.Reads[ExperienceDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "key").read[String] and
        (__ \ "subcatalog_id").read[String]
      )(ExperienceDeleted.apply _)
    }

    def jsObjectExperienceDeleted(obj: io.flow.v0.models.ExperienceDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "key" -> play.api.libs.json.JsString(obj.key),
        "subcatalog_id" -> play.api.libs.json.JsString(obj.subcatalogId)
      )
    }

    implicit def jsonReadsApiExperienceForm: play.api.libs.json.Reads[ExperienceForm] = {
      (
        (__ \ "region_id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "delivered_duty").readNullable[io.flow.v0.models.DeliveredDuty] and
        (__ \ "country").readNullable[String] and
        (__ \ "currency").readNullable[String] and
        (__ \ "language").readNullable[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "measurement_system").readNullable[io.flow.v0.models.MeasurementSystem] and
        (__ \ "subcatalog_id").readNullable[String] and
        (__ \ "position").readNullable[Long]
      )(ExperienceForm.apply _)
    }

    def jsObjectExperienceForm(obj: io.flow.v0.models.ExperienceForm) = {
      play.api.libs.json.Json.obj(
        "region_id" -> play.api.libs.json.JsString(obj.regionId),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.deliveredDuty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivered_duty" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.language match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("language" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.measurementSystem match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("measurement_system" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.subcatalogId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("subcatalog_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesApiExperienceForm: play.api.libs.json.Writes[ExperienceForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExperienceForm] {
        def writes(obj: io.flow.v0.models.ExperienceForm) = {
          jsObjectExperienceForm(obj)
        }
      }
    }

    implicit def jsonReadsApiExperienceReference: play.api.libs.json.Reads[ExperienceReference] = {
      (__ \ "id").read[String].map { x => new ExperienceReference(id = x) }
    }

    def jsObjectExperienceReference(obj: io.flow.v0.models.ExperienceReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiExperienceReference: play.api.libs.json.Writes[ExperienceReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExperienceReference] {
        def writes(obj: io.flow.v0.models.ExperienceReference) = {
          jsObjectExperienceReference(obj)
        }
      }
    }

    implicit def jsonReadsApiExperienceSummary: play.api.libs.json.Reads[ExperienceSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "currency").readNullable[String] and
        (__ \ "country").readNullable[String]
      )(ExperienceSummary.apply _)
    }

    def jsObjectExperienceSummary(obj: io.flow.v0.models.ExperienceSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.country match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("country" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiExperienceSummary: play.api.libs.json.Writes[ExperienceSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExperienceSummary] {
        def writes(obj: io.flow.v0.models.ExperienceSummary) = {
          jsObjectExperienceSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiExperienceUpserted: play.api.libs.json.Reads[ExperienceUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "delivered_duty").read[String] and
        (__ \ "subcatalog_id").read[String] and
        (__ \ "region_id").read[String] and
        (__ \ "country").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "language").read[String] and
        (__ \ "measurement_system").read[String] and
        (__ \ "position").read[Long]
      )(ExperienceUpserted.apply _)
    }

    def jsObjectExperienceUpserted(obj: io.flow.v0.models.ExperienceUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "key" -> play.api.libs.json.JsString(obj.key),
        "name" -> play.api.libs.json.JsString(obj.name),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty),
        "subcatalog_id" -> play.api.libs.json.JsString(obj.subcatalogId),
        "region_id" -> play.api.libs.json.JsString(obj.regionId),
        "country" -> play.api.libs.json.JsString(obj.country),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "language" -> play.api.libs.json.JsString(obj.language),
        "measurement_system" -> play.api.libs.json.JsString(obj.measurementSystem),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonReadsApiExperienceVersion: play.api.libs.json.Reads[ExperienceVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "experience").read[io.flow.v0.models.Experience]
      )(ExperienceVersion.apply _)
    }

    def jsObjectExperienceVersion(obj: io.flow.v0.models.ExperienceVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "experience" -> jsObjectExperience(obj.experience)
      )
    }

    implicit def jsonWritesApiExperienceVersion: play.api.libs.json.Writes[ExperienceVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExperienceVersion] {
        def writes(obj: io.flow.v0.models.ExperienceVersion) = {
          jsObjectExperienceVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiExpiration: play.api.libs.json.Reads[Expiration] = {
      (
        (__ \ "month").read[Int] and
        (__ \ "year").read[Int]
      )(Expiration.apply _)
    }

    def jsObjectExpiration(obj: io.flow.v0.models.Expiration) = {
      play.api.libs.json.Json.obj(
        "month" -> play.api.libs.json.JsNumber(obj.month),
        "year" -> play.api.libs.json.JsNumber(obj.year)
      )
    }

    implicit def jsonWritesApiExpiration: play.api.libs.json.Writes[Expiration] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Expiration] {
        def writes(obj: io.flow.v0.models.Expiration) = {
          jsObjectExpiration(obj)
        }
      }
    }

    implicit def jsonReadsApiFlatRate: play.api.libs.json.Reads[FlatRate] = {
      (__ \ "price").read[io.flow.v0.models.Price].map { x => new FlatRate(price = x) }
    }

    def jsObjectFlatRate(obj: io.flow.v0.models.FlatRate) = {
      play.api.libs.json.Json.obj(
        "price" -> jsObjectPrice(obj.price)
      )
    }

    implicit def jsonReadsApiFlowCurrencySettingDeleted: play.api.libs.json.Reads[FlowCurrencySettingDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "flow_currency_setting_id").read[String]
      )(FlowCurrencySettingDeleted.apply _)
    }

    def jsObjectFlowCurrencySettingDeleted(obj: io.flow.v0.models.FlowCurrencySettingDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "flow_currency_setting_id" -> play.api.libs.json.JsString(obj.flowCurrencySettingId)
      )
    }

    implicit def jsonReadsApiFlowCurrencySettingUpserted: play.api.libs.json.Reads[FlowCurrencySettingUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "flow_currency_setting_id").read[String] and
        (__ \ "organization_id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "margin").read[BigDecimal] and
        (__ \ "rate_lock_unit").read[String] and
        (__ \ "rate_lock_value").read[Long]
      )(FlowCurrencySettingUpserted.apply _)
    }

    def jsObjectFlowCurrencySettingUpserted(obj: io.flow.v0.models.FlowCurrencySettingUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "flow_currency_setting_id" -> play.api.libs.json.JsString(obj.flowCurrencySettingId),
        "organization_id" -> play.api.libs.json.JsString(obj.organizationId),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "margin" -> play.api.libs.json.JsNumber(obj.margin),
        "rate_lock_unit" -> play.api.libs.json.JsString(obj.rateLockUnit),
        "rate_lock_value" -> play.api.libs.json.JsNumber(obj.rateLockValue)
      )
    }

    implicit def jsonReadsApiFlowItemIndexMetadata: play.api.libs.json.Reads[FlowItemIndexMetadata] = {
      (__ \ "status").read[io.flow.v0.models.SubcatalogItemStatus].map { x => new FlowItemIndexMetadata(status = x) }
    }

    def jsObjectFlowItemIndexMetadata(obj: io.flow.v0.models.FlowItemIndexMetadata) = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesApiFlowItemIndexMetadata: play.api.libs.json.Writes[FlowItemIndexMetadata] = {
      new play.api.libs.json.Writes[io.flow.v0.models.FlowItemIndexMetadata] {
        def writes(obj: io.flow.v0.models.FlowItemIndexMetadata) = {
          jsObjectFlowItemIndexMetadata(obj)
        }
      }
    }

    implicit def jsonReadsApiFreeShipping: play.api.libs.json.Reads[FreeShipping] = {
      (__ \ "ignore").readNullable[String].map { x => new FreeShipping(ignore = x) }
    }

    def jsObjectFreeShipping(obj: io.flow.v0.models.FreeShipping) = {
      (obj.ignore match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ignore" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiFulfillmentExperienceReference: play.api.libs.json.Reads[FulfillmentExperienceReference] = {
      (
        (__ \ "id").read[String] and
        (__ \ "currency").read[String]
      )(FulfillmentExperienceReference.apply _)
    }

    def jsObjectFulfillmentExperienceReference(obj: io.flow.v0.models.FulfillmentExperienceReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonWritesApiFulfillmentExperienceReference: play.api.libs.json.Writes[FulfillmentExperienceReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.FulfillmentExperienceReference] {
        def writes(obj: io.flow.v0.models.FulfillmentExperienceReference) = {
          jsObjectFulfillmentExperienceReference(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizationDocument: play.api.libs.json.Reads[HarmonizationDocument] = {
      (
        (__ \ "code").read[String] and
        (__ \ "categories").read[Seq[io.flow.v0.models.CategorySummary]] and
        (__ \ "origin").readNullable[String]
      )(HarmonizationDocument.apply _)
    }

    def jsObjectHarmonizationDocument(obj: io.flow.v0.models.HarmonizationDocument) = {
      play.api.libs.json.Json.obj(
        "code" -> play.api.libs.json.JsString(obj.code),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories)
      ) ++ (obj.origin match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("origin" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiHarmonizationSettings: play.api.libs.json.Reads[HarmonizationSettings] = {
      (
        (__ \ "duty_strategy").read[io.flow.v0.models.LevyStrategy] and
        (__ \ "tax_strategy").read[io.flow.v0.models.LevyStrategy]
      )(HarmonizationSettings.apply _)
    }

    def jsObjectHarmonizationSettings(obj: io.flow.v0.models.HarmonizationSettings) = {
      play.api.libs.json.Json.obj(
        "duty_strategy" -> play.api.libs.json.JsString(obj.dutyStrategy.toString),
        "tax_strategy" -> play.api.libs.json.JsString(obj.taxStrategy.toString)
      )
    }

    implicit def jsonWritesApiHarmonizationSettings: play.api.libs.json.Writes[HarmonizationSettings] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizationSettings] {
        def writes(obj: io.flow.v0.models.HarmonizationSettings) = {
          jsObjectHarmonizationSettings(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizationSettingsForm: play.api.libs.json.Reads[HarmonizationSettingsForm] = {
      (
        (__ \ "duty_strategy").readNullable[io.flow.v0.models.LevyStrategy] and
        (__ \ "tax_strategy").readNullable[io.flow.v0.models.LevyStrategy]
      )(HarmonizationSettingsForm.apply _)
    }

    def jsObjectHarmonizationSettingsForm(obj: io.flow.v0.models.HarmonizationSettingsForm) = {
      (obj.dutyStrategy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty_strategy" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.taxStrategy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax_strategy" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesApiHarmonizationSettingsForm: play.api.libs.json.Writes[HarmonizationSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizationSettingsForm] {
        def writes(obj: io.flow.v0.models.HarmonizationSettingsForm) = {
          jsObjectHarmonizationSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedCategory: play.api.libs.json.Reads[HarmonizedCategory] = {
      (
        (__ \ "id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "parent").readNullable[io.flow.v0.models.HarmonizedCategoryReference]
      )(HarmonizedCategory.apply _)
    }

    def jsObjectHarmonizedCategory(obj: io.flow.v0.models.HarmonizedCategory) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.parent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent" -> jsObjectHarmonizedCategoryReference(x))
      })
    }

    implicit def jsonWritesApiHarmonizedCategory: play.api.libs.json.Writes[HarmonizedCategory] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedCategory] {
        def writes(obj: io.flow.v0.models.HarmonizedCategory) = {
          jsObjectHarmonizedCategory(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedCategoryReference: play.api.libs.json.Reads[HarmonizedCategoryReference] = {
      (__ \ "id").read[String].map { x => new HarmonizedCategoryReference(id = x) }
    }

    def jsObjectHarmonizedCategoryReference(obj: io.flow.v0.models.HarmonizedCategoryReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiHarmonizedCategoryReference: play.api.libs.json.Writes[HarmonizedCategoryReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedCategoryReference] {
        def writes(obj: io.flow.v0.models.HarmonizedCategoryReference) = {
          jsObjectHarmonizedCategoryReference(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItem: play.api.libs.json.Reads[HarmonizedItem] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String] and
        (__ \ "name").read[String] and
        (__ \ "description").readNullable[String] and
        (__ \ "categories").read[Seq[String]] and
        (__ \ "attributes").read[Map[String, String]]
      )(HarmonizedItem.apply _)
    }

    def jsObjectHarmonizedItem(obj: io.flow.v0.models.HarmonizedItem) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "name" -> play.api.libs.json.JsString(obj.name),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiHarmonizedItem: play.api.libs.json.Writes[HarmonizedItem] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItem] {
        def writes(obj: io.flow.v0.models.HarmonizedItem) = {
          jsObjectHarmonizedItem(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemDuty: play.api.libs.json.Reads[HarmonizedItemDuty] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item").read[io.flow.v0.models.HarmonizedItemReference] and
        (__ \ "origin").read[String] and
        (__ \ "destination").read[String] and
        (__ \ "rate").read[BigDecimal]
      )(HarmonizedItemDuty.apply _)
    }

    def jsObjectHarmonizedItemDuty(obj: io.flow.v0.models.HarmonizedItemDuty) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "rate" -> play.api.libs.json.JsNumber(obj.rate)
      )
    }

    implicit def jsonWritesApiHarmonizedItemDuty: play.api.libs.json.Writes[HarmonizedItemDuty] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemDuty] {
        def writes(obj: io.flow.v0.models.HarmonizedItemDuty) = {
          jsObjectHarmonizedItemDuty(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemDutyForm: play.api.libs.json.Reads[HarmonizedItemDutyForm] = {
      (
        (__ \ "number").read[String] and
        (__ \ "origin").read[String] and
        (__ \ "destination").read[String] and
        (__ \ "rate").read[BigDecimal]
      )(HarmonizedItemDutyForm.apply _)
    }

    def jsObjectHarmonizedItemDutyForm(obj: io.flow.v0.models.HarmonizedItemDutyForm) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "rate" -> play.api.libs.json.JsNumber(obj.rate)
      )
    }

    implicit def jsonWritesApiHarmonizedItemDutyForm: play.api.libs.json.Writes[HarmonizedItemDutyForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemDutyForm] {
        def writes(obj: io.flow.v0.models.HarmonizedItemDutyForm) = {
          jsObjectHarmonizedItemDutyForm(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemDutyVersion: play.api.libs.json.Reads[HarmonizedItemDutyVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "harmonized_item_duty").read[io.flow.v0.models.HarmonizedItemDuty]
      )(HarmonizedItemDutyVersion.apply _)
    }

    def jsObjectHarmonizedItemDutyVersion(obj: io.flow.v0.models.HarmonizedItemDutyVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "harmonized_item_duty" -> jsObjectHarmonizedItemDuty(obj.harmonizedItemDuty)
      )
    }

    implicit def jsonWritesApiHarmonizedItemDutyVersion: play.api.libs.json.Writes[HarmonizedItemDutyVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemDutyVersion] {
        def writes(obj: io.flow.v0.models.HarmonizedItemDutyVersion) = {
          jsObjectHarmonizedItemDutyVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemForm: play.api.libs.json.Reads[HarmonizedItemForm] = {
      (
        (__ \ "name").read[String] and
        (__ \ "number").read[String] and
        (__ \ "categories").readNullable[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").readNullable[Map[String, String]]
      )(HarmonizedItemForm.apply _)
    }

    def jsObjectHarmonizedItemForm(obj: io.flow.v0.models.HarmonizedItemForm) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "number" -> play.api.libs.json.JsString(obj.number)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesApiHarmonizedItemForm: play.api.libs.json.Writes[HarmonizedItemForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemForm] {
        def writes(obj: io.flow.v0.models.HarmonizedItemForm) = {
          jsObjectHarmonizedItemForm(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemPutForm: play.api.libs.json.Reads[HarmonizedItemPutForm] = {
      (
        (__ \ "name").read[String] and
        (__ \ "categories").readNullable[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").readNullable[Map[String, String]]
      )(HarmonizedItemPutForm.apply _)
    }

    def jsObjectHarmonizedItemPutForm(obj: io.flow.v0.models.HarmonizedItemPutForm) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesApiHarmonizedItemPutForm: play.api.libs.json.Writes[HarmonizedItemPutForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemPutForm] {
        def writes(obj: io.flow.v0.models.HarmonizedItemPutForm) = {
          jsObjectHarmonizedItemPutForm(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemReference: play.api.libs.json.Reads[HarmonizedItemReference] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String]
      )(HarmonizedItemReference.apply _)
    }

    def jsObjectHarmonizedItemReference(obj: io.flow.v0.models.HarmonizedItemReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesApiHarmonizedItemReference: play.api.libs.json.Writes[HarmonizedItemReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemReference] {
        def writes(obj: io.flow.v0.models.HarmonizedItemReference) = {
          jsObjectHarmonizedItemReference(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedItemVersion: play.api.libs.json.Reads[HarmonizedItemVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "harmonized_item").read[io.flow.v0.models.HarmonizedItem]
      )(HarmonizedItemVersion.apply _)
    }

    def jsObjectHarmonizedItemVersion(obj: io.flow.v0.models.HarmonizedItemVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "harmonized_item" -> jsObjectHarmonizedItem(obj.harmonizedItem)
      )
    }

    implicit def jsonWritesApiHarmonizedItemVersion: play.api.libs.json.Writes[HarmonizedItemVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedItemVersion] {
        def writes(obj: io.flow.v0.models.HarmonizedItemVersion) = {
          jsObjectHarmonizedItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedLandedCost: play.api.libs.json.Reads[HarmonizedLandedCost] = {
      (
        (__ \ "address").read[io.flow.v0.models.Address] and
        (__ \ "items").read[Seq[io.flow.v0.models.HarmonizedLandedCostItem]]
      )(HarmonizedLandedCost.apply _)
    }

    def jsObjectHarmonizedLandedCost(obj: io.flow.v0.models.HarmonizedLandedCost) = {
      play.api.libs.json.Json.obj(
        "address" -> jsObjectAddress(obj.address),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesApiHarmonizedLandedCost: play.api.libs.json.Writes[HarmonizedLandedCost] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedLandedCost] {
        def writes(obj: io.flow.v0.models.HarmonizedLandedCost) = {
          jsObjectHarmonizedLandedCost(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedLandedCostForm: play.api.libs.json.Reads[HarmonizedLandedCostForm] = {
      (
        (__ \ "address").read[io.flow.v0.models.Address] and
        (__ \ "item_numbers").read[Seq[String]]
      )(HarmonizedLandedCostForm.apply _)
    }

    def jsObjectHarmonizedLandedCostForm(obj: io.flow.v0.models.HarmonizedLandedCostForm) = {
      play.api.libs.json.Json.obj(
        "address" -> jsObjectAddress(obj.address),
        "item_numbers" -> play.api.libs.json.Json.toJson(obj.itemNumbers)
      )
    }

    implicit def jsonWritesApiHarmonizedLandedCostForm: play.api.libs.json.Writes[HarmonizedLandedCostForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedLandedCostForm] {
        def writes(obj: io.flow.v0.models.HarmonizedLandedCostForm) = {
          jsObjectHarmonizedLandedCostForm(obj)
        }
      }
    }

    implicit def jsonReadsApiHarmonizedLandedCostItem: play.api.libs.json.Reads[HarmonizedLandedCostItem] = {
      (
        (__ \ "item").read[io.flow.v0.models.HarmonizedItemReference] and
        (__ \ "duty").read[io.flow.v0.models.Duty] and
        (__ \ "tax").read[io.flow.v0.models.Tax]
      )(HarmonizedLandedCostItem.apply _)
    }

    def jsObjectHarmonizedLandedCostItem(obj: io.flow.v0.models.HarmonizedLandedCostItem) = {
      play.api.libs.json.Json.obj(
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "duty" -> jsObjectDuty(obj.duty),
        "tax" -> jsObjectTax(obj.tax)
      )
    }

    implicit def jsonWritesApiHarmonizedLandedCostItem: play.api.libs.json.Writes[HarmonizedLandedCostItem] = {
      new play.api.libs.json.Writes[io.flow.v0.models.HarmonizedLandedCostItem] {
        def writes(obj: io.flow.v0.models.HarmonizedLandedCostItem) = {
          jsObjectHarmonizedLandedCostItem(obj)
        }
      }
    }

    implicit def jsonReadsApiHeader: play.api.libs.json.Reads[Header] = {
      (
        (__ \ "name").read[String] and
        (__ \ "value").read[String]
      )(Header.apply _)
    }

    def jsObjectHeader(obj: io.flow.v0.models.Header) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesApiHeader: play.api.libs.json.Writes[Header] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Header] {
        def writes(obj: io.flow.v0.models.Header) = {
          jsObjectHeader(obj)
        }
      }
    }

    implicit def jsonReadsApiHealthcheck: play.api.libs.json.Reads[Healthcheck] = {
      (__ \ "status").read[String].map { x => new Healthcheck(status = x) }
    }

    def jsObjectHealthcheck(obj: io.flow.v0.models.Healthcheck) = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesApiHealthcheck: play.api.libs.json.Writes[Healthcheck] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Healthcheck] {
        def writes(obj: io.flow.v0.models.Healthcheck) = {
          jsObjectHealthcheck(obj)
        }
      }
    }

    implicit def jsonReadsApiHs10: play.api.libs.json.Reads[Hs10] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item").read[io.flow.v0.models.HarmonizedItemReference] and
        (__ \ "origin").read[String] and
        (__ \ "destination").read[String] and
        (__ \ "code").read[String]
      )(Hs10.apply _)
    }

    def jsObjectHs10(obj: io.flow.v0.models.Hs10) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesApiHs10: play.api.libs.json.Writes[Hs10] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Hs10] {
        def writes(obj: io.flow.v0.models.Hs10) = {
          jsObjectHs10(obj)
        }
      }
    }

    implicit def jsonReadsApiHs10CodeDeleted: play.api.libs.json.Reads[Hs10CodeDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "origin").read[String] and
        (__ \ "destination").read[String]
      )(Hs10CodeDeleted.apply _)
    }

    def jsObjectHs10CodeDeleted(obj: io.flow.v0.models.Hs10CodeDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination)
      )
    }

    implicit def jsonReadsApiHs10CodeUpserted: play.api.libs.json.Reads[Hs10CodeUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "origin").read[String] and
        (__ \ "destination").read[String] and
        (__ \ "code").read[String]
      )(Hs10CodeUpserted.apply _)
    }

    def jsObjectHs10CodeUpserted(obj: io.flow.v0.models.Hs10CodeUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "origin" -> play.api.libs.json.JsString(obj.origin),
        "destination" -> play.api.libs.json.JsString(obj.destination),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonReadsApiHs10Version: play.api.libs.json.Reads[Hs10Version] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "hs10").read[io.flow.v0.models.Hs10]
      )(Hs10Version.apply _)
    }

    def jsObjectHs10Version(obj: io.flow.v0.models.Hs10Version) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "hs10" -> jsObjectHs10(obj.hs10)
      )
    }

    implicit def jsonWritesApiHs10Version: play.api.libs.json.Writes[Hs10Version] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Hs10Version] {
        def writes(obj: io.flow.v0.models.Hs10Version) = {
          jsObjectHs10Version(obj)
        }
      }
    }

    implicit def jsonReadsApiHs6: play.api.libs.json.Reads[Hs6] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item").read[io.flow.v0.models.HarmonizedItemReference] and
        (__ \ "code").read[String]
      )(Hs6.apply _)
    }

    def jsObjectHs6(obj: io.flow.v0.models.Hs6) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectHarmonizedItemReference(obj.item),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesApiHs6: play.api.libs.json.Writes[Hs6] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Hs6] {
        def writes(obj: io.flow.v0.models.Hs6) = {
          jsObjectHs6(obj)
        }
      }
    }

    implicit def jsonReadsApiHs6CodeDeleted: play.api.libs.json.Reads[Hs6CodeDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String]
      )(Hs6CodeDeleted.apply _)
    }

    def jsObjectHs6CodeDeleted(obj: io.flow.v0.models.Hs6CodeDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonReadsApiHs6CodeUpserted: play.api.libs.json.Reads[Hs6CodeUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "code").read[String]
      )(Hs6CodeUpserted.apply _)
    }

    def jsObjectHs6CodeUpserted(obj: io.flow.v0.models.Hs6CodeUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonReadsApiHs6Version: play.api.libs.json.Reads[Hs6Version] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "hs6").read[io.flow.v0.models.Hs6]
      )(Hs6Version.apply _)
    }

    def jsObjectHs6Version(obj: io.flow.v0.models.Hs6Version) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "hs6" -> jsObjectHs6(obj.hs6)
      )
    }

    implicit def jsonWritesApiHs6Version: play.api.libs.json.Writes[Hs6Version] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Hs6Version] {
        def writes(obj: io.flow.v0.models.Hs6Version) = {
          jsObjectHs6Version(obj)
        }
      }
    }

    implicit def jsonReadsApiImage: play.api.libs.json.Reads[Image] = {
      (
        (__ \ "url").read[String] and
        (__ \ "tags").read[Seq[String]]
      )(Image.apply _)
    }

    def jsObjectImage(obj: io.flow.v0.models.Image) = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "tags" -> play.api.libs.json.Json.toJson(obj.tags)
      )
    }

    implicit def jsonWritesApiImage: play.api.libs.json.Writes[Image] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Image] {
        def writes(obj: io.flow.v0.models.Image) = {
          jsObjectImage(obj)
        }
      }
    }

    implicit def jsonReadsApiImageForm: play.api.libs.json.Reads[ImageForm] = {
      (
        (__ \ "url").read[String] and
        (__ \ "tags").readNullable[Seq[String]]
      )(ImageForm.apply _)
    }

    def jsObjectImageForm(obj: io.flow.v0.models.ImageForm) = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url)
      ) ++ (obj.tags match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tags" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesApiImageForm: play.api.libs.json.Writes[ImageForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ImageForm] {
        def writes(obj: io.flow.v0.models.ImageForm) = {
          jsObjectImageForm(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryBackorder: play.api.libs.json.Reads[InventoryBackorder] = {
      (__ \ "quantity").read[Long].map { x => new InventoryBackorder(quantity = x) }
    }

    def jsObjectInventoryBackorder(obj: io.flow.v0.models.InventoryBackorder) = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonReadsApiInventoryCenterReference: play.api.libs.json.Reads[InventoryCenterReference] = {
      (__ \ "key").read[String].map { x => new InventoryCenterReference(key = x) }
    }

    def jsObjectInventoryCenterReference(obj: io.flow.v0.models.InventoryCenterReference) = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key)
      )
    }

    implicit def jsonWritesApiInventoryCenterReference: play.api.libs.json.Writes[InventoryCenterReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryCenterReference] {
        def writes(obj: io.flow.v0.models.InventoryCenterReference) = {
          jsObjectInventoryCenterReference(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryItemReference: play.api.libs.json.Reads[InventoryItemReference] = {
      (__ \ "number").read[String].map { x => new InventoryItemReference(number = x) }
    }

    def jsObjectInventoryItemReference(obj: io.flow.v0.models.InventoryItemReference) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number)
      )
    }

    implicit def jsonWritesApiInventoryItemReference: play.api.libs.json.Writes[InventoryItemReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryItemReference] {
        def writes(obj: io.flow.v0.models.InventoryItemReference) = {
          jsObjectInventoryItemReference(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryRule: play.api.libs.json.Reads[InventoryRule] = {
      (
        (__ \ "id").read[String] and
        (__ \ "position").read[Long] and
        (__ \ "query").read[String] and
        (__ \ "strategy").read[io.flow.v0.models.InventoryStrategy]
      )(InventoryRule.apply _)
    }

    def jsObjectInventoryRule(obj: io.flow.v0.models.InventoryRule) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "strategy" -> jsObjectInventoryStrategy(obj.strategy)
      )
    }

    implicit def jsonWritesApiInventoryRule: play.api.libs.json.Writes[InventoryRule] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryRule] {
        def writes(obj: io.flow.v0.models.InventoryRule) = {
          jsObjectInventoryRule(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryRuleForm: play.api.libs.json.Reads[InventoryRuleForm] = {
      (
        (__ \ "position").read[Long] and
        (__ \ "query").read[String] and
        (__ \ "strategy").read[io.flow.v0.models.InventoryStrategy]
      )(InventoryRuleForm.apply _)
    }

    def jsObjectInventoryRuleForm(obj: io.flow.v0.models.InventoryRuleForm) = {
      play.api.libs.json.Json.obj(
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "strategy" -> jsObjectInventoryStrategy(obj.strategy)
      )
    }

    implicit def jsonWritesApiInventoryRuleForm: play.api.libs.json.Writes[InventoryRuleForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryRuleForm] {
        def writes(obj: io.flow.v0.models.InventoryRuleForm) = {
          jsObjectInventoryRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryRuleVersion: play.api.libs.json.Reads[InventoryRuleVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "inventory_rule").read[io.flow.v0.models.InventoryRule]
      )(InventoryRuleVersion.apply _)
    }

    def jsObjectInventoryRuleVersion(obj: io.flow.v0.models.InventoryRuleVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_rule" -> jsObjectInventoryRule(obj.inventoryRule)
      )
    }

    implicit def jsonWritesApiInventoryRuleVersion: play.api.libs.json.Writes[InventoryRuleVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryRuleVersion] {
        def writes(obj: io.flow.v0.models.InventoryRuleVersion) = {
          jsObjectInventoryRuleVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiInventorySnapshot: play.api.libs.json.Reads[InventorySnapshot] = {
      (
        (__ \ "id").read[String] and
        (__ \ "available").read[Long] and
        (__ \ "center").read[io.flow.v0.models.InventoryCenterReference] and
        (__ \ "item").read[io.flow.v0.models.InventoryItemReference] and
        (__ \ "quantity").read[Long]
      )(InventorySnapshot.apply _)
    }

    def jsObjectInventorySnapshot(obj: io.flow.v0.models.InventorySnapshot) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "available" -> play.api.libs.json.JsNumber(obj.available),
        "center" -> jsObjectInventoryCenterReference(obj.center),
        "item" -> jsObjectInventoryItemReference(obj.item),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonWritesApiInventorySnapshot: play.api.libs.json.Writes[InventorySnapshot] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventorySnapshot] {
        def writes(obj: io.flow.v0.models.InventorySnapshot) = {
          jsObjectInventorySnapshot(obj)
        }
      }
    }

    implicit def jsonReadsApiInventorySnapshotVersion: play.api.libs.json.Reads[InventorySnapshotVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "inventory_snapshot").read[io.flow.v0.models.InventorySnapshot]
      )(InventorySnapshotVersion.apply _)
    }

    def jsObjectInventorySnapshotVersion(obj: io.flow.v0.models.InventorySnapshotVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_snapshot" -> jsObjectInventorySnapshot(obj.inventorySnapshot)
      )
    }

    implicit def jsonWritesApiInventorySnapshotVersion: play.api.libs.json.Writes[InventorySnapshotVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventorySnapshotVersion] {
        def writes(obj: io.flow.v0.models.InventorySnapshotVersion) = {
          jsObjectInventorySnapshotVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryStock: play.api.libs.json.Reads[InventoryStock] = {
      (__ \ "quantity").read[Long].map { x => new InventoryStock(quantity = x) }
    }

    def jsObjectInventoryStock(obj: io.flow.v0.models.InventoryStock) = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      )
    }

    implicit def jsonReadsApiInventoryUnlimited: play.api.libs.json.Reads[InventoryUnlimited] = {
      (__ \ "quantity").read[String].map { x => new InventoryUnlimited(quantity = x) }
    }

    def jsObjectInventoryUnlimited(obj: io.flow.v0.models.InventoryUnlimited) = {
      play.api.libs.json.Json.obj(
        "quantity" -> play.api.libs.json.JsString(obj.quantity)
      )
    }

    implicit def jsonReadsApiInventoryUpdate: play.api.libs.json.Reads[InventoryUpdate] = {
      (
        (__ \ "id").read[String] and
        (__ \ "idempotency_key").read[String] and
        (__ \ "center").read[io.flow.v0.models.InventoryCenterReference] and
        (__ \ "item").read[io.flow.v0.models.InventoryItemReference] and
        (__ \ "notes").read[_root_.play.api.libs.json.JsObject] and
        (__ \ "quantity").read[Long] and
        (__ \ "type").read[io.flow.v0.models.UpdateType]
      )(InventoryUpdate.apply _)
    }

    def jsObjectInventoryUpdate(obj: io.flow.v0.models.InventoryUpdate) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "idempotency_key" -> play.api.libs.json.JsString(obj.idempotencyKey),
        "center" -> jsObjectInventoryCenterReference(obj.center),
        "item" -> jsObjectInventoryItemReference(obj.item),
        "notes" -> obj.notes,
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesApiInventoryUpdate: play.api.libs.json.Writes[InventoryUpdate] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryUpdate] {
        def writes(obj: io.flow.v0.models.InventoryUpdate) = {
          jsObjectInventoryUpdate(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryUpdateForm: play.api.libs.json.Reads[InventoryUpdateForm] = {
      (
        (__ \ "center").read[String] and
        (__ \ "idempotency_key").read[String] and
        (__ \ "item_number").read[String] and
        (__ \ "quantity").read[Long] and
        (__ \ "type").read[io.flow.v0.models.UpdateType] and
        (__ \ "notes").readNullable[_root_.play.api.libs.json.JsObject]
      )(InventoryUpdateForm.apply _)
    }

    def jsObjectInventoryUpdateForm(obj: io.flow.v0.models.InventoryUpdateForm) = {
      play.api.libs.json.Json.obj(
        "center" -> play.api.libs.json.JsString(obj.center),
        "idempotency_key" -> play.api.libs.json.JsString(obj.idempotencyKey),
        "item_number" -> play.api.libs.json.JsString(obj.itemNumber),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.notes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("notes" -> x)
      })
    }

    implicit def jsonWritesApiInventoryUpdateForm: play.api.libs.json.Writes[InventoryUpdateForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryUpdateForm] {
        def writes(obj: io.flow.v0.models.InventoryUpdateForm) = {
          jsObjectInventoryUpdateForm(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryUpdateVersion: play.api.libs.json.Reads[InventoryUpdateVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "inventory_update").read[io.flow.v0.models.InventoryUpdate]
      )(InventoryUpdateVersion.apply _)
    }

    def jsObjectInventoryUpdateVersion(obj: io.flow.v0.models.InventoryUpdateVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "inventory_update" -> jsObjectInventoryUpdate(obj.inventoryUpdate)
      )
    }

    implicit def jsonWritesApiInventoryUpdateVersion: play.api.libs.json.Writes[InventoryUpdateVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryUpdateVersion] {
        def writes(obj: io.flow.v0.models.InventoryUpdateVersion) = {
          jsObjectInventoryUpdateVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiInvitation: play.api.libs.json.Reads[Invitation] = {
      (
        (__ \ "id").read[String] and
        (__ \ "organization").read[io.flow.v0.models.ExpandableOrganization] and
        (__ \ "email").read[String] and
        (__ \ "name").read[io.flow.v0.models.Name] and
        (__ \ "role").read[io.flow.v0.models.Role] and
        (__ \ "expiration").read[_root_.org.joda.time.DateTime]
      )(Invitation.apply _)
    }

    def jsObjectInvitation(obj: io.flow.v0.models.Invitation) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "organization" -> jsObjectExpandableOrganization(obj.organization),
        "email" -> play.api.libs.json.JsString(obj.email),
        "name" -> jsObjectName(obj.name),
        "role" -> play.api.libs.json.JsString(obj.role.toString),
        "expiration" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiration))
      )
    }

    implicit def jsonWritesApiInvitation: play.api.libs.json.Writes[Invitation] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Invitation] {
        def writes(obj: io.flow.v0.models.Invitation) = {
          jsObjectInvitation(obj)
        }
      }
    }

    implicit def jsonReadsApiInvitationAcceptsForm: play.api.libs.json.Reads[InvitationAcceptsForm] = {
      (__ \ "user_id").read[String].map { x => new InvitationAcceptsForm(userId = x) }
    }

    def jsObjectInvitationAcceptsForm(obj: io.flow.v0.models.InvitationAcceptsForm) = {
      play.api.libs.json.Json.obj(
        "user_id" -> play.api.libs.json.JsString(obj.userId)
      )
    }

    implicit def jsonWritesApiInvitationAcceptsForm: play.api.libs.json.Writes[InvitationAcceptsForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InvitationAcceptsForm] {
        def writes(obj: io.flow.v0.models.InvitationAcceptsForm) = {
          jsObjectInvitationAcceptsForm(obj)
        }
      }
    }

    implicit def jsonReadsApiInvitationForm: play.api.libs.json.Reads[InvitationForm] = {
      (
        (__ \ "organization").read[String] and
        (__ \ "email").read[String] and
        (__ \ "name").readNullable[io.flow.v0.models.Name] and
        (__ \ "role").read[io.flow.v0.models.Role]
      )(InvitationForm.apply _)
    }

    def jsObjectInvitationForm(obj: io.flow.v0.models.InvitationForm) = {
      play.api.libs.json.Json.obj(
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "email" -> play.api.libs.json.JsString(obj.email),
        "role" -> play.api.libs.json.JsString(obj.role.toString)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> jsObjectName(x))
      })
    }

    implicit def jsonWritesApiInvitationForm: play.api.libs.json.Writes[InvitationForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InvitationForm] {
        def writes(obj: io.flow.v0.models.InvitationForm) = {
          jsObjectInvitationForm(obj)
        }
      }
    }

    implicit def jsonReadsApiInvitationVersion: play.api.libs.json.Reads[InvitationVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "invitation").read[io.flow.v0.models.Invitation]
      )(InvitationVersion.apply _)
    }

    def jsObjectInvitationVersion(obj: io.flow.v0.models.InvitationVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "invitation" -> jsObjectInvitation(obj.invitation)
      )
    }

    implicit def jsonWritesApiInvitationVersion: play.api.libs.json.Writes[InvitationVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InvitationVersion] {
        def writes(obj: io.flow.v0.models.InvitationVersion) = {
          jsObjectInvitationVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiItem: play.api.libs.json.Reads[Item] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String] and
        (__ \ "locale").read[String] and
        (__ \ "name").read[String] and
        (__ \ "price").read[io.flow.v0.models.Price] and
        (__ \ "categories").read[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "dimensions").read[io.flow.v0.models.Dimensions] and
        (__ \ "images").read[Seq[io.flow.v0.models.Image]] and
        (__ \ "local").readNullable[io.flow.v0.models.Local]
      )(Item.apply _)
    }

    def jsObjectItem(obj: io.flow.v0.models.Item) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "price" -> jsObjectPrice(obj.price),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "dimensions" -> jsObjectDimensions(obj.dimensions),
        "images" -> play.api.libs.json.Json.toJson(obj.images)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.local match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("local" -> jsObjectLocal(x))
      })
    }

    implicit def jsonWritesApiItem: play.api.libs.json.Writes[Item] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Item] {
        def writes(obj: io.flow.v0.models.Item) = {
          jsObjectItem(obj)
        }
      }
    }

    implicit def jsonReadsApiItemForm: play.api.libs.json.Reads[ItemForm] = {
      (
        (__ \ "number").read[String] and
        (__ \ "locale").read[String] and
        (__ \ "name").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "price").read[Double] and
        (__ \ "categories").readNullable[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").readNullable[Map[String, String]] and
        (__ \ "dimensions").readNullable[io.flow.v0.models.Dimensions] and
        (__ \ "images").readNullable[Seq[io.flow.v0.models.ImageForm]]
      )(ItemForm.apply _)
    }

    def jsObjectItemForm(obj: io.flow.v0.models.ItemForm) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price)
      ) ++ (obj.categories match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("categories" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.dimensions match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("dimensions" -> jsObjectDimensions(x))
      }) ++
      (obj.images match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("images" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesApiItemForm: play.api.libs.json.Writes[ItemForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemForm] {
        def writes(obj: io.flow.v0.models.ItemForm) = {
          jsObjectItemForm(obj)
        }
      }
    }

    implicit def jsonReadsApiItemFunction: play.api.libs.json.Reads[ItemFunction] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "description").read[String] and
        (__ \ "code").read[String]
      )(ItemFunction.apply _)
    }

    def jsObjectItemFunction(obj: io.flow.v0.models.ItemFunction) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "description" -> play.api.libs.json.JsString(obj.description),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonReadsApiItemFunctionPostForm: play.api.libs.json.Reads[ItemFunctionPostForm] = {
      (
        (__ \ "description").read[String] and
        (__ \ "code").read[String] and
        (__ \ "key").readNullable[String]
      )(ItemFunctionPostForm.apply _)
    }

    def jsObjectItemFunctionPostForm(obj: io.flow.v0.models.ItemFunctionPostForm) = {
      play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.JsString(obj.description),
        "code" -> play.api.libs.json.JsString(obj.code)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiItemFunctionPostForm: play.api.libs.json.Writes[ItemFunctionPostForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemFunctionPostForm] {
        def writes(obj: io.flow.v0.models.ItemFunctionPostForm) = {
          jsObjectItemFunctionPostForm(obj)
        }
      }
    }

    implicit def jsonReadsApiItemFunctionPutForm: play.api.libs.json.Reads[ItemFunctionPutForm] = {
      (
        (__ \ "description").read[String] and
        (__ \ "code").read[String]
      )(ItemFunctionPutForm.apply _)
    }

    def jsObjectItemFunctionPutForm(obj: io.flow.v0.models.ItemFunctionPutForm) = {
      play.api.libs.json.Json.obj(
        "description" -> play.api.libs.json.JsString(obj.description),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesApiItemFunctionPutForm: play.api.libs.json.Writes[ItemFunctionPutForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemFunctionPutForm] {
        def writes(obj: io.flow.v0.models.ItemFunctionPutForm) = {
          jsObjectItemFunctionPutForm(obj)
        }
      }
    }

    implicit def jsonReadsApiItemFunctionReference: play.api.libs.json.Reads[ItemFunctionReference] = {
      (__ \ "id").read[String].map { x => new ItemFunctionReference(id = x) }
    }

    def jsObjectItemFunctionReference(obj: io.flow.v0.models.ItemFunctionReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsApiItemFunctionVersion: play.api.libs.json.Reads[ItemFunctionVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "item_function").read[io.flow.v0.models.ItemFunction]
      )(ItemFunctionVersion.apply _)
    }

    def jsObjectItemFunctionVersion(obj: io.flow.v0.models.ItemFunctionVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item_function" -> jsObjectItemFunction(obj.itemFunction)
      )
    }

    implicit def jsonWritesApiItemFunctionVersion: play.api.libs.json.Writes[ItemFunctionVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemFunctionVersion] {
        def writes(obj: io.flow.v0.models.ItemFunctionVersion) = {
          jsObjectItemFunctionVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiItemMargin: play.api.libs.json.Reads[ItemMargin] = {
      (
        (__ \ "id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "q").read[String] and
        (__ \ "margin").read[io.flow.v0.models.Margin] and
        (__ \ "position").read[Long]
      )(ItemMargin.apply _)
    }

    def jsObjectItemMargin(obj: io.flow.v0.models.ItemMargin) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q),
        "margin" -> jsObjectMargin(obj.margin),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesApiItemMargin: play.api.libs.json.Writes[ItemMargin] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemMargin] {
        def writes(obj: io.flow.v0.models.ItemMargin) = {
          jsObjectItemMargin(obj)
        }
      }
    }

    implicit def jsonReadsApiItemMarginDeleted: play.api.libs.json.Reads[ItemMarginDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "item_margin_id").read[String]
      )(ItemMarginDeleted.apply _)
    }

    def jsObjectItemMarginDeleted(obj: io.flow.v0.models.ItemMarginDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "item_margin_id" -> play.api.libs.json.JsString(obj.itemMarginId)
      )
    }

    implicit def jsonReadsApiItemMarginForm: play.api.libs.json.Reads[ItemMarginForm] = {
      (
        (__ \ "name").read[String] and
        (__ \ "margin").read[io.flow.v0.models.Margin] and
        (__ \ "q").read[String] and
        (__ \ "position").readNullable[Long]
      )(ItemMarginForm.apply _)
    }

    def jsObjectItemMarginForm(obj: io.flow.v0.models.ItemMarginForm) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "margin" -> jsObjectMargin(obj.margin),
        "q" -> play.api.libs.json.JsString(obj.q)
      ) ++ (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesApiItemMarginForm: play.api.libs.json.Writes[ItemMarginForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemMarginForm] {
        def writes(obj: io.flow.v0.models.ItemMarginForm) = {
          jsObjectItemMarginForm(obj)
        }
      }
    }

    implicit def jsonReadsApiItemMarginUpserted: play.api.libs.json.Reads[ItemMarginUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "item_margin_id").read[String] and
        (__ \ "organization_id").read[String] and
        (__ \ "experience_key").read[String] and
        (__ \ "name").read[String] and
        (__ \ "q").read[String] and
        (__ \ "margin_type").read[String] and
        (__ \ "margin_value").read[BigDecimal] and
        (__ \ "position").read[Long]
      )(ItemMarginUpserted.apply _)
    }

    def jsObjectItemMarginUpserted(obj: io.flow.v0.models.ItemMarginUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "item_margin_id" -> play.api.libs.json.JsString(obj.itemMarginId),
        "organization_id" -> play.api.libs.json.JsString(obj.organizationId),
        "experience_key" -> play.api.libs.json.JsString(obj.experienceKey),
        "name" -> play.api.libs.json.JsString(obj.name),
        "q" -> play.api.libs.json.JsString(obj.q),
        "margin_type" -> play.api.libs.json.JsString(obj.marginType),
        "margin_value" -> play.api.libs.json.JsNumber(obj.marginValue),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonReadsApiItemMarginVersion: play.api.libs.json.Reads[ItemMarginVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "item_margin").read[io.flow.v0.models.ItemMargin]
      )(ItemMarginVersion.apply _)
    }

    def jsObjectItemMarginVersion(obj: io.flow.v0.models.ItemMarginVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item_margin" -> jsObjectItemMargin(obj.itemMargin)
      )
    }

    implicit def jsonWritesApiItemMarginVersion: play.api.libs.json.Writes[ItemMarginVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemMarginVersion] {
        def writes(obj: io.flow.v0.models.ItemMarginVersion) = {
          jsObjectItemMarginVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiItemStatistics: play.api.libs.json.Reads[ItemStatistics] = {
      (
        (__ \ "items").read[Long] and
        (__ \ "categories").read[Long]
      )(ItemStatistics.apply _)
    }

    def jsObjectItemStatistics(obj: io.flow.v0.models.ItemStatistics) = {
      play.api.libs.json.Json.obj(
        "items" -> play.api.libs.json.JsNumber(obj.items),
        "categories" -> play.api.libs.json.JsNumber(obj.categories)
      )
    }

    implicit def jsonWritesApiItemStatistics: play.api.libs.json.Writes[ItemStatistics] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemStatistics] {
        def writes(obj: io.flow.v0.models.ItemStatistics) = {
          jsObjectItemStatistics(obj)
        }
      }
    }

    implicit def jsonReadsApiItemVersion: play.api.libs.json.Reads[ItemVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "item").read[io.flow.v0.models.Item]
      )(ItemVersion.apply _)
    }

    def jsObjectItemVersion(obj: io.flow.v0.models.ItemVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "item" -> jsObjectItem(obj.item)
      )
    }

    implicit def jsonWritesApiItemVersion: play.api.libs.json.Writes[ItemVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ItemVersion] {
        def writes(obj: io.flow.v0.models.ItemVersion) = {
          jsObjectItemVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiLabel: play.api.libs.json.Reads[Label] = {
      (
        (__ \ "id").read[String] and
        (__ \ "tracking").read[io.flow.v0.models.TrackingSummary] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "carrier").read[String] and
        (__ \ "tracking_number").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "delivery_estimate").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "description").readNullable[String]
      )(Label.apply _)
    }

    def jsObjectLabel(obj: io.flow.v0.models.Label) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "tracking" -> jsObjectTrackingSummary(obj.tracking),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "carrier" -> play.api.libs.json.JsString(obj.carrier),
        "tracking_number" -> play.api.libs.json.JsString(obj.trackingNumber),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp))
      ) ++ (obj.deliveryEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivery_estimate" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiLabel: play.api.libs.json.Writes[Label] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Label] {
        def writes(obj: io.flow.v0.models.Label) = {
          jsObjectLabel(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelEvent: play.api.libs.json.Reads[LabelEvent] = {
      (
        (__ \ "id").read[String] and
        (__ \ "label").read[io.flow.v0.models.LabelSummary] and
        (__ \ "address").read[io.flow.v0.models.Address] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "description").readNullable[String]
      )(LabelEvent.apply _)
    }

    def jsObjectLabelEvent(obj: io.flow.v0.models.LabelEvent) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "label" -> jsObjectLabelSummary(obj.label),
        "address" -> jsObjectAddress(obj.address),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp))
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiLabelEvent: play.api.libs.json.Writes[LabelEvent] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelEvent] {
        def writes(obj: io.flow.v0.models.LabelEvent) = {
          jsObjectLabelEvent(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelEventForm: play.api.libs.json.Reads[LabelEventForm] = {
      (
        (__ \ "label_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "description").readNullable[String] and
        (__ \ "address").readNullable[String]
      )(LabelEventForm.apply _)
    }

    def jsObjectLabelEventForm(obj: io.flow.v0.models.LabelEventForm) = {
      play.api.libs.json.Json.obj(
        "label_id" -> play.api.libs.json.JsString(obj.labelId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.address match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("address" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiLabelEventForm: play.api.libs.json.Writes[LabelEventForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelEventForm] {
        def writes(obj: io.flow.v0.models.LabelEventForm) = {
          jsObjectLabelEventForm(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelEventSummary: play.api.libs.json.Reads[LabelEventSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime]
      )(LabelEventSummary.apply _)
    }

    def jsObjectLabelEventSummary(obj: io.flow.v0.models.LabelEventSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp))
      )
    }

    implicit def jsonWritesApiLabelEventSummary: play.api.libs.json.Writes[LabelEventSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelEventSummary] {
        def writes(obj: io.flow.v0.models.LabelEventSummary) = {
          jsObjectLabelEventSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelEventVersion: play.api.libs.json.Reads[LabelEventVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "label_event").read[io.flow.v0.models.LabelEventSummary]
      )(LabelEventVersion.apply _)
    }

    def jsObjectLabelEventVersion(obj: io.flow.v0.models.LabelEventVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "label_event" -> jsObjectLabelEventSummary(obj.labelEvent)
      )
    }

    implicit def jsonWritesApiLabelEventVersion: play.api.libs.json.Writes[LabelEventVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelEventVersion] {
        def writes(obj: io.flow.v0.models.LabelEventVersion) = {
          jsObjectLabelEventVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelForm: play.api.libs.json.Reads[LabelForm] = {
      (
        (__ \ "tracking_id").read[String] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "carrier").read[String] and
        (__ \ "tracking_number").read[String] and
        (__ \ "delivery_estimate").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "description").readNullable[String] and
        (__ \ "timestamp").readNullable[_root_.org.joda.time.DateTime]
      )(LabelForm.apply _)
    }

    def jsObjectLabelForm(obj: io.flow.v0.models.LabelForm) = {
      play.api.libs.json.Json.obj(
        "tracking_id" -> play.api.libs.json.JsString(obj.trackingId),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "carrier" -> play.api.libs.json.JsString(obj.carrier),
        "tracking_number" -> play.api.libs.json.JsString(obj.trackingNumber)
      ) ++ (obj.deliveryEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivery_estimate" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.timestamp match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      })
    }

    implicit def jsonWritesApiLabelForm: play.api.libs.json.Writes[LabelForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelForm] {
        def writes(obj: io.flow.v0.models.LabelForm) = {
          jsObjectLabelForm(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelSummary: play.api.libs.json.Reads[LabelSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "tracking").read[io.flow.v0.models.TrackingSummary] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "carrier").read[String] and
        (__ \ "tracking_number").read[String]
      )(LabelSummary.apply _)
    }

    def jsObjectLabelSummary(obj: io.flow.v0.models.LabelSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "tracking" -> jsObjectTrackingSummary(obj.tracking),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "carrier" -> play.api.libs.json.JsString(obj.carrier),
        "tracking_number" -> play.api.libs.json.JsString(obj.trackingNumber)
      )
    }

    implicit def jsonWritesApiLabelSummary: play.api.libs.json.Writes[LabelSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelSummary] {
        def writes(obj: io.flow.v0.models.LabelSummary) = {
          jsObjectLabelSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiLabelVersion: play.api.libs.json.Reads[LabelVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "label").read[io.flow.v0.models.LabelSummary]
      )(LabelVersion.apply _)
    }

    def jsObjectLabelVersion(obj: io.flow.v0.models.LabelVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "label" -> jsObjectLabelSummary(obj.label)
      )
    }

    implicit def jsonWritesApiLabelVersion: play.api.libs.json.Writes[LabelVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LabelVersion] {
        def writes(obj: io.flow.v0.models.LabelVersion) = {
          jsObjectLabelVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiLanguage: play.api.libs.json.Reads[Language] = {
      (
        (__ \ "name").read[String] and
        (__ \ "iso_639_2").read[String]
      )(Language.apply _)
    }

    def jsObjectLanguage(obj: io.flow.v0.models.Language) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "iso_639_2" -> play.api.libs.json.JsString(obj.iso6392)
      )
    }

    implicit def jsonWritesApiLanguage: play.api.libs.json.Writes[Language] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Language] {
        def writes(obj: io.flow.v0.models.Language) = {
          jsObjectLanguage(obj)
        }
      }
    }

    implicit def jsonReadsApiLineItem: play.api.libs.json.Reads[LineItem] = {
      (
        (__ \ "number").read[String] and
        (__ \ "quantity").read[Long] and
        (__ \ "center").readNullable[String] and
        (__ \ "price").readNullable[io.flow.v0.models.Money] and
        (__ \ "discount").readNullable[io.flow.v0.models.Money]
      )(LineItem.apply _)
    }

    def jsObjectLineItem(obj: io.flow.v0.models.LineItem) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity)
      ) ++ (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> jsObjectMoney(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectMoney(x))
      })
    }

    implicit def jsonWritesApiLineItem: play.api.libs.json.Writes[LineItem] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LineItem] {
        def writes(obj: io.flow.v0.models.LineItem) = {
          jsObjectLineItem(obj)
        }
      }
    }

    implicit def jsonReadsApiLocal: play.api.libs.json.Reads[Local] = {
      (__ \ "prices").read[Seq[io.flow.v0.models.LocalizedPrice]].map { x => new Local(prices = x) }
    }

    def jsObjectLocal(obj: io.flow.v0.models.Local) = {
      play.api.libs.json.Json.obj(
        "prices" -> play.api.libs.json.Json.toJson(obj.prices)
      )
    }

    implicit def jsonWritesApiLocal: play.api.libs.json.Writes[Local] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Local] {
        def writes(obj: io.flow.v0.models.Local) = {
          jsObjectLocal(obj)
        }
      }
    }

    implicit def jsonReadsApiLocalizedItemDeleted: play.api.libs.json.Reads[LocalizedItemDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "catalog").read[String]
      )(LocalizedItemDeleted.apply _)
    }

    def jsObjectLocalizedItemDeleted(obj: io.flow.v0.models.LocalizedItemDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "catalog" -> play.api.libs.json.JsString(obj.catalog)
      )
    }

    implicit def jsonReadsApiLocalizedItemUpserted: play.api.libs.json.Reads[LocalizedItemUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "catalog").read[String] and
        (__ \ "locale").read[String] and
        (__ \ "name").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "price").read[Double] and
        (__ \ "categories").read[Seq[String]] and
        (__ \ "description").readNullable[String] and
        (__ \ "attributes").read[Map[String, String]] and
        (__ \ "dimensions").read[_root_.play.api.libs.json.JsObject] and
        (__ \ "images").read[Seq[_root_.play.api.libs.json.JsObject]] and
        (__ \ "local").read[_root_.play.api.libs.json.JsObject]
      )(LocalizedItemUpserted.apply _)
    }

    def jsObjectLocalizedItemUpserted(obj: io.flow.v0.models.LocalizedItemUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "catalog" -> play.api.libs.json.JsString(obj.catalog),
        "locale" -> play.api.libs.json.JsString(obj.locale),
        "name" -> play.api.libs.json.JsString(obj.name),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "price" -> play.api.libs.json.JsNumber(obj.price),
        "categories" -> play.api.libs.json.Json.toJson(obj.categories),
        "attributes" -> play.api.libs.json.Json.toJson(obj.attributes),
        "dimensions" -> obj.dimensions,
        "images" -> play.api.libs.json.Json.toJson(obj.images),
        "local" -> obj.local
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiLocalizedLineItem: play.api.libs.json.Reads[LocalizedLineItem] = {
      (
        (__ \ "number").read[String] and
        (__ \ "quantity").read[Long] and
        (__ \ "center").readNullable[String] and
        (__ \ "price").readNullable[io.flow.v0.models.Money] and
        (__ \ "discount").readNullable[io.flow.v0.models.Money] and
        (__ \ "local").read[io.flow.v0.models.Local]
      )(LocalizedLineItem.apply _)
    }

    def jsObjectLocalizedLineItem(obj: io.flow.v0.models.LocalizedLineItem) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "quantity" -> play.api.libs.json.JsNumber(obj.quantity),
        "local" -> jsObjectLocal(obj.local)
      ) ++ (obj.center match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("center" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.price match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("price" -> jsObjectMoney(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectMoney(x))
      })
    }

    implicit def jsonWritesApiLocalizedLineItem: play.api.libs.json.Writes[LocalizedLineItem] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LocalizedLineItem] {
        def writes(obj: io.flow.v0.models.LocalizedLineItem) = {
          jsObjectLocalizedLineItem(obj)
        }
      }
    }

    implicit def jsonReadsApiLocalizedPrice: play.api.libs.json.Reads[LocalizedPrice] = {
      (
        (__ \ "key").read[io.flow.v0.models.LocalizedPriceKey] and
        (__ \ "currency").read[String] and
        (__ \ "amount").read[Double] and
        (__ \ "label").read[String]
      )(LocalizedPrice.apply _)
    }

    def jsObjectLocalizedPrice(obj: io.flow.v0.models.LocalizedPrice) = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key.toString),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesApiLocalizedPrice: play.api.libs.json.Writes[LocalizedPrice] = {
      new play.api.libs.json.Writes[io.flow.v0.models.LocalizedPrice] {
        def writes(obj: io.flow.v0.models.LocalizedPrice) = {
          jsObjectLocalizedPrice(obj)
        }
      }
    }

    implicit def jsonReadsApiMargin: play.api.libs.json.Reads[Margin] = {
      (
        (__ \ "type").read[io.flow.v0.models.MarginType] and
        (__ \ "value").read[BigDecimal]
      )(Margin.apply _)
    }

    def jsObjectMargin(obj: io.flow.v0.models.Margin) = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesApiMargin: play.api.libs.json.Writes[Margin] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Margin] {
        def writes(obj: io.flow.v0.models.Margin) = {
          jsObjectMargin(obj)
        }
      }
    }

    implicit def jsonReadsApiMeasurement: play.api.libs.json.Reads[Measurement] = {
      (
        (__ \ "value").read[String] and
        (__ \ "units").read[io.flow.v0.models.UnitOfMeasurement]
      )(Measurement.apply _)
    }

    def jsObjectMeasurement(obj: io.flow.v0.models.Measurement) = {
      play.api.libs.json.Json.obj(
        "value" -> play.api.libs.json.JsString(obj.value),
        "units" -> play.api.libs.json.JsString(obj.units.toString)
      )
    }

    implicit def jsonWritesApiMeasurement: play.api.libs.json.Writes[Measurement] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Measurement] {
        def writes(obj: io.flow.v0.models.Measurement) = {
          jsObjectMeasurement(obj)
        }
      }
    }

    implicit def jsonReadsApiMembership: play.api.libs.json.Reads[Membership] = {
      (
        (__ \ "id").read[String] and
        (__ \ "organization").read[io.flow.v0.models.ExpandableOrganization] and
        (__ \ "user").read[io.flow.v0.models.ExpandableUser] and
        (__ \ "role").read[io.flow.v0.models.Role]
      )(Membership.apply _)
    }

    def jsObjectMembership(obj: io.flow.v0.models.Membership) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "organization" -> jsObjectExpandableOrganization(obj.organization),
        "user" -> jsObjectExpandableUser(obj.user),
        "role" -> play.api.libs.json.JsString(obj.role.toString)
      )
    }

    implicit def jsonWritesApiMembership: play.api.libs.json.Writes[Membership] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Membership] {
        def writes(obj: io.flow.v0.models.Membership) = {
          jsObjectMembership(obj)
        }
      }
    }

    implicit def jsonReadsApiMembershipForm: play.api.libs.json.Reads[MembershipForm] = {
      (
        (__ \ "organization").read[String] and
        (__ \ "user").read[String] and
        (__ \ "role").read[io.flow.v0.models.Role]
      )(MembershipForm.apply _)
    }

    def jsObjectMembershipForm(obj: io.flow.v0.models.MembershipForm) = {
      play.api.libs.json.Json.obj(
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "user" -> play.api.libs.json.JsString(obj.user),
        "role" -> play.api.libs.json.JsString(obj.role.toString)
      )
    }

    implicit def jsonWritesApiMembershipForm: play.api.libs.json.Writes[MembershipForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.MembershipForm] {
        def writes(obj: io.flow.v0.models.MembershipForm) = {
          jsObjectMembershipForm(obj)
        }
      }
    }

    implicit def jsonReadsApiMembershipPutForm: play.api.libs.json.Reads[MembershipPutForm] = {
      (__ \ "role").read[io.flow.v0.models.Role].map { x => new MembershipPutForm(role = x) }
    }

    def jsObjectMembershipPutForm(obj: io.flow.v0.models.MembershipPutForm) = {
      play.api.libs.json.Json.obj(
        "role" -> play.api.libs.json.JsString(obj.role.toString)
      )
    }

    implicit def jsonWritesApiMembershipPutForm: play.api.libs.json.Writes[MembershipPutForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.MembershipPutForm] {
        def writes(obj: io.flow.v0.models.MembershipPutForm) = {
          jsObjectMembershipPutForm(obj)
        }
      }
    }

    implicit def jsonReadsApiMembershipVersion: play.api.libs.json.Reads[MembershipVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "membership").read[io.flow.v0.models.Membership]
      )(MembershipVersion.apply _)
    }

    def jsObjectMembershipVersion(obj: io.flow.v0.models.MembershipVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "membership" -> jsObjectMembership(obj.membership)
      )
    }

    implicit def jsonWritesApiMembershipVersion: play.api.libs.json.Writes[MembershipVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.MembershipVersion] {
        def writes(obj: io.flow.v0.models.MembershipVersion) = {
          jsObjectMembershipVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiMerchantOfRecordAuthorizationForm: play.api.libs.json.Reads[MerchantOfRecordAuthorizationForm] = {
      (
        (__ \ "token").read[String] and
        (__ \ "order_number").read[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "cvv").readNullable[String] and
        (__ \ "attributes").readNullable[Map[String, String]] and
        (__ \ "ip").readNullable[String]
      )(MerchantOfRecordAuthorizationForm.apply _)
    }

    def jsObjectMerchantOfRecordAuthorizationForm(obj: io.flow.v0.models.MerchantOfRecordAuthorizationForm) = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "order_number" -> play.api.libs.json.JsString(obj.orderNumber)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.cvv match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cvv" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.attributes match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("attributes" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.ip match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ip" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiMoney: play.api.libs.json.Reads[Money] = {
      (
        (__ \ "amount").read[Double] and
        (__ \ "currency").read[String]
      )(Money.apply _)
    }

    def jsObjectMoney(obj: io.flow.v0.models.Money) = {
      play.api.libs.json.Json.obj(
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonWritesApiMoney: play.api.libs.json.Writes[Money] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Money] {
        def writes(obj: io.flow.v0.models.Money) = {
          jsObjectMoney(obj)
        }
      }
    }

    implicit def jsonReadsApiName: play.api.libs.json.Reads[Name] = {
      (
        (__ \ "first").readNullable[String] and
        (__ \ "last").readNullable[String]
      )(Name.apply _)
    }

    def jsObjectName(obj: io.flow.v0.models.Name) = {
      (obj.first match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("first" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.last match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("last" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiName: play.api.libs.json.Writes[Name] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Name] {
        def writes(obj: io.flow.v0.models.Name) = {
          jsObjectName(obj)
        }
      }
    }

    implicit def jsonReadsApiNameForm: play.api.libs.json.Reads[NameForm] = {
      (
        (__ \ "first").readNullable[String] and
        (__ \ "last").readNullable[String]
      )(NameForm.apply _)
    }

    def jsObjectNameForm(obj: io.flow.v0.models.NameForm) = {
      (obj.first match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("first" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.last match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("last" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiNameForm: play.api.libs.json.Writes[NameForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.NameForm] {
        def writes(obj: io.flow.v0.models.NameForm) = {
          jsObjectNameForm(obj)
        }
      }
    }

    implicit def jsonReadsApiOptions: play.api.libs.json.Reads[Options] = {
      (
        (__ \ "required").read[Boolean] and
        (__ \ "show_in_catalog").read[Boolean] and
        (__ \ "show_in_harmonization").read[Boolean]
      )(Options.apply _)
    }

    def jsObjectOptions(obj: io.flow.v0.models.Options) = {
      play.api.libs.json.Json.obj(
        "required" -> play.api.libs.json.JsBoolean(obj.required),
        "show_in_catalog" -> play.api.libs.json.JsBoolean(obj.showInCatalog),
        "show_in_harmonization" -> play.api.libs.json.JsBoolean(obj.showInHarmonization)
      )
    }

    implicit def jsonWritesApiOptions: play.api.libs.json.Writes[Options] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Options] {
        def writes(obj: io.flow.v0.models.Options) = {
          jsObjectOptions(obj)
        }
      }
    }

    implicit def jsonReadsApiOrder: play.api.libs.json.Reads[Order] = {
      (
        (__ \ "id").read[String] and
        (__ \ "number").read[String] and
        (__ \ "customer").read[io.flow.v0.models.Customer] and
        (__ \ "expires_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "items").read[Seq[io.flow.v0.models.LocalizedLineItem]] and
        (__ \ "destination").read[io.flow.v0.models.Address] and
        (__ \ "deliveries").read[Seq[io.flow.v0.models.Delivery]] and
        (__ \ "selections").read[Seq[String]] and
        (__ \ "prices").read[Seq[io.flow.v0.models.LocalizedPrice]] and
        (__ \ "total").read[io.flow.v0.models.LocalizedPrice]
      )(Order.apply _)
    }

    def jsObjectOrder(obj: io.flow.v0.models.Order) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "number" -> play.api.libs.json.JsString(obj.number),
        "customer" -> jsObjectCustomer(obj.customer),
        "expires_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.expiresAt)),
        "items" -> play.api.libs.json.Json.toJson(obj.items),
        "destination" -> jsObjectAddress(obj.destination),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections),
        "prices" -> play.api.libs.json.Json.toJson(obj.prices),
        "total" -> jsObjectLocalizedPrice(obj.total)
      )
    }

    implicit def jsonWritesApiOrder: play.api.libs.json.Writes[Order] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Order] {
        def writes(obj: io.flow.v0.models.Order) = {
          jsObjectOrder(obj)
        }
      }
    }

    implicit def jsonReadsApiOrderBooking: play.api.libs.json.Reads[OrderBooking] = {
      (
        (__ \ "id").read[String] and
        (__ \ "order").read[io.flow.v0.models.OrderReference] and
        (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      )(OrderBooking.apply _)
    }

    def jsObjectOrderBooking(obj: io.flow.v0.models.OrderBooking) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "order" -> jsObjectOrderReference(obj.order),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      )
    }

    implicit def jsonWritesApiOrderBooking: play.api.libs.json.Writes[OrderBooking] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrderBooking] {
        def writes(obj: io.flow.v0.models.OrderBooking) = {
          jsObjectOrderBooking(obj)
        }
      }
    }

    implicit def jsonReadsApiOrderForm: play.api.libs.json.Reads[OrderForm] = {
      (
        (__ \ "number").read[String] and
        (__ \ "customer").read[io.flow.v0.models.Customer] and
        (__ \ "destination").read[io.flow.v0.models.Address] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]] and
        (__ \ "discount").readNullable[io.flow.v0.models.Money]
      )(OrderForm.apply _)
    }

    def jsObjectOrderForm(obj: io.flow.v0.models.OrderForm) = {
      play.api.libs.json.Json.obj(
        "number" -> play.api.libs.json.JsString(obj.number),
        "customer" -> jsObjectCustomer(obj.customer),
        "destination" -> jsObjectAddress(obj.destination),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectMoney(x))
      })
    }

    implicit def jsonWritesApiOrderForm: play.api.libs.json.Writes[OrderForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrderForm] {
        def writes(obj: io.flow.v0.models.OrderForm) = {
          jsObjectOrderForm(obj)
        }
      }
    }

    implicit def jsonReadsApiOrderPutForm: play.api.libs.json.Reads[OrderPutForm] = {
      (
        (__ \ "customer").read[io.flow.v0.models.Customer] and
        (__ \ "destination").read[io.flow.v0.models.Address] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]] and
        (__ \ "selections").readNullable[Seq[String]] and
        (__ \ "discount").readNullable[io.flow.v0.models.Money]
      )(OrderPutForm.apply _)
    }

    def jsObjectOrderPutForm(obj: io.flow.v0.models.OrderPutForm) = {
      play.api.libs.json.Json.obj(
        "customer" -> jsObjectCustomer(obj.customer),
        "destination" -> jsObjectAddress(obj.destination),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      ) ++ (obj.selections match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("selections" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.discount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("discount" -> jsObjectMoney(x))
      })
    }

    implicit def jsonWritesApiOrderPutForm: play.api.libs.json.Writes[OrderPutForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrderPutForm] {
        def writes(obj: io.flow.v0.models.OrderPutForm) = {
          jsObjectOrderPutForm(obj)
        }
      }
    }

    implicit def jsonReadsApiOrderReference: play.api.libs.json.Reads[OrderReference] = {
      (__ \ "id").read[String].map { x => new OrderReference(id = x) }
    }

    def jsObjectOrderReference(obj: io.flow.v0.models.OrderReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiOrderReference: play.api.libs.json.Writes[OrderReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrderReference] {
        def writes(obj: io.flow.v0.models.OrderReference) = {
          jsObjectOrderReference(obj)
        }
      }
    }

    implicit def jsonReadsApiOrderVersion: play.api.libs.json.Reads[OrderVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "order").read[io.flow.v0.models.Order]
      )(OrderVersion.apply _)
    }

    def jsObjectOrderVersion(obj: io.flow.v0.models.OrderVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "order" -> jsObjectOrder(obj.order)
      )
    }

    implicit def jsonWritesApiOrderVersion: play.api.libs.json.Writes[OrderVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrderVersion] {
        def writes(obj: io.flow.v0.models.OrderVersion) = {
          jsObjectOrderVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganization: play.api.libs.json.Reads[Organization] = {
      (
        (__ \ "id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "environment").read[io.flow.v0.models.Environment] and
        (__ \ "parent").readNullable[io.flow.v0.models.OrganizationReference]
      )(Organization.apply _)
    }

    def jsObjectOrganization(obj: io.flow.v0.models.Organization) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "environment" -> play.api.libs.json.JsString(obj.environment.toString)
      ) ++ (obj.parent match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent" -> jsObjectOrganizationReference(x))
      })
    }

    implicit def jsonReadsApiOrganizationAuthorization: play.api.libs.json.Reads[OrganizationAuthorization] = {
      (
        (__ \ "role").read[io.flow.v0.models.Role] and
        (__ \ "environment").read[io.flow.v0.models.Environment]
      )(OrganizationAuthorization.apply _)
    }

    def jsObjectOrganizationAuthorization(obj: io.flow.v0.models.OrganizationAuthorization) = {
      play.api.libs.json.Json.obj(
        "role" -> play.api.libs.json.JsString(obj.role.toString),
        "environment" -> play.api.libs.json.JsString(obj.environment.toString)
      )
    }

    implicit def jsonWritesApiOrganizationAuthorization: play.api.libs.json.Writes[OrganizationAuthorization] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationAuthorization] {
        def writes(obj: io.flow.v0.models.OrganizationAuthorization) = {
          jsObjectOrganizationAuthorization(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationCurrencySetting: play.api.libs.json.Reads[OrganizationCurrencySetting] = {
      (
        (__ \ "id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "margin").read[BigDecimal]
      )(OrganizationCurrencySetting.apply _)
    }

    def jsObjectOrganizationCurrencySetting(obj: io.flow.v0.models.OrganizationCurrencySetting) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "margin" -> play.api.libs.json.JsNumber(obj.margin)
      )
    }

    implicit def jsonWritesApiOrganizationCurrencySetting: play.api.libs.json.Writes[OrganizationCurrencySetting] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationCurrencySetting] {
        def writes(obj: io.flow.v0.models.OrganizationCurrencySetting) = {
          jsObjectOrganizationCurrencySetting(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationCurrencySettingDeleted: play.api.libs.json.Reads[OrganizationCurrencySettingDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization_currency_setting_id").read[String]
      )(OrganizationCurrencySettingDeleted.apply _)
    }

    def jsObjectOrganizationCurrencySettingDeleted(obj: io.flow.v0.models.OrganizationCurrencySettingDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization_currency_setting_id" -> play.api.libs.json.JsString(obj.organizationCurrencySettingId)
      )
    }

    implicit def jsonReadsApiOrganizationCurrencySettingForm: play.api.libs.json.Reads[OrganizationCurrencySettingForm] = {
      (
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "margin").read[BigDecimal]
      )(OrganizationCurrencySettingForm.apply _)
    }

    def jsObjectOrganizationCurrencySettingForm(obj: io.flow.v0.models.OrganizationCurrencySettingForm) = {
      play.api.libs.json.Json.obj(
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "margin" -> play.api.libs.json.JsNumber(obj.margin)
      )
    }

    implicit def jsonWritesApiOrganizationCurrencySettingForm: play.api.libs.json.Writes[OrganizationCurrencySettingForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationCurrencySettingForm] {
        def writes(obj: io.flow.v0.models.OrganizationCurrencySettingForm) = {
          jsObjectOrganizationCurrencySettingForm(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationCurrencySettingUpserted: play.api.libs.json.Reads[OrganizationCurrencySettingUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization_currency_setting_id").read[String] and
        (__ \ "organization_id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "margin").read[BigDecimal]
      )(OrganizationCurrencySettingUpserted.apply _)
    }

    def jsObjectOrganizationCurrencySettingUpserted(obj: io.flow.v0.models.OrganizationCurrencySettingUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization_currency_setting_id" -> play.api.libs.json.JsString(obj.organizationCurrencySettingId),
        "organization_id" -> play.api.libs.json.JsString(obj.organizationId),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "margin" -> play.api.libs.json.JsNumber(obj.margin)
      )
    }

    implicit def jsonReadsApiOrganizationCurrencySettingVersion: play.api.libs.json.Reads[OrganizationCurrencySettingVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "organization_currency_setting").read[io.flow.v0.models.OrganizationCurrencySetting]
      )(OrganizationCurrencySettingVersion.apply _)
    }

    def jsObjectOrganizationCurrencySettingVersion(obj: io.flow.v0.models.OrganizationCurrencySettingVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "organization_currency_setting" -> jsObjectOrganizationCurrencySetting(obj.organizationCurrencySetting)
      )
    }

    implicit def jsonWritesApiOrganizationCurrencySettingVersion: play.api.libs.json.Writes[OrganizationCurrencySettingVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationCurrencySettingVersion] {
        def writes(obj: io.flow.v0.models.OrganizationCurrencySettingVersion) = {
          jsObjectOrganizationCurrencySettingVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationDeleted: play.api.libs.json.Reads[OrganizationDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "id").read[String]
      )(OrganizationDeleted.apply _)
    }

    def jsObjectOrganizationDeleted(obj: io.flow.v0.models.OrganizationDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsApiOrganizationForm: play.api.libs.json.Reads[OrganizationForm] = {
      (
        (__ \ "id").readNullable[String] and
        (__ \ "name").readNullable[String] and
        (__ \ "environment").read[io.flow.v0.models.Environment] and
        (__ \ "parent_id").readNullable[String]
      )(OrganizationForm.apply _)
    }

    def jsObjectOrganizationForm(obj: io.flow.v0.models.OrganizationForm) = {
      play.api.libs.json.Json.obj(
        "environment" -> play.api.libs.json.JsString(obj.environment.toString)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.parentId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiOrganizationForm: play.api.libs.json.Writes[OrganizationForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationForm] {
        def writes(obj: io.flow.v0.models.OrganizationForm) = {
          jsObjectOrganizationForm(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationPutForm: play.api.libs.json.Reads[OrganizationPutForm] = {
      (
        (__ \ "name").readNullable[String] and
        (__ \ "environment").readNullable[io.flow.v0.models.Environment] and
        (__ \ "parent_id").readNullable[String]
      )(OrganizationPutForm.apply _)
    }

    def jsObjectOrganizationPutForm(obj: io.flow.v0.models.OrganizationPutForm) = {
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.environment match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("environment" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.parentId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiOrganizationPutForm: play.api.libs.json.Writes[OrganizationPutForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationPutForm] {
        def writes(obj: io.flow.v0.models.OrganizationPutForm) = {
          jsObjectOrganizationPutForm(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationReference: play.api.libs.json.Reads[OrganizationReference] = {
      (__ \ "id").read[String].map { x => new OrganizationReference(id = x) }
    }

    def jsObjectOrganizationReference(obj: io.flow.v0.models.OrganizationReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsApiOrganizationSummary: play.api.libs.json.Reads[OrganizationSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "name").read[String]
      )(OrganizationSummary.apply _)
    }

    def jsObjectOrganizationSummary(obj: io.flow.v0.models.OrganizationSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesApiOrganizationSummary: play.api.libs.json.Writes[OrganizationSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationSummary] {
        def writes(obj: io.flow.v0.models.OrganizationSummary) = {
          jsObjectOrganizationSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiOrganizationUpserted: play.api.libs.json.Reads[OrganizationUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "environment").read[String] and
        (__ \ "currencies").read[Seq[String]] and
        (__ \ "parent_id").readNullable[String]
      )(OrganizationUpserted.apply _)
    }

    def jsObjectOrganizationUpserted(obj: io.flow.v0.models.OrganizationUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "environment" -> play.api.libs.json.JsString(obj.environment),
        "currencies" -> play.api.libs.json.Json.toJson(obj.currencies)
      ) ++ (obj.parentId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("parent_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiOrganizationVersion: play.api.libs.json.Reads[OrganizationVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "organization").read[io.flow.v0.models.Organization]
      )(OrganizationVersion.apply _)
    }

    def jsObjectOrganizationVersion(obj: io.flow.v0.models.OrganizationVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "organization" -> jsObjectOrganization(obj.organization)
      )
    }

    implicit def jsonWritesApiOrganizationVersion: play.api.libs.json.Writes[OrganizationVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.OrganizationVersion] {
        def writes(obj: io.flow.v0.models.OrganizationVersion) = {
          jsObjectOrganizationVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiPackaging: play.api.libs.json.Reads[Packaging] = {
      (
        (__ \ "dimensions").read[io.flow.v0.models.Dimensions] and
        (__ \ "name").readNullable[String] and
        (__ \ "number").readNullable[String]
      )(Packaging.apply _)
    }

    def jsObjectPackaging(obj: io.flow.v0.models.Packaging) = {
      play.api.libs.json.Json.obj(
        "dimensions" -> jsObjectDimensions(obj.dimensions)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.number match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("number" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiPackaging: play.api.libs.json.Writes[Packaging] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Packaging] {
        def writes(obj: io.flow.v0.models.Packaging) = {
          jsObjectPackaging(obj)
        }
      }
    }

    implicit def jsonReadsApiPasswordChangeForm: play.api.libs.json.Reads[PasswordChangeForm] = {
      (
        (__ \ "current").read[String] and
        (__ \ "new").read[String]
      )(PasswordChangeForm.apply _)
    }

    def jsObjectPasswordChangeForm(obj: io.flow.v0.models.PasswordChangeForm) = {
      play.api.libs.json.Json.obj(
        "current" -> play.api.libs.json.JsString(obj.current),
        "new" -> play.api.libs.json.JsString(obj.`new`)
      )
    }

    implicit def jsonWritesApiPasswordChangeForm: play.api.libs.json.Writes[PasswordChangeForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PasswordChangeForm] {
        def writes(obj: io.flow.v0.models.PasswordChangeForm) = {
          jsObjectPasswordChangeForm(obj)
        }
      }
    }

    implicit def jsonReadsApiPasswordResetForm: play.api.libs.json.Reads[PasswordResetForm] = {
      (
        (__ \ "token").read[String] and
        (__ \ "password").read[String]
      )(PasswordResetForm.apply _)
    }

    def jsObjectPasswordResetForm(obj: io.flow.v0.models.PasswordResetForm) = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token),
        "password" -> play.api.libs.json.JsString(obj.password)
      )
    }

    implicit def jsonWritesApiPasswordResetForm: play.api.libs.json.Writes[PasswordResetForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PasswordResetForm] {
        def writes(obj: io.flow.v0.models.PasswordResetForm) = {
          jsObjectPasswordResetForm(obj)
        }
      }
    }

    implicit def jsonReadsApiPasswordResetRequestForm: play.api.libs.json.Reads[PasswordResetRequestForm] = {
      (__ \ "email").read[String].map { x => new PasswordResetRequestForm(email = x) }
    }

    def jsObjectPasswordResetRequestForm(obj: io.flow.v0.models.PasswordResetRequestForm) = {
      play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.JsString(obj.email)
      )
    }

    implicit def jsonWritesApiPasswordResetRequestForm: play.api.libs.json.Writes[PasswordResetRequestForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PasswordResetRequestForm] {
        def writes(obj: io.flow.v0.models.PasswordResetRequestForm) = {
          jsObjectPasswordResetRequestForm(obj)
        }
      }
    }

    implicit def jsonReadsApiPercentMargin: play.api.libs.json.Reads[PercentMargin] = {
      (__ \ "percentage").read[Double].map { x => new PercentMargin(percentage = x) }
    }

    def jsObjectPercentMargin(obj: io.flow.v0.models.PercentMargin) = {
      play.api.libs.json.Json.obj(
        "percentage" -> play.api.libs.json.JsNumber(obj.percentage)
      )
    }

    implicit def jsonReadsApiPrice: play.api.libs.json.Reads[Price] = {
      (
        (__ \ "amount").read[Double] and
        (__ \ "currency").read[String] and
        (__ \ "label").read[String]
      )(Price.apply _)
    }

    def jsObjectPrice(obj: io.flow.v0.models.Price) = {
      play.api.libs.json.Json.obj(
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "label" -> play.api.libs.json.JsString(obj.label)
      )
    }

    implicit def jsonWritesApiPrice: play.api.libs.json.Writes[Price] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Price] {
        def writes(obj: io.flow.v0.models.Price) = {
          jsObjectPrice(obj)
        }
      }
    }

    implicit def jsonReadsApiPriceDetails: play.api.libs.json.Reads[PriceDetails] = {
      (
        (__ \ "base").read[io.flow.v0.models.Price] and
        (__ \ "local").read[io.flow.v0.models.Price] and
        (__ \ "currency_margin").read[io.flow.v0.models.Price] and
        (__ \ "margin").read[io.flow.v0.models.Price] and
        (__ \ "vat").read[io.flow.v0.models.Price] and
        (__ \ "duty").read[io.flow.v0.models.Price] and
        (__ \ "rounding").read[io.flow.v0.models.Price] and
        (__ \ "total").read[io.flow.v0.models.Price]
      )(PriceDetails.apply _)
    }

    def jsObjectPriceDetails(obj: io.flow.v0.models.PriceDetails) = {
      play.api.libs.json.Json.obj(
        "base" -> jsObjectPrice(obj.base),
        "local" -> jsObjectPrice(obj.local),
        "currency_margin" -> jsObjectPrice(obj.currencyMargin),
        "margin" -> jsObjectPrice(obj.margin),
        "vat" -> jsObjectPrice(obj.vat),
        "duty" -> jsObjectPrice(obj.duty),
        "rounding" -> jsObjectPrice(obj.rounding),
        "total" -> jsObjectPrice(obj.total)
      )
    }

    implicit def jsonWritesApiPriceDetails: play.api.libs.json.Writes[PriceDetails] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PriceDetails] {
        def writes(obj: io.flow.v0.models.PriceDetails) = {
          jsObjectPriceDetails(obj)
        }
      }
    }

    implicit def jsonReadsApiPriceEquation: play.api.libs.json.Reads[PriceEquation] = {
      (
        (__ \ "base_price").read[BigDecimal] and
        (__ \ "contracted_rate").read[BigDecimal] and
        (__ \ "rate").read[BigDecimal] and
        (__ \ "insurance").read[BigDecimal] and
        (__ \ "freight").read[BigDecimal] and
        (__ \ "margins").read[Seq[io.flow.v0.models.Margin]] and
        (__ \ "duty").readNullable[io.flow.v0.models.Duty] and
        (__ \ "tax").readNullable[io.flow.v0.models.Tax] and
        (__ \ "rounding").readNullable[io.flow.v0.models.Rounding]
      )(PriceEquation.apply _)
    }

    def jsObjectPriceEquation(obj: io.flow.v0.models.PriceEquation) = {
      play.api.libs.json.Json.obj(
        "base_price" -> play.api.libs.json.JsNumber(obj.basePrice),
        "contracted_rate" -> play.api.libs.json.JsNumber(obj.contractedRate),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "insurance" -> play.api.libs.json.JsNumber(obj.insurance),
        "freight" -> play.api.libs.json.JsNumber(obj.freight),
        "margins" -> play.api.libs.json.Json.toJson(obj.margins)
      ) ++ (obj.duty match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duty" -> jsObjectDuty(x))
      }) ++
      (obj.tax match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("tax" -> jsObjectTax(x))
      }) ++
      (obj.rounding match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rounding" -> jsObjectRounding(x))
      })
    }

    implicit def jsonWritesApiPriceEquation: play.api.libs.json.Writes[PriceEquation] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PriceEquation] {
        def writes(obj: io.flow.v0.models.PriceEquation) = {
          jsObjectPriceEquation(obj)
        }
      }
    }

    implicit def jsonReadsApiPriceForm: play.api.libs.json.Reads[PriceForm] = {
      (
        (__ \ "amount").read[Double] and
        (__ \ "currency").read[String]
      )(PriceForm.apply _)
    }

    def jsObjectPriceForm(obj: io.flow.v0.models.PriceForm) = {
      play.api.libs.json.Json.obj(
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonWritesApiPriceForm: play.api.libs.json.Writes[PriceForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PriceForm] {
        def writes(obj: io.flow.v0.models.PriceForm) = {
          jsObjectPriceForm(obj)
        }
      }
    }

    implicit def jsonReadsApiPricing: play.api.libs.json.Reads[Pricing] = {
      (
        (__ \ "vat").read[io.flow.v0.models.PricingLevySetting] and
        (__ \ "duty").read[io.flow.v0.models.PricingLevySetting] and
        (__ \ "rounding").readNullable[io.flow.v0.models.Rounding]
      )(Pricing.apply _)
    }

    def jsObjectPricing(obj: io.flow.v0.models.Pricing) = {
      play.api.libs.json.Json.obj(
        "vat" -> play.api.libs.json.JsString(obj.vat.toString),
        "duty" -> play.api.libs.json.JsString(obj.duty.toString)
      ) ++ (obj.rounding match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("rounding" -> jsObjectRounding(x))
      })
    }

    implicit def jsonWritesApiPricing: play.api.libs.json.Writes[Pricing] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Pricing] {
        def writes(obj: io.flow.v0.models.Pricing) = {
          jsObjectPricing(obj)
        }
      }
    }

    implicit def jsonReadsApiPublicKey: play.api.libs.json.Reads[PublicKey] = {
      (__ \ "id").read[String].map { x => new PublicKey(id = x) }
    }

    def jsObjectPublicKey(obj: io.flow.v0.models.PublicKey) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiPublicKey: play.api.libs.json.Writes[PublicKey] = {
      new play.api.libs.json.Writes[io.flow.v0.models.PublicKey] {
        def writes(obj: io.flow.v0.models.PublicKey) = {
          jsObjectPublicKey(obj)
        }
      }
    }

    implicit def jsonReadsApiQuery: play.api.libs.json.Reads[Query] = {
      (
        (__ \ "id").read[String] and
        (__ \ "q").read[String] and
        (__ \ "type").read[io.flow.v0.models.QueryType]
      )(Query.apply _)
    }

    def jsObjectQuery(obj: io.flow.v0.models.Query) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "q" -> play.api.libs.json.JsString(obj.q),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesApiQuery: play.api.libs.json.Writes[Query] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Query] {
        def writes(obj: io.flow.v0.models.Query) = {
          jsObjectQuery(obj)
        }
      }
    }

    implicit def jsonReadsApiQueryForm: play.api.libs.json.Reads[QueryForm] = {
      (
        (__ \ "q").read[String] and
        (__ \ "type").read[io.flow.v0.models.QueryType]
      )(QueryForm.apply _)
    }

    def jsObjectQueryForm(obj: io.flow.v0.models.QueryForm) = {
      play.api.libs.json.Json.obj(
        "q" -> play.api.libs.json.JsString(obj.q),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      )
    }

    implicit def jsonWritesApiQueryForm: play.api.libs.json.Writes[QueryForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.QueryForm] {
        def writes(obj: io.flow.v0.models.QueryForm) = {
          jsObjectQueryForm(obj)
        }
      }
    }

    implicit def jsonReadsApiQuote: play.api.libs.json.Reads[Quote] = {
      (
        (__ \ "id").read[String] and
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "deliveries").read[Seq[io.flow.v0.models.Delivery]] and
        (__ \ "selections").read[Seq[io.flow.v0.models.DeliveryOptionReference]]
      )(Quote.apply _)
    }

    def jsObjectQuote(obj: io.flow.v0.models.Quote) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "destination" -> jsObjectShippingAddress(obj.destination),
        "deliveries" -> play.api.libs.json.Json.toJson(obj.deliveries),
        "selections" -> play.api.libs.json.Json.toJson(obj.selections)
      )
    }

    implicit def jsonWritesApiQuote: play.api.libs.json.Writes[Quote] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Quote] {
        def writes(obj: io.flow.v0.models.Quote) = {
          jsObjectQuote(obj)
        }
      }
    }

    implicit def jsonReadsApiQuoteForm: play.api.libs.json.Reads[QuoteForm] = {
      (
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "experience").read[String] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]]
      )(QuoteForm.apply _)
    }

    def jsObjectQuoteForm(obj: io.flow.v0.models.QuoteForm) = {
      play.api.libs.json.Json.obj(
        "destination" -> jsObjectShippingAddress(obj.destination),
        "experience" -> play.api.libs.json.JsString(obj.experience),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesApiQuoteForm: play.api.libs.json.Writes[QuoteForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.QuoteForm] {
        def writes(obj: io.flow.v0.models.QuoteForm) = {
          jsObjectQuoteForm(obj)
        }
      }
    }

    implicit def jsonReadsApiQuoteSummary: play.api.libs.json.Reads[QuoteSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress]
      )(QuoteSummary.apply _)
    }

    def jsObjectQuoteSummary(obj: io.flow.v0.models.QuoteSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "destination" -> jsObjectShippingAddress(obj.destination)
      )
    }

    implicit def jsonWritesApiQuoteSummary: play.api.libs.json.Writes[QuoteSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.QuoteSummary] {
        def writes(obj: io.flow.v0.models.QuoteSummary) = {
          jsObjectQuoteSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiQuoteVersion: play.api.libs.json.Reads[QuoteVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "quote").read[io.flow.v0.models.QuoteSummary]
      )(QuoteVersion.apply _)
    }

    def jsObjectQuoteVersion(obj: io.flow.v0.models.QuoteVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "quote" -> jsObjectQuoteSummary(obj.quote)
      )
    }

    implicit def jsonWritesApiQuoteVersion: play.api.libs.json.Writes[QuoteVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.QuoteVersion] {
        def writes(obj: io.flow.v0.models.QuoteVersion) = {
          jsObjectQuoteVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiRate: play.api.libs.json.Reads[Rate] = {
      (
        (__ \ "id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "value").read[BigDecimal]
      )(Rate.apply _)
    }

    def jsObjectRate(obj: io.flow.v0.models.Rate) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt)),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesApiRate: play.api.libs.json.Writes[Rate] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Rate] {
        def writes(obj: io.flow.v0.models.Rate) = {
          jsObjectRate(obj)
        }
      }
    }

    implicit def jsonReadsApiRateDeleted: play.api.libs.json.Reads[RateDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "rate_id").read[String]
      )(RateDeleted.apply _)
    }

    def jsObjectRateDeleted(obj: io.flow.v0.models.RateDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "rate_id" -> play.api.libs.json.JsString(obj.rateId)
      )
    }

    implicit def jsonReadsApiRateForm: play.api.libs.json.Reads[RateForm] = {
      (
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime]
      )(RateForm.apply _)
    }

    def jsObjectRateForm(obj: io.flow.v0.models.RateForm) = {
      play.api.libs.json.Json.obj(
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt))
      )
    }

    implicit def jsonWritesApiRateForm: play.api.libs.json.Writes[RateForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RateForm] {
        def writes(obj: io.flow.v0.models.RateForm) = {
          jsObjectRateForm(obj)
        }
      }
    }

    implicit def jsonReadsApiRateUpserted: play.api.libs.json.Reads[RateUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "rate_id").read[String] and
        (__ \ "organization_id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "value").read[BigDecimal]
      )(RateUpserted.apply _)
    }

    def jsObjectRateUpserted(obj: io.flow.v0.models.RateUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "rate_id" -> play.api.libs.json.JsString(obj.rateId),
        "organization_id" -> play.api.libs.json.JsString(obj.organizationId),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt)),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonReadsApiRateVersion: play.api.libs.json.Reads[RateVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "rate").read[io.flow.v0.models.Rate]
      )(RateVersion.apply _)
    }

    def jsObjectRateVersion(obj: io.flow.v0.models.RateVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "rate" -> jsObjectRate(obj.rate)
      )
    }

    implicit def jsonWritesApiRateVersion: play.api.libs.json.Writes[RateVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RateVersion] {
        def writes(obj: io.flow.v0.models.RateVersion) = {
          jsObjectRateVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiRefund: play.api.libs.json.Reads[Refund] = {
      (
        (__ \ "id").read[String] and
        (__ \ "key").read[String] and
        (__ \ "capture").read[io.flow.v0.models.Capture] and
        (__ \ "amount").read[BigDecimal] and
        (__ \ "currency").read[String]
      )(Refund.apply _)
    }

    def jsObjectRefund(obj: io.flow.v0.models.Refund) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "key" -> play.api.libs.json.JsString(obj.key),
        "capture" -> jsObjectCapture(obj.capture),
        "amount" -> play.api.libs.json.JsNumber(obj.amount),
        "currency" -> play.api.libs.json.JsString(obj.currency)
      )
    }

    implicit def jsonWritesApiRefund: play.api.libs.json.Writes[Refund] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Refund] {
        def writes(obj: io.flow.v0.models.Refund) = {
          jsObjectRefund(obj)
        }
      }
    }

    implicit def jsonReadsApiRefundForm: play.api.libs.json.Reads[RefundForm] = {
      (
        (__ \ "capture_id").read[String] and
        (__ \ "key").readNullable[String] and
        (__ \ "amount").readNullable[BigDecimal] and
        (__ \ "currency").readNullable[String]
      )(RefundForm.apply _)
    }

    def jsObjectRefundForm(obj: io.flow.v0.models.RefundForm) = {
      play.api.libs.json.Json.obj(
        "capture_id" -> play.api.libs.json.JsString(obj.captureId)
      ) ++ (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.amount match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("amount" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.currency match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("currency" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiRefundForm: play.api.libs.json.Writes[RefundForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RefundForm] {
        def writes(obj: io.flow.v0.models.RefundForm) = {
          jsObjectRefundForm(obj)
        }
      }
    }

    implicit def jsonReadsApiRefundVersion: play.api.libs.json.Reads[RefundVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "refund").read[io.flow.v0.models.Refund]
      )(RefundVersion.apply _)
    }

    def jsObjectRefundVersion(obj: io.flow.v0.models.RefundVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "refund" -> jsObjectRefund(obj.refund)
      )
    }

    implicit def jsonWritesApiRefundVersion: play.api.libs.json.Writes[RefundVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RefundVersion] {
        def writes(obj: io.flow.v0.models.RefundVersion) = {
          jsObjectRefundVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiRegion: play.api.libs.json.Reads[Region] = {
      (
        (__ \ "id").read[String] and
        (__ \ "name").read[String] and
        (__ \ "countries").read[Seq[String]] and
        (__ \ "currencies").read[Seq[String]] and
        (__ \ "languages").read[Seq[String]] and
        (__ \ "measurement_systems").read[Seq[String]] and
        (__ \ "timezones").read[Seq[String]]
      )(Region.apply _)
    }

    def jsObjectRegion(obj: io.flow.v0.models.Region) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name),
        "countries" -> play.api.libs.json.Json.toJson(obj.countries),
        "currencies" -> play.api.libs.json.Json.toJson(obj.currencies),
        "languages" -> play.api.libs.json.Json.toJson(obj.languages),
        "measurement_systems" -> play.api.libs.json.Json.toJson(obj.measurementSystems),
        "timezones" -> play.api.libs.json.Json.toJson(obj.timezones)
      )
    }

    implicit def jsonWritesApiRegion: play.api.libs.json.Writes[Region] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Region] {
        def writes(obj: io.flow.v0.models.Region) = {
          jsObjectRegion(obj)
        }
      }
    }

    implicit def jsonReadsApiRegionReference: play.api.libs.json.Reads[RegionReference] = {
      (__ \ "id").read[String].map { x => new RegionReference(id = x) }
    }

    def jsObjectRegionReference(obj: io.flow.v0.models.RegionReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiRegionReference: play.api.libs.json.Writes[RegionReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.RegionReference] {
        def writes(obj: io.flow.v0.models.RegionReference) = {
          jsObjectRegionReference(obj)
        }
      }
    }

    implicit def jsonReadsApiRounding: play.api.libs.json.Reads[Rounding] = {
      (
        (__ \ "type").read[io.flow.v0.models.RoundingType] and
        (__ \ "method").read[io.flow.v0.models.RoundingMethod] and
        (__ \ "value").read[BigDecimal]
      )(Rounding.apply _)
    }

    def jsObjectRounding(obj: io.flow.v0.models.Rounding) = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "method" -> play.api.libs.json.JsString(obj.method.toString),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesApiRounding: play.api.libs.json.Writes[Rounding] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Rounding] {
        def writes(obj: io.flow.v0.models.Rounding) = {
          jsObjectRounding(obj)
        }
      }
    }

    implicit def jsonReadsApiSchedule: play.api.libs.json.Reads[Schedule] = {
      (
        (__ \ "calendar").readNullable[io.flow.v0.models.Calendar] and
        (__ \ "holiday").read[io.flow.v0.models.HolidayCalendar] and
        (__ \ "exception").read[Seq[io.flow.v0.models.Exception]] and
        (__ \ "cutoff").readNullable[String]
      )(Schedule.apply _)
    }

    def jsObjectSchedule(obj: io.flow.v0.models.Schedule) = {
      play.api.libs.json.Json.obj(
        "holiday" -> play.api.libs.json.JsString(obj.holiday.toString),
        "exception" -> play.api.libs.json.Json.toJson(obj.exception)
      ) ++ (obj.calendar match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("calendar" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.cutoff match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("cutoff" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiSchedule: play.api.libs.json.Writes[Schedule] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Schedule] {
        def writes(obj: io.flow.v0.models.Schedule) = {
          jsObjectSchedule(obj)
        }
      }
    }

    implicit def jsonReadsApiService: play.api.libs.json.Reads[Service] = {
      (
        (__ \ "id").read[String] and
        (__ \ "carrier").read[io.flow.v0.models.Carrier] and
        (__ \ "name").read[String]
      )(Service.apply _)
    }

    def jsObjectService(obj: io.flow.v0.models.Service) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "carrier" -> jsObjectCarrier(obj.carrier),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesApiService: play.api.libs.json.Writes[Service] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Service] {
        def writes(obj: io.flow.v0.models.Service) = {
          jsObjectService(obj)
        }
      }
    }

    implicit def jsonReadsApiServiceReference: play.api.libs.json.Reads[ServiceReference] = {
      (__ \ "id").read[String].map { x => new ServiceReference(id = x) }
    }

    def jsObjectServiceReference(obj: io.flow.v0.models.ServiceReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiServiceReference: play.api.libs.json.Writes[ServiceReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ServiceReference] {
        def writes(obj: io.flow.v0.models.ServiceReference) = {
          jsObjectServiceReference(obj)
        }
      }
    }

    implicit def jsonReadsApiServiceSummary: play.api.libs.json.Reads[ServiceSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "carrier").read[io.flow.v0.models.CarrierReference] and
        (__ \ "name").read[String]
      )(ServiceSummary.apply _)
    }

    def jsObjectServiceSummary(obj: io.flow.v0.models.ServiceSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "carrier" -> jsObjectCarrierReference(obj.carrier),
        "name" -> play.api.libs.json.JsString(obj.name)
      )
    }

    implicit def jsonWritesApiServiceSummary: play.api.libs.json.Writes[ServiceSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ServiceSummary] {
        def writes(obj: io.flow.v0.models.ServiceSummary) = {
          jsObjectServiceSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiShippingAddress: play.api.libs.json.Reads[ShippingAddress] = {
      (
        (__ \ "contact").read[io.flow.v0.models.Contact] and
        (__ \ "location").read[io.flow.v0.models.Address]
      )(ShippingAddress.apply _)
    }

    def jsObjectShippingAddress(obj: io.flow.v0.models.ShippingAddress) = {
      play.api.libs.json.Json.obj(
        "contact" -> jsObjectContact(obj.contact),
        "location" -> jsObjectAddress(obj.location)
      )
    }

    implicit def jsonWritesApiShippingAddress: play.api.libs.json.Writes[ShippingAddress] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ShippingAddress] {
        def writes(obj: io.flow.v0.models.ShippingAddress) = {
          jsObjectShippingAddress(obj)
        }
      }
    }

    implicit def jsonReadsApiShippingLabel: play.api.libs.json.Reads[ShippingLabel] = {
      (
        (__ \ "id").read[String] and
        (__ \ "carrier_tracking_number").read[String] and
        (__ \ "commercial_invoice").read[String] and
        (__ \ "data").read[String] and
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "flow_tracking_number").read[String] and
        (__ \ "origin").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "service").read[io.flow.v0.models.ServiceSummary] and
        (__ \ "window").read[io.flow.v0.models.DatetimeRange] and
        (__ \ "pdf").readNullable[String] and
        (__ \ "png").readNullable[String]
      )(ShippingLabel.apply _)
    }

    def jsObjectShippingLabel(obj: io.flow.v0.models.ShippingLabel) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "carrier_tracking_number" -> play.api.libs.json.JsString(obj.carrierTrackingNumber),
        "commercial_invoice" -> play.api.libs.json.JsString(obj.commercialInvoice),
        "data" -> play.api.libs.json.JsString(obj.data),
        "destination" -> jsObjectShippingAddress(obj.destination),
        "flow_tracking_number" -> play.api.libs.json.JsString(obj.flowTrackingNumber),
        "origin" -> jsObjectShippingAddress(obj.origin),
        "service" -> jsObjectServiceSummary(obj.service),
        "window" -> jsObjectDatetimeRange(obj.window)
      ) ++ (obj.pdf match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("pdf" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.png match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("png" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiShippingLabel: play.api.libs.json.Writes[ShippingLabel] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ShippingLabel] {
        def writes(obj: io.flow.v0.models.ShippingLabel) = {
          jsObjectShippingLabel(obj)
        }
      }
    }

    implicit def jsonReadsApiShippingLabelForm: play.api.libs.json.Reads[ShippingLabelForm] = {
      (
        (__ \ "service").read[String] and
        (__ \ "delivered_duty").read[io.flow.v0.models.DeliveredDuty] and
        (__ \ "destination").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "origin").read[io.flow.v0.models.ShippingAddress] and
        (__ \ "packages").read[Seq[io.flow.v0.models.ShippingLabelPackage]] and
        (__ \ "insurance").readNullable[io.flow.v0.models.Price]
      )(ShippingLabelForm.apply _)
    }

    def jsObjectShippingLabelForm(obj: io.flow.v0.models.ShippingLabelForm) = {
      play.api.libs.json.Json.obj(
        "service" -> play.api.libs.json.JsString(obj.service),
        "delivered_duty" -> play.api.libs.json.JsString(obj.deliveredDuty.toString),
        "destination" -> jsObjectShippingAddress(obj.destination),
        "origin" -> jsObjectShippingAddress(obj.origin),
        "packages" -> play.api.libs.json.Json.toJson(obj.packages)
      ) ++ (obj.insurance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("insurance" -> jsObjectPrice(x))
      })
    }

    implicit def jsonWritesApiShippingLabelForm: play.api.libs.json.Writes[ShippingLabelForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ShippingLabelForm] {
        def writes(obj: io.flow.v0.models.ShippingLabelForm) = {
          jsObjectShippingLabelForm(obj)
        }
      }
    }

    implicit def jsonReadsApiShippingLabelPackage: play.api.libs.json.Reads[ShippingLabelPackage] = {
      (
        (__ \ "dimensions").read[io.flow.v0.models.Dimension] and
        (__ \ "items").read[Seq[io.flow.v0.models.LineItem]]
      )(ShippingLabelPackage.apply _)
    }

    def jsObjectShippingLabelPackage(obj: io.flow.v0.models.ShippingLabelPackage) = {
      play.api.libs.json.Json.obj(
        "dimensions" -> jsObjectDimension(obj.dimensions),
        "items" -> play.api.libs.json.Json.toJson(obj.items)
      )
    }

    implicit def jsonWritesApiShippingLabelPackage: play.api.libs.json.Writes[ShippingLabelPackage] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ShippingLabelPackage] {
        def writes(obj: io.flow.v0.models.ShippingLabelPackage) = {
          jsObjectShippingLabelPackage(obj)
        }
      }
    }

    implicit def jsonReadsApiShippingLabelVersion: play.api.libs.json.Reads[ShippingLabelVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "shipping_label").read[io.flow.v0.models.ShippingLabel]
      )(ShippingLabelVersion.apply _)
    }

    def jsObjectShippingLabelVersion(obj: io.flow.v0.models.ShippingLabelVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "shipping_label" -> jsObjectShippingLabel(obj.shippingLabel)
      )
    }

    implicit def jsonWritesApiShippingLabelVersion: play.api.libs.json.Writes[ShippingLabelVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ShippingLabelVersion] {
        def writes(obj: io.flow.v0.models.ShippingLabelVersion) = {
          jsObjectShippingLabelVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiSpotRate: play.api.libs.json.Reads[SpotRate] = {
      (
        (__ \ "id").read[String] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "value").read[BigDecimal]
      )(SpotRate.apply _)
    }

    def jsObjectSpotRate(obj: io.flow.v0.models.SpotRate) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt)),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesApiSpotRate: play.api.libs.json.Writes[SpotRate] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SpotRate] {
        def writes(obj: io.flow.v0.models.SpotRate) = {
          jsObjectSpotRate(obj)
        }
      }
    }

    implicit def jsonReadsApiSpotRateDeleted: play.api.libs.json.Reads[SpotRateDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "spot_rate_id").read[String]
      )(SpotRateDeleted.apply _)
    }

    def jsObjectSpotRateDeleted(obj: io.flow.v0.models.SpotRateDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "spot_rate_id" -> play.api.libs.json.JsString(obj.spotRateId)
      )
    }

    implicit def jsonReadsApiSpotRateForm: play.api.libs.json.Reads[SpotRateForm] = {
      (
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "value").read[BigDecimal]
      )(SpotRateForm.apply _)
    }

    def jsObjectSpotRateForm(obj: io.flow.v0.models.SpotRateForm) = {
      play.api.libs.json.Json.obj(
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt)),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "value" -> play.api.libs.json.JsNumber(obj.value)
      )
    }

    implicit def jsonWritesApiSpotRateForm: play.api.libs.json.Writes[SpotRateForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SpotRateForm] {
        def writes(obj: io.flow.v0.models.SpotRateForm) = {
          jsObjectSpotRateForm(obj)
        }
      }
    }

    implicit def jsonReadsApiSpotRateUpserted: play.api.libs.json.Reads[SpotRateUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "spot_rate_id").read[String] and
        (__ \ "base").read[String] and
        (__ \ "target").read[String] and
        (__ \ "value").read[BigDecimal] and
        (__ \ "effective_at").read[_root_.org.joda.time.DateTime]
      )(SpotRateUpserted.apply _)
    }

    def jsObjectSpotRateUpserted(obj: io.flow.v0.models.SpotRateUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "spot_rate_id" -> play.api.libs.json.JsString(obj.spotRateId),
        "base" -> play.api.libs.json.JsString(obj.base),
        "target" -> play.api.libs.json.JsString(obj.target),
        "value" -> play.api.libs.json.JsNumber(obj.value),
        "effective_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.effectiveAt))
      )
    }

    implicit def jsonReadsApiSpotRateVersion: play.api.libs.json.Reads[SpotRateVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "spot_rate").read[io.flow.v0.models.SpotRate]
      )(SpotRateVersion.apply _)
    }

    def jsObjectSpotRateVersion(obj: io.flow.v0.models.SpotRateVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "spot_rate" -> jsObjectSpotRate(obj.spotRate)
      )
    }

    implicit def jsonWritesApiSpotRateVersion: play.api.libs.json.Writes[SpotRateVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SpotRateVersion] {
        def writes(obj: io.flow.v0.models.SpotRateVersion) = {
          jsObjectSpotRateVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalog: play.api.libs.json.Reads[Subcatalog] = {
      (
        (__ \ "id").read[String] and
        (__ \ "catalog").read[io.flow.v0.models.Catalog] and
        (__ \ "settings").read[io.flow.v0.models.SubcatalogSettings]
      )(Subcatalog.apply _)
    }

    def jsObjectSubcatalog(obj: io.flow.v0.models.Subcatalog) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "catalog" -> jsObjectCatalog(obj.catalog),
        "settings" -> jsObjectSubcatalogSettings(obj.settings)
      )
    }

    implicit def jsonReadsApiSubcatalogDeleted: play.api.libs.json.Reads[SubcatalogDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "catalog").read[String] and
        (__ \ "subcatalog_id").read[String]
      )(SubcatalogDeleted.apply _)
    }

    def jsObjectSubcatalogDeleted(obj: io.flow.v0.models.SubcatalogDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "catalog" -> play.api.libs.json.JsString(obj.catalog),
        "subcatalog_id" -> play.api.libs.json.JsString(obj.subcatalogId)
      )
    }

    implicit def jsonReadsApiSubcatalogForm: play.api.libs.json.Reads[SubcatalogForm] = {
      (__ \ "settings").readNullable[io.flow.v0.models.SubcatalogSettingsForm].map { x => new SubcatalogForm(settings = x) }
    }

    def jsObjectSubcatalogForm(obj: io.flow.v0.models.SubcatalogForm) = {
      (obj.settings match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("settings" -> jsObjectSubcatalogSettingsForm(x))
      })
    }

    implicit def jsonWritesApiSubcatalogForm: play.api.libs.json.Writes[SubcatalogForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogForm] {
        def writes(obj: io.flow.v0.models.SubcatalogForm) = {
          jsObjectSubcatalogForm(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogFunction: play.api.libs.json.Reads[SubcatalogFunction] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item_function").read[io.flow.v0.models.ItemFunction] and
        (__ \ "q").read[String] and
        (__ \ "position").read[Long]
      )(SubcatalogFunction.apply _)
    }

    def jsObjectSubcatalogFunction(obj: io.flow.v0.models.SubcatalogFunction) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item_function" -> jsObjectItemFunction(obj.itemFunction),
        "q" -> play.api.libs.json.JsString(obj.q),
        "position" -> play.api.libs.json.JsNumber(obj.position)
      )
    }

    implicit def jsonWritesApiSubcatalogFunction: play.api.libs.json.Writes[SubcatalogFunction] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogFunction] {
        def writes(obj: io.flow.v0.models.SubcatalogFunction) = {
          jsObjectSubcatalogFunction(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogFunctionForm: play.api.libs.json.Reads[SubcatalogFunctionForm] = {
      (
        (__ \ "item_function_id").read[String] and
        (__ \ "q").readNullable[String] and
        (__ \ "position").readNullable[Long]
      )(SubcatalogFunctionForm.apply _)
    }

    def jsObjectSubcatalogFunctionForm(obj: io.flow.v0.models.SubcatalogFunctionForm) = {
      play.api.libs.json.Json.obj(
        "item_function_id" -> play.api.libs.json.JsString(obj.itemFunctionId)
      ) ++ (obj.q match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("q" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesApiSubcatalogFunctionForm: play.api.libs.json.Writes[SubcatalogFunctionForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogFunctionForm] {
        def writes(obj: io.flow.v0.models.SubcatalogFunctionForm) = {
          jsObjectSubcatalogFunctionForm(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogFunctionVersion: play.api.libs.json.Reads[SubcatalogFunctionVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "subcatalog_function").read[io.flow.v0.models.SubcatalogFunction]
      )(SubcatalogFunctionVersion.apply _)
    }

    def jsObjectSubcatalogFunctionVersion(obj: io.flow.v0.models.SubcatalogFunctionVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog_function" -> jsObjectSubcatalogFunction(obj.subcatalogFunction)
      )
    }

    implicit def jsonWritesApiSubcatalogFunctionVersion: play.api.libs.json.Writes[SubcatalogFunctionVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogFunctionVersion] {
        def writes(obj: io.flow.v0.models.SubcatalogFunctionVersion) = {
          jsObjectSubcatalogFunctionVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogItem: play.api.libs.json.Reads[SubcatalogItem] = {
      (
        (__ \ "id").read[String] and
        (__ \ "item").read[io.flow.v0.models.Item] and
        (__ \ "item_function").readNullable[io.flow.v0.models.ExpandableItemFunction] and
        (__ \ "item_status").read[io.flow.v0.models.SubcatalogItemStatus]
      )(SubcatalogItem.apply _)
    }

    def jsObjectSubcatalogItem(obj: io.flow.v0.models.SubcatalogItem) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "item" -> jsObjectItem(obj.item),
        "item_status" -> play.api.libs.json.JsString(obj.itemStatus.toString)
      ) ++ (obj.itemFunction match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("item_function" -> jsObjectExpandableItemFunction(x))
      })
    }

    implicit def jsonWritesApiSubcatalogItem: play.api.libs.json.Writes[SubcatalogItem] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogItem] {
        def writes(obj: io.flow.v0.models.SubcatalogItem) = {
          jsObjectSubcatalogItem(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogItemDeleted: play.api.libs.json.Reads[SubcatalogItemDeleted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "catalog").read[String] and
        (__ \ "subcatalog_id").read[String]
      )(SubcatalogItemDeleted.apply _)
    }

    def jsObjectSubcatalogItemDeleted(obj: io.flow.v0.models.SubcatalogItemDeleted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "catalog" -> play.api.libs.json.JsString(obj.catalog),
        "subcatalog_id" -> play.api.libs.json.JsString(obj.subcatalogId)
      )
    }

    implicit def jsonReadsApiSubcatalogItemUpserted: play.api.libs.json.Reads[SubcatalogItemUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "number").read[String] and
        (__ \ "catalog").read[String] and
        (__ \ "subcatalog_id").read[String] and
        (__ \ "status").read[String] and
        (__ \ "function_id").readNullable[String]
      )(SubcatalogItemUpserted.apply _)
    }

    def jsObjectSubcatalogItemUpserted(obj: io.flow.v0.models.SubcatalogItemUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "number" -> play.api.libs.json.JsString(obj.number),
        "catalog" -> play.api.libs.json.JsString(obj.catalog),
        "subcatalog_id" -> play.api.libs.json.JsString(obj.subcatalogId),
        "status" -> play.api.libs.json.JsString(obj.status)
      ) ++ (obj.functionId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("function_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiSubcatalogReference: play.api.libs.json.Reads[SubcatalogReference] = {
      (__ \ "id").read[String].map { x => new SubcatalogReference(id = x) }
    }

    def jsObjectSubcatalogReference(obj: io.flow.v0.models.SubcatalogReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsApiSubcatalogSettings: play.api.libs.json.Reads[SubcatalogSettings] = {
      (__ \ "update_policy").read[io.flow.v0.models.UpdatePolicy].map { x => new SubcatalogSettings(updatePolicy = x) }
    }

    def jsObjectSubcatalogSettings(obj: io.flow.v0.models.SubcatalogSettings) = {
      play.api.libs.json.Json.obj(
        "update_policy" -> play.api.libs.json.JsString(obj.updatePolicy.toString)
      )
    }

    implicit def jsonWritesApiSubcatalogSettings: play.api.libs.json.Writes[SubcatalogSettings] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogSettings] {
        def writes(obj: io.flow.v0.models.SubcatalogSettings) = {
          jsObjectSubcatalogSettings(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogSettingsForm: play.api.libs.json.Reads[SubcatalogSettingsForm] = {
      (__ \ "update_policy").readNullable[io.flow.v0.models.UpdatePolicy].map { x => new SubcatalogSettingsForm(updatePolicy = x) }
    }

    def jsObjectSubcatalogSettingsForm(obj: io.flow.v0.models.SubcatalogSettingsForm) = {
      (obj.updatePolicy match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("update_policy" -> play.api.libs.json.JsString(x.toString))
      })
    }

    implicit def jsonWritesApiSubcatalogSettingsForm: play.api.libs.json.Writes[SubcatalogSettingsForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogSettingsForm] {
        def writes(obj: io.flow.v0.models.SubcatalogSettingsForm) = {
          jsObjectSubcatalogSettingsForm(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogStatistics: play.api.libs.json.Reads[SubcatalogStatistics] = {
      (
        (__ \ "excluded").read[io.flow.v0.models.ItemStatistics] and
        (__ \ "included").read[io.flow.v0.models.ItemStatistics] and
        (__ \ "restricted").read[io.flow.v0.models.ItemStatistics] and
        (__ \ "queue").read[io.flow.v0.models.ItemStatistics] and
        (__ \ "catalog").read[io.flow.v0.models.CatalogStatistics]
      )(SubcatalogStatistics.apply _)
    }

    def jsObjectSubcatalogStatistics(obj: io.flow.v0.models.SubcatalogStatistics) = {
      play.api.libs.json.Json.obj(
        "excluded" -> jsObjectItemStatistics(obj.excluded),
        "included" -> jsObjectItemStatistics(obj.included),
        "restricted" -> jsObjectItemStatistics(obj.restricted),
        "queue" -> jsObjectItemStatistics(obj.queue),
        "catalog" -> jsObjectCatalogStatistics(obj.catalog)
      )
    }

    implicit def jsonWritesApiSubcatalogStatistics: play.api.libs.json.Writes[SubcatalogStatistics] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogStatistics] {
        def writes(obj: io.flow.v0.models.SubcatalogStatistics) = {
          jsObjectSubcatalogStatistics(obj)
        }
      }
    }

    implicit def jsonReadsApiSubcatalogUpserted: play.api.libs.json.Reads[SubcatalogUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "catalog").read[String] and
        (__ \ "subcatalog_id").read[String]
      )(SubcatalogUpserted.apply _)
    }

    def jsObjectSubcatalogUpserted(obj: io.flow.v0.models.SubcatalogUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "catalog" -> play.api.libs.json.JsString(obj.catalog),
        "subcatalog_id" -> play.api.libs.json.JsString(obj.subcatalogId)
      )
    }

    implicit def jsonReadsApiSubcatalogVersion: play.api.libs.json.Reads[SubcatalogVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "subcatalog").read[io.flow.v0.models.Subcatalog]
      )(SubcatalogVersion.apply _)
    }

    def jsObjectSubcatalogVersion(obj: io.flow.v0.models.SubcatalogVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "subcatalog" -> jsObjectSubcatalog(obj.subcatalog)
      )
    }

    implicit def jsonWritesApiSubcatalogVersion: play.api.libs.json.Writes[SubcatalogVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.SubcatalogVersion] {
        def writes(obj: io.flow.v0.models.SubcatalogVersion) = {
          jsObjectSubcatalogVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiSuggestion: play.api.libs.json.Reads[Suggestion] = {
      (
        (__ \ "label").read[String] and
        (__ \ "count").read[Long]
      )(Suggestion.apply _)
    }

    def jsObjectSuggestion(obj: io.flow.v0.models.Suggestion) = {
      play.api.libs.json.Json.obj(
        "label" -> play.api.libs.json.JsString(obj.label),
        "count" -> play.api.libs.json.JsNumber(obj.count)
      )
    }

    implicit def jsonWritesApiSuggestion: play.api.libs.json.Writes[Suggestion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Suggestion] {
        def writes(obj: io.flow.v0.models.Suggestion) = {
          jsObjectSuggestion(obj)
        }
      }
    }

    implicit def jsonReadsApiTax: play.api.libs.json.Reads[Tax] = {
      (
        (__ \ "name").read[String] and
        (__ \ "rate").read[BigDecimal] and
        (__ \ "components").read[Seq[io.flow.v0.models.LevyComponent]] and
        (__ \ "deminimus").readNullable[io.flow.v0.models.Deminimus]
      )(Tax.apply _)
    }

    def jsObjectTax(obj: io.flow.v0.models.Tax) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "rate" -> play.api.libs.json.JsNumber(obj.rate),
        "components" -> play.api.libs.json.Json.toJson(obj.components)
      ) ++ (obj.deminimus match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("deminimus" -> jsObjectDeminimus(x))
      })
    }

    implicit def jsonWritesApiTax: play.api.libs.json.Writes[Tax] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Tax] {
        def writes(obj: io.flow.v0.models.Tax) = {
          jsObjectTax(obj)
        }
      }
    }

    implicit def jsonReadsApiTier: play.api.libs.json.Reads[Tier] = {
      (
        (__ \ "id").read[String] and
        (__ \ "experience").read[io.flow.v0.models.FulfillmentExperienceReference] and
        (__ \ "integration").read[io.flow.v0.models.ShipmentIntegrationType] and
        (__ \ "name").read[String] and
        (__ \ "rules").read[Seq[io.flow.v0.models.TierRule]] and
        (__ \ "services").read[Seq[io.flow.v0.models.Service]] and
        (__ \ "strategy").read[io.flow.v0.models.TierStrategy] and
        (__ \ "visibility").read[io.flow.v0.models.Visibility]
      )(Tier.apply _)
    }

    def jsObjectTier(obj: io.flow.v0.models.Tier) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectFulfillmentExperienceReference(obj.experience),
        "integration" -> play.api.libs.json.JsString(obj.integration.toString),
        "name" -> play.api.libs.json.JsString(obj.name),
        "rules" -> play.api.libs.json.Json.toJson(obj.rules),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString)
      )
    }

    implicit def jsonWritesApiTier: play.api.libs.json.Writes[Tier] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Tier] {
        def writes(obj: io.flow.v0.models.Tier) = {
          jsObjectTier(obj)
        }
      }
    }

    implicit def jsonReadsApiTierDefault: play.api.libs.json.Reads[TierDefault] = {
      (
        (__ \ "id").read[String] and
        (__ \ "default_tier").read[io.flow.v0.models.TierReference] and
        (__ \ "experience").read[io.flow.v0.models.FulfillmentExperienceReference]
      )(TierDefault.apply _)
    }

    def jsObjectTierDefault(obj: io.flow.v0.models.TierDefault) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "default_tier" -> jsObjectTierReference(obj.defaultTier),
        "experience" -> jsObjectFulfillmentExperienceReference(obj.experience)
      )
    }

    implicit def jsonWritesApiTierDefault: play.api.libs.json.Writes[TierDefault] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierDefault] {
        def writes(obj: io.flow.v0.models.TierDefault) = {
          jsObjectTierDefault(obj)
        }
      }
    }

    implicit def jsonReadsApiTierDefaultForm: play.api.libs.json.Reads[TierDefaultForm] = {
      (
        (__ \ "default_tier").read[String] and
        (__ \ "currency").read[String] and
        (__ \ "experience").read[String]
      )(TierDefaultForm.apply _)
    }

    def jsObjectTierDefaultForm(obj: io.flow.v0.models.TierDefaultForm) = {
      play.api.libs.json.Json.obj(
        "default_tier" -> play.api.libs.json.JsString(obj.defaultTier),
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "experience" -> play.api.libs.json.JsString(obj.experience)
      )
    }

    implicit def jsonWritesApiTierDefaultForm: play.api.libs.json.Writes[TierDefaultForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierDefaultForm] {
        def writes(obj: io.flow.v0.models.TierDefaultForm) = {
          jsObjectTierDefaultForm(obj)
        }
      }
    }

    implicit def jsonReadsApiTierDefaultVersion: play.api.libs.json.Reads[TierDefaultVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "tier_default").read[io.flow.v0.models.TierDefault]
      )(TierDefaultVersion.apply _)
    }

    def jsObjectTierDefaultVersion(obj: io.flow.v0.models.TierDefaultVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "tier_default" -> jsObjectTierDefault(obj.tierDefault)
      )
    }

    implicit def jsonWritesApiTierDefaultVersion: play.api.libs.json.Writes[TierDefaultVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierDefaultVersion] {
        def writes(obj: io.flow.v0.models.TierDefaultVersion) = {
          jsObjectTierDefaultVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiTierForm: play.api.libs.json.Reads[TierForm] = {
      (
        (__ \ "currency").read[String] and
        (__ \ "experience").read[String] and
        (__ \ "integration").read[io.flow.v0.models.ShipmentIntegrationType] and
        (__ \ "name").read[String] and
        (__ \ "rules").read[Seq[io.flow.v0.models.TierRuleForm]] and
        (__ \ "services").read[Seq[String]] and
        (__ \ "strategy").read[io.flow.v0.models.TierStrategy] and
        (__ \ "visibility").read[io.flow.v0.models.Visibility]
      )(TierForm.apply _)
    }

    def jsObjectTierForm(obj: io.flow.v0.models.TierForm) = {
      play.api.libs.json.Json.obj(
        "currency" -> play.api.libs.json.JsString(obj.currency),
        "experience" -> play.api.libs.json.JsString(obj.experience),
        "integration" -> play.api.libs.json.JsString(obj.integration.toString),
        "name" -> play.api.libs.json.JsString(obj.name),
        "rules" -> play.api.libs.json.Json.toJson(obj.rules),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString)
      )
    }

    implicit def jsonWritesApiTierForm: play.api.libs.json.Writes[TierForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierForm] {
        def writes(obj: io.flow.v0.models.TierForm) = {
          jsObjectTierForm(obj)
        }
      }
    }

    implicit def jsonReadsApiTierReference: play.api.libs.json.Reads[TierReference] = {
      (__ \ "id").read[String].map { x => new TierReference(id = x) }
    }

    def jsObjectTierReference(obj: io.flow.v0.models.TierReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiTierReference: play.api.libs.json.Writes[TierReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierReference] {
        def writes(obj: io.flow.v0.models.TierReference) = {
          jsObjectTierReference(obj)
        }
      }
    }

    implicit def jsonReadsApiTierRule: play.api.libs.json.Reads[TierRule] = {
      (
        (__ \ "id").read[String] and
        (__ \ "position").read[Long] and
        (__ \ "query").read[String] and
        (__ \ "outcome").read[io.flow.v0.models.TierRuleOutcome]
      )(TierRule.apply _)
    }

    def jsObjectTierRule(obj: io.flow.v0.models.TierRule) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "position" -> play.api.libs.json.JsNumber(obj.position),
        "query" -> play.api.libs.json.JsString(obj.query),
        "outcome" -> jsObjectTierRuleOutcome(obj.outcome)
      )
    }

    implicit def jsonWritesApiTierRule: play.api.libs.json.Writes[TierRule] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierRule] {
        def writes(obj: io.flow.v0.models.TierRule) = {
          jsObjectTierRule(obj)
        }
      }
    }

    implicit def jsonReadsApiTierRuleForm: play.api.libs.json.Reads[TierRuleForm] = {
      (
        (__ \ "position").readNullable[Long] and
        (__ \ "query").read[String] and
        (__ \ "outcome").read[io.flow.v0.models.TierRuleOutcome]
      )(TierRuleForm.apply _)
    }

    def jsObjectTierRuleForm(obj: io.flow.v0.models.TierRuleForm) = {
      play.api.libs.json.Json.obj(
        "query" -> play.api.libs.json.JsString(obj.query),
        "outcome" -> jsObjectTierRuleOutcome(obj.outcome)
      ) ++ (obj.position match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("position" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesApiTierRuleForm: play.api.libs.json.Writes[TierRuleForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierRuleForm] {
        def writes(obj: io.flow.v0.models.TierRuleForm) = {
          jsObjectTierRuleForm(obj)
        }
      }
    }

    implicit def jsonReadsApiTierRuleVersion: play.api.libs.json.Reads[TierRuleVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "tier_rule").read[io.flow.v0.models.TierRule]
      )(TierRuleVersion.apply _)
    }

    def jsObjectTierRuleVersion(obj: io.flow.v0.models.TierRuleVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "tier_rule" -> jsObjectTierRule(obj.tierRule)
      )
    }

    implicit def jsonWritesApiTierRuleVersion: play.api.libs.json.Writes[TierRuleVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierRuleVersion] {
        def writes(obj: io.flow.v0.models.TierRuleVersion) = {
          jsObjectTierRuleVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiTierSummary: play.api.libs.json.Reads[TierSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "experience").read[io.flow.v0.models.FulfillmentExperienceReference] and
        (__ \ "integration").read[io.flow.v0.models.ShipmentIntegrationType] and
        (__ \ "name").read[String] and
        (__ \ "services").read[Seq[String]] and
        (__ \ "strategy").read[io.flow.v0.models.TierStrategy] and
        (__ \ "visibility").read[io.flow.v0.models.Visibility]
      )(TierSummary.apply _)
    }

    def jsObjectTierSummary(obj: io.flow.v0.models.TierSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "experience" -> jsObjectFulfillmentExperienceReference(obj.experience),
        "integration" -> play.api.libs.json.JsString(obj.integration.toString),
        "name" -> play.api.libs.json.JsString(obj.name),
        "services" -> play.api.libs.json.Json.toJson(obj.services),
        "strategy" -> play.api.libs.json.JsString(obj.strategy.toString),
        "visibility" -> play.api.libs.json.JsString(obj.visibility.toString)
      )
    }

    implicit def jsonWritesApiTierSummary: play.api.libs.json.Writes[TierSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierSummary] {
        def writes(obj: io.flow.v0.models.TierSummary) = {
          jsObjectTierSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiTierVersion: play.api.libs.json.Reads[TierVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "tier").read[io.flow.v0.models.TierSummary]
      )(TierVersion.apply _)
    }

    def jsObjectTierVersion(obj: io.flow.v0.models.TierVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "tier" -> jsObjectTierSummary(obj.tier)
      )
    }

    implicit def jsonWritesApiTierVersion: play.api.libs.json.Writes[TierVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierVersion] {
        def writes(obj: io.flow.v0.models.TierVersion) = {
          jsObjectTierVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiTimezone: play.api.libs.json.Reads[Timezone] = {
      (
        (__ \ "name").read[String] and
        (__ \ "description").read[String] and
        (__ \ "offset").read[Int]
      )(Timezone.apply _)
    }

    def jsObjectTimezone(obj: io.flow.v0.models.Timezone) = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "description" -> play.api.libs.json.JsString(obj.description),
        "offset" -> play.api.libs.json.JsNumber(obj.offset)
      )
    }

    implicit def jsonWritesApiTimezone: play.api.libs.json.Writes[Timezone] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Timezone] {
        def writes(obj: io.flow.v0.models.Timezone) = {
          jsObjectTimezone(obj)
        }
      }
    }

    implicit def jsonReadsApiToken: play.api.libs.json.Reads[Token] = {
      (
        (__ \ "id").read[String] and
        (__ \ "user").read[io.flow.v0.models.UserReference] and
        (__ \ "partial").read[String] and
        (__ \ "created_at").read[_root_.org.joda.time.DateTime] and
        (__ \ "description").readNullable[String]
      )(Token.apply _)
    }

    def jsObjectToken(obj: io.flow.v0.models.Token) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "user" -> jsObjectUserReference(obj.user),
        "partial" -> play.api.libs.json.JsString(obj.partial),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiToken: play.api.libs.json.Writes[Token] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Token] {
        def writes(obj: io.flow.v0.models.Token) = {
          jsObjectToken(obj)
        }
      }
    }

    implicit def jsonReadsApiTokenAuthenticationForm: play.api.libs.json.Reads[TokenAuthenticationForm] = {
      (__ \ "token").read[String].map { x => new TokenAuthenticationForm(token = x) }
    }

    def jsObjectTokenAuthenticationForm(obj: io.flow.v0.models.TokenAuthenticationForm) = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesApiTokenAuthenticationForm: play.api.libs.json.Writes[TokenAuthenticationForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TokenAuthenticationForm] {
        def writes(obj: io.flow.v0.models.TokenAuthenticationForm) = {
          jsObjectTokenAuthenticationForm(obj)
        }
      }
    }

    implicit def jsonReadsApiTokenForm: play.api.libs.json.Reads[TokenForm] = {
      (__ \ "description").readNullable[String].map { x => new TokenForm(description = x) }
    }

    def jsObjectTokenForm(obj: io.flow.v0.models.TokenForm) = {
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiTokenForm: play.api.libs.json.Writes[TokenForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TokenForm] {
        def writes(obj: io.flow.v0.models.TokenForm) = {
          jsObjectTokenForm(obj)
        }
      }
    }

    implicit def jsonReadsApiTokenReference: play.api.libs.json.Reads[TokenReference] = {
      (
        (__ \ "id").read[String] and
        (__ \ "user").read[io.flow.v0.models.UserReference]
      )(TokenReference.apply _)
    }

    def jsObjectTokenReference(obj: io.flow.v0.models.TokenReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "user" -> jsObjectUserReference(obj.user)
      )
    }

    implicit def jsonWritesApiTokenReference: play.api.libs.json.Writes[TokenReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TokenReference] {
        def writes(obj: io.flow.v0.models.TokenReference) = {
          jsObjectTokenReference(obj)
        }
      }
    }

    implicit def jsonReadsApiTokenVersion: play.api.libs.json.Reads[TokenVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "token").read[io.flow.v0.models.Token]
      )(TokenVersion.apply _)
    }

    def jsObjectTokenVersion(obj: io.flow.v0.models.TokenVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "token" -> jsObjectToken(obj.token)
      )
    }

    implicit def jsonWritesApiTokenVersion: play.api.libs.json.Writes[TokenVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TokenVersion] {
        def writes(obj: io.flow.v0.models.TokenVersion) = {
          jsObjectTokenVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiTracking: play.api.libs.json.Reads[Tracking] = {
      (
        (__ \ "id").read[String] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus] and
        (__ \ "metadata").read[_root_.play.api.libs.json.JsObject]
      )(Tracking.apply _)
    }

    def jsObjectTracking(obj: io.flow.v0.models.Tracking) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "metadata" -> obj.metadata
      )
    }

    implicit def jsonWritesApiTracking: play.api.libs.json.Writes[Tracking] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Tracking] {
        def writes(obj: io.flow.v0.models.Tracking) = {
          jsObjectTracking(obj)
        }
      }
    }

    implicit def jsonReadsApiTrackingForm: play.api.libs.json.Reads[TrackingForm] = {
      (
        (__ \ "status").readNullable[io.flow.v0.models.TrackingStatus] and
        (__ \ "metadata").readNullable[_root_.play.api.libs.json.JsObject]
      )(TrackingForm.apply _)
    }

    def jsObjectTrackingForm(obj: io.flow.v0.models.TrackingForm) = {
      (obj.status match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("status" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.metadata match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("metadata" -> x)
      })
    }

    implicit def jsonWritesApiTrackingForm: play.api.libs.json.Writes[TrackingForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TrackingForm] {
        def writes(obj: io.flow.v0.models.TrackingForm) = {
          jsObjectTrackingForm(obj)
        }
      }
    }

    implicit def jsonReadsApiTrackingLabelEventUpserted: play.api.libs.json.Reads[TrackingLabelEventUpserted] = {
      (
        (__ \ "event_id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "organization").read[String] and
        (__ \ "address").read[_root_.play.api.libs.json.JsObject] and
        (__ \ "carrier").read[String] and
        (__ \ "carrier_timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "carrier_tracking_number").read[String] and
        (__ \ "flow_tracking_numnber").read[String] and
        (__ \ "status").read[String] and
        (__ \ "delivery_estimate").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "description").readNullable[String]
      )(TrackingLabelEventUpserted.apply _)
    }

    def jsObjectTrackingLabelEventUpserted(obj: io.flow.v0.models.TrackingLabelEventUpserted) = {
      play.api.libs.json.Json.obj(
        "event_id" -> play.api.libs.json.JsString(obj.eventId),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "organization" -> play.api.libs.json.JsString(obj.organization),
        "address" -> obj.address,
        "carrier" -> play.api.libs.json.JsString(obj.carrier),
        "carrier_timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.carrierTimestamp)),
        "carrier_tracking_number" -> play.api.libs.json.JsString(obj.carrierTrackingNumber),
        "flow_tracking_numnber" -> play.api.libs.json.JsString(obj.flowTrackingNumnber),
        "status" -> play.api.libs.json.JsString(obj.status)
      ) ++ (obj.deliveryEstimate match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("delivery_estimate" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiTrackingSummary: play.api.libs.json.Reads[TrackingSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "status").read[io.flow.v0.models.TrackingStatus]
      )(TrackingSummary.apply _)
    }

    def jsObjectTrackingSummary(obj: io.flow.v0.models.TrackingSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      )
    }

    implicit def jsonWritesApiTrackingSummary: play.api.libs.json.Writes[TrackingSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TrackingSummary] {
        def writes(obj: io.flow.v0.models.TrackingSummary) = {
          jsObjectTrackingSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiTrackingVersion: play.api.libs.json.Reads[TrackingVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "tracking").read[io.flow.v0.models.TrackingSummary]
      )(TrackingVersion.apply _)
    }

    def jsObjectTrackingVersion(obj: io.flow.v0.models.TrackingVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "tracking" -> jsObjectTrackingSummary(obj.tracking)
      )
    }

    implicit def jsonWritesApiTrackingVersion: play.api.libs.json.Writes[TrackingVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TrackingVersion] {
        def writes(obj: io.flow.v0.models.TrackingVersion) = {
          jsObjectTrackingVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiUser: play.api.libs.json.Reads[User] = {
      (
        (__ \ "id").read[String] and
        (__ \ "email").readNullable[String] and
        (__ \ "name").read[io.flow.v0.models.Name]
      )(User.apply _)
    }

    def jsObjectUser(obj: io.flow.v0.models.User) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> jsObjectName(obj.name)
      ) ++ (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsApiUserForm: play.api.libs.json.Reads[UserForm] = {
      (
        (__ \ "email").readNullable[String] and
        (__ \ "password").readNullable[String] and
        (__ \ "name").readNullable[io.flow.v0.models.NameForm]
      )(UserForm.apply _)
    }

    def jsObjectUserForm(obj: io.flow.v0.models.UserForm) = {
      (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.password match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("password" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> jsObjectNameForm(x))
      })
    }

    implicit def jsonWritesApiUserForm: play.api.libs.json.Writes[UserForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UserForm] {
        def writes(obj: io.flow.v0.models.UserForm) = {
          jsObjectUserForm(obj)
        }
      }
    }

    implicit def jsonReadsApiUserPutForm: play.api.libs.json.Reads[UserPutForm] = {
      (
        (__ \ "email").readNullable[String] and
        (__ \ "name").readNullable[io.flow.v0.models.NameForm]
      )(UserPutForm.apply _)
    }

    def jsObjectUserPutForm(obj: io.flow.v0.models.UserPutForm) = {
      (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> jsObjectNameForm(x))
      })
    }

    implicit def jsonWritesApiUserPutForm: play.api.libs.json.Writes[UserPutForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UserPutForm] {
        def writes(obj: io.flow.v0.models.UserPutForm) = {
          jsObjectUserPutForm(obj)
        }
      }
    }

    implicit def jsonReadsApiUserReference: play.api.libs.json.Reads[UserReference] = {
      (__ \ "id").read[String].map { x => new UserReference(id = x) }
    }

    def jsObjectUserReference(obj: io.flow.v0.models.UserReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonReadsApiUserSummary: play.api.libs.json.Reads[UserSummary] = {
      (
        (__ \ "id").read[String] and
        (__ \ "email").readNullable[String] and
        (__ \ "name").read[String]
      )(UserSummary.apply _)
    }

    def jsObjectUserSummary(obj: io.flow.v0.models.UserSummary) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "name" -> play.api.libs.json.JsString(obj.name)
      ) ++ (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiUserSummary: play.api.libs.json.Writes[UserSummary] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UserSummary] {
        def writes(obj: io.flow.v0.models.UserSummary) = {
          jsObjectUserSummary(obj)
        }
      }
    }

    implicit def jsonReadsApiUserVersion: play.api.libs.json.Reads[UserVersion] = {
      (
        (__ \ "id").read[String] and
        (__ \ "timestamp").read[_root_.org.joda.time.DateTime] and
        (__ \ "type").read[io.flow.v0.models.ChangeType] and
        (__ \ "user").read[io.flow.v0.models.User]
      )(UserVersion.apply _)
    }

    def jsObjectUserVersion(obj: io.flow.v0.models.UserVersion) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "timestamp" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.timestamp)),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "user" -> jsObjectUser(obj.user)
      )
    }

    implicit def jsonWritesApiUserVersion: play.api.libs.json.Writes[UserVersion] = {
      new play.api.libs.json.Writes[io.flow.v0.models.UserVersion] {
        def writes(obj: io.flow.v0.models.UserVersion) = {
          jsObjectUserVersion(obj)
        }
      }
    }

    implicit def jsonReadsApiValidation: play.api.libs.json.Reads[Validation] = {
      (__ \ "status").read[String].map { x => new Validation(status = x) }
    }

    def jsObjectValidation(obj: io.flow.v0.models.Validation) = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesApiValidation: play.api.libs.json.Writes[Validation] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Validation] {
        def writes(obj: io.flow.v0.models.Validation) = {
          jsObjectValidation(obj)
        }
      }
    }

    implicit def jsonReadsApiValidationForm: play.api.libs.json.Reads[ValidationForm] = {
      (__ \ "token").read[String].map { x => new ValidationForm(token = x) }
    }

    def jsObjectValidationForm(obj: io.flow.v0.models.ValidationForm) = {
      play.api.libs.json.Json.obj(
        "token" -> play.api.libs.json.JsString(obj.token)
      )
    }

    implicit def jsonWritesApiValidationForm: play.api.libs.json.Writes[ValidationForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ValidationForm] {
        def writes(obj: io.flow.v0.models.ValidationForm) = {
          jsObjectValidationForm(obj)
        }
      }
    }

    implicit def jsonReadsApiWebhook: play.api.libs.json.Reads[Webhook] = {
      (
        (__ \ "id").read[String] and
        (__ \ "url").read[String] and
        (__ \ "events").read[Seq[io.flow.v0.models.EventType]]
      )(Webhook.apply _)
    }

    def jsObjectWebhook(obj: io.flow.v0.models.Webhook) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "url" -> play.api.libs.json.JsString(obj.url),
        "events" -> play.api.libs.json.Json.toJson(obj.events)
      )
    }

    implicit def jsonWritesApiWebhook: play.api.libs.json.Writes[Webhook] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Webhook] {
        def writes(obj: io.flow.v0.models.Webhook) = {
          jsObjectWebhook(obj)
        }
      }
    }

    implicit def jsonReadsApiWebhookForm: play.api.libs.json.Reads[WebhookForm] = {
      (
        (__ \ "url").read[String] and
        (__ \ "events").read[Seq[io.flow.v0.models.EventType]]
      )(WebhookForm.apply _)
    }

    def jsObjectWebhookForm(obj: io.flow.v0.models.WebhookForm) = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "events" -> play.api.libs.json.Json.toJson(obj.events)
      )
    }

    implicit def jsonWritesApiWebhookForm: play.api.libs.json.Writes[WebhookForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.WebhookForm] {
        def writes(obj: io.flow.v0.models.WebhookForm) = {
          jsObjectWebhookForm(obj)
        }
      }
    }

    implicit def jsonReadsApiWebhookReference: play.api.libs.json.Reads[WebhookReference] = {
      (__ \ "id").read[String].map { x => new WebhookReference(id = x) }
    }

    def jsObjectWebhookReference(obj: io.flow.v0.models.WebhookReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiWebhookReference: play.api.libs.json.Writes[WebhookReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.WebhookReference] {
        def writes(obj: io.flow.v0.models.WebhookReference) = {
          jsObjectWebhookReference(obj)
        }
      }
    }

    implicit def jsonReadsApiWebhookRequest: play.api.libs.json.Reads[WebhookRequest] = {
      (
        (__ \ "id").read[String] and
        (__ \ "webhook").read[io.flow.v0.models.WebhookReference] and
        (__ \ "headers").read[Seq[io.flow.v0.models.Header]] and
        (__ \ "method").read[io.flow.v0.models.Method] and
        (__ \ "body").read[String] and
        (__ \ "status").read[io.flow.v0.models.WebhookRequestStatus] and
        (__ \ "started_at").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "completed_at").readNullable[_root_.org.joda.time.DateTime] and
        (__ \ "duration_ms").readNullable[Long] and
        (__ \ "response").readNullable[io.flow.v0.models.WebhookResponse] and
        (__ \ "error").readNullable[String]
      )(WebhookRequest.apply _)
    }

    def jsObjectWebhookRequest(obj: io.flow.v0.models.WebhookRequest) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "webhook" -> jsObjectWebhookReference(obj.webhook),
        "headers" -> play.api.libs.json.Json.toJson(obj.headers),
        "method" -> play.api.libs.json.JsString(obj.method.toString),
        "body" -> play.api.libs.json.JsString(obj.body),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.startedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("started_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.completedAt match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("completed_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.durationMs match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("duration_ms" -> play.api.libs.json.JsNumber(x))
      }) ++
      (obj.response match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("response" -> jsObjectWebhookResponse(x))
      }) ++
      (obj.error match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("error" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiWebhookRequest: play.api.libs.json.Writes[WebhookRequest] = {
      new play.api.libs.json.Writes[io.flow.v0.models.WebhookRequest] {
        def writes(obj: io.flow.v0.models.WebhookRequest) = {
          jsObjectWebhookRequest(obj)
        }
      }
    }

    implicit def jsonReadsApiWebhookRequestReference: play.api.libs.json.Reads[WebhookRequestReference] = {
      (__ \ "id").read[String].map { x => new WebhookRequestReference(id = x) }
    }

    def jsObjectWebhookRequestReference(obj: io.flow.v0.models.WebhookRequestReference) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id)
      )
    }

    implicit def jsonWritesApiWebhookRequestReference: play.api.libs.json.Writes[WebhookRequestReference] = {
      new play.api.libs.json.Writes[io.flow.v0.models.WebhookRequestReference] {
        def writes(obj: io.flow.v0.models.WebhookRequestReference) = {
          jsObjectWebhookRequestReference(obj)
        }
      }
    }

    implicit def jsonReadsApiWebhookResponse: play.api.libs.json.Reads[WebhookResponse] = {
      (
        (__ \ "id").read[String] and
        (__ \ "request").read[io.flow.v0.models.WebhookRequestReference] and
        (__ \ "headers").read[Seq[io.flow.v0.models.Header]] and
        (__ \ "body").read[String] and
        (__ \ "status").read[Int]
      )(WebhookResponse.apply _)
    }

    def jsObjectWebhookResponse(obj: io.flow.v0.models.WebhookResponse) = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsString(obj.id),
        "request" -> jsObjectWebhookRequestReference(obj.request),
        "headers" -> play.api.libs.json.Json.toJson(obj.headers),
        "body" -> play.api.libs.json.JsString(obj.body),
        "status" -> play.api.libs.json.JsNumber(obj.status)
      )
    }

    implicit def jsonWritesApiWebhookResponse: play.api.libs.json.Writes[WebhookResponse] = {
      new play.api.libs.json.Writes[io.flow.v0.models.WebhookResponse] {
        def writes(obj: io.flow.v0.models.WebhookResponse) = {
          jsObjectWebhookResponse(obj)
        }
      }
    }

    implicit def jsonReadsApiZone: play.api.libs.json.Reads[Zone] = {
      (
        (__ \ "province").readNullable[String] and
        (__ \ "country").read[String]
      )(Zone.apply _)
    }

    def jsObjectZone(obj: io.flow.v0.models.Zone) = {
      play.api.libs.json.Json.obj(
        "country" -> play.api.libs.json.JsString(obj.country)
      ) ++ (obj.province match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("province" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesApiZone: play.api.libs.json.Writes[Zone] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Zone] {
        def writes(obj: io.flow.v0.models.Zone) = {
          jsObjectZone(obj)
        }
      }
    }

    implicit def jsonReadsApiAuthorizationForm: play.api.libs.json.Reads[AuthorizationForm] = new play.api.libs.json.Reads[AuthorizationForm] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[AuthorizationForm] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "direct_authorization_form" => js.validate[io.flow.v0.models.DirectAuthorizationForm]
              case "merchant_of_record_authorization_form" => js.validate[io.flow.v0.models.MerchantOfRecordAuthorizationForm]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.AuthorizationFormUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectAuthorizationForm(obj: io.flow.v0.models.AuthorizationForm) = {
      obj match {
        case x: io.flow.v0.models.DirectAuthorizationForm => jsObjectDirectAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "direct_authorization_form")
        case x: io.flow.v0.models.MerchantOfRecordAuthorizationForm => jsObjectMerchantOfRecordAuthorizationForm(x) ++ play.api.libs.json.Json.obj("discriminator" -> "merchant_of_record_authorization_form")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiAuthorizationForm: play.api.libs.json.Writes[AuthorizationForm] = {
      new play.api.libs.json.Writes[io.flow.v0.models.AuthorizationForm] {
        def writes(obj: io.flow.v0.models.AuthorizationForm) = {
          jsObjectAuthorizationForm(obj)
        }
      }
    }

    implicit def jsonReadsApiDeminimus: play.api.libs.json.Reads[Deminimus] = new play.api.libs.json.Reads[Deminimus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Deminimus] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "deminimus_simple" => js.validate[io.flow.v0.models.DeminimusSimple]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.DeminimusUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectDeminimus(obj: io.flow.v0.models.Deminimus) = {
      obj match {
        case x: io.flow.v0.models.DeminimusSimple => jsObjectDeminimusSimple(x) ++ play.api.libs.json.Json.obj("discriminator" -> "deminimus_simple")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiDeminimus: play.api.libs.json.Writes[Deminimus] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Deminimus] {
        def writes(obj: io.flow.v0.models.Deminimus) = {
          jsObjectDeminimus(obj)
        }
      }
    }

    implicit def jsonReadsApiDocument: play.api.libs.json.Reads[Document] = new play.api.libs.json.Reads[Document] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Document] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "catalog_item_document" => js.validate[io.flow.v0.models.CatalogItemDocument]
              case "harmonization_document" => js.validate[io.flow.v0.models.HarmonizationDocument]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.DocumentUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectDocument(obj: io.flow.v0.models.Document) = {
      obj match {
        case x: io.flow.v0.models.CatalogItemDocument => jsObjectCatalogItemDocument(x) ++ play.api.libs.json.Json.obj("discriminator" -> "catalog_item_document")
        case x: io.flow.v0.models.HarmonizationDocument => jsObjectHarmonizationDocument(x) ++ play.api.libs.json.Json.obj("discriminator" -> "harmonization_document")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiDocument: play.api.libs.json.Writes[Document] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Document] {
        def writes(obj: io.flow.v0.models.Document) = {
          jsObjectDocument(obj)
        }
      }
    }

    implicit def jsonReadsApiEvent: play.api.libs.json.Reads[Event] = new play.api.libs.json.Reads[Event] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Event] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "catalog_upserted" => js.validate[io.flow.v0.models.CatalogUpserted]
              case "catalog_deleted" => js.validate[io.flow.v0.models.CatalogDeleted]
              case "subcatalog_upserted" => js.validate[io.flow.v0.models.SubcatalogUpserted]
              case "subcatalog_deleted" => js.validate[io.flow.v0.models.SubcatalogDeleted]
              case "catalog_item_upserted" => js.validate[io.flow.v0.models.CatalogItemUpserted]
              case "catalog_item_deleted" => js.validate[io.flow.v0.models.CatalogItemDeleted]
              case "subcatalog_item_upserted" => js.validate[io.flow.v0.models.SubcatalogItemUpserted]
              case "subcatalog_item_deleted" => js.validate[io.flow.v0.models.SubcatalogItemDeleted]
              case "flow_currency_setting_deleted" => js.validate[io.flow.v0.models.FlowCurrencySettingDeleted]
              case "flow_currency_setting_upserted" => js.validate[io.flow.v0.models.FlowCurrencySettingUpserted]
              case "rate_deleted" => js.validate[io.flow.v0.models.RateDeleted]
              case "rate_upserted" => js.validate[io.flow.v0.models.RateUpserted]
              case "spot_rate_deleted" => js.validate[io.flow.v0.models.SpotRateDeleted]
              case "spot_rate_upserted" => js.validate[io.flow.v0.models.SpotRateUpserted]
              case "organization_currency_setting_deleted" => js.validate[io.flow.v0.models.OrganizationCurrencySettingDeleted]
              case "organization_currency_setting_upserted" => js.validate[io.flow.v0.models.OrganizationCurrencySettingUpserted]
              case "contracted_rate_upserted" => js.validate[io.flow.v0.models.ContractedRateUpserted]
              case "experience_deleted" => js.validate[io.flow.v0.models.ExperienceDeleted]
              case "experience_upserted" => js.validate[io.flow.v0.models.ExperienceUpserted]
              case "item_margin_deleted" => js.validate[io.flow.v0.models.ItemMarginDeleted]
              case "item_margin_upserted" => js.validate[io.flow.v0.models.ItemMarginUpserted]
              case "hs6_code_upserted" => js.validate[io.flow.v0.models.Hs6CodeUpserted]
              case "hs6_code_deleted" => js.validate[io.flow.v0.models.Hs6CodeDeleted]
              case "hs10_code_upserted" => js.validate[io.flow.v0.models.Hs10CodeUpserted]
              case "hs10_code_deleted" => js.validate[io.flow.v0.models.Hs10CodeDeleted]
              case "localized_item_upserted" => js.validate[io.flow.v0.models.LocalizedItemUpserted]
              case "localized_item_deleted" => js.validate[io.flow.v0.models.LocalizedItemDeleted]
              case "organization_upserted" => js.validate[io.flow.v0.models.OrganizationUpserted]
              case "organization_deleted" => js.validate[io.flow.v0.models.OrganizationDeleted]
              case "tracking_label_event_upserted" => js.validate[io.flow.v0.models.TrackingLabelEventUpserted]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.EventUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectEvent(obj: io.flow.v0.models.Event) = {
      obj match {
        case x: io.flow.v0.models.CatalogUpserted => jsObjectCatalogUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "catalog_upserted")
        case x: io.flow.v0.models.CatalogDeleted => jsObjectCatalogDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "catalog_deleted")
        case x: io.flow.v0.models.SubcatalogUpserted => jsObjectSubcatalogUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_upserted")
        case x: io.flow.v0.models.SubcatalogDeleted => jsObjectSubcatalogDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_deleted")
        case x: io.flow.v0.models.CatalogItemUpserted => jsObjectCatalogItemUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "catalog_item_upserted")
        case x: io.flow.v0.models.CatalogItemDeleted => jsObjectCatalogItemDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "catalog_item_deleted")
        case x: io.flow.v0.models.SubcatalogItemUpserted => jsObjectSubcatalogItemUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_item_upserted")
        case x: io.flow.v0.models.SubcatalogItemDeleted => jsObjectSubcatalogItemDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_item_deleted")
        case x: io.flow.v0.models.FlowCurrencySettingDeleted => jsObjectFlowCurrencySettingDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "flow_currency_setting_deleted")
        case x: io.flow.v0.models.FlowCurrencySettingUpserted => jsObjectFlowCurrencySettingUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "flow_currency_setting_upserted")
        case x: io.flow.v0.models.RateDeleted => jsObjectRateDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "rate_deleted")
        case x: io.flow.v0.models.RateUpserted => jsObjectRateUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "rate_upserted")
        case x: io.flow.v0.models.SpotRateDeleted => jsObjectSpotRateDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "spot_rate_deleted")
        case x: io.flow.v0.models.SpotRateUpserted => jsObjectSpotRateUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "spot_rate_upserted")
        case x: io.flow.v0.models.OrganizationCurrencySettingDeleted => jsObjectOrganizationCurrencySettingDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "organization_currency_setting_deleted")
        case x: io.flow.v0.models.OrganizationCurrencySettingUpserted => jsObjectOrganizationCurrencySettingUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "organization_currency_setting_upserted")
        case x: io.flow.v0.models.ContractedRateUpserted => jsObjectContractedRateUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "contracted_rate_upserted")
        case x: io.flow.v0.models.ExperienceDeleted => jsObjectExperienceDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "experience_deleted")
        case x: io.flow.v0.models.ExperienceUpserted => jsObjectExperienceUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "experience_upserted")
        case x: io.flow.v0.models.ItemMarginDeleted => jsObjectItemMarginDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "item_margin_deleted")
        case x: io.flow.v0.models.ItemMarginUpserted => jsObjectItemMarginUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "item_margin_upserted")
        case x: io.flow.v0.models.Hs6CodeUpserted => jsObjectHs6CodeUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "hs6_code_upserted")
        case x: io.flow.v0.models.Hs6CodeDeleted => jsObjectHs6CodeDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "hs6_code_deleted")
        case x: io.flow.v0.models.Hs10CodeUpserted => jsObjectHs10CodeUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "hs10_code_upserted")
        case x: io.flow.v0.models.Hs10CodeDeleted => jsObjectHs10CodeDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "hs10_code_deleted")
        case x: io.flow.v0.models.LocalizedItemUpserted => jsObjectLocalizedItemUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "localized_item_upserted")
        case x: io.flow.v0.models.LocalizedItemDeleted => jsObjectLocalizedItemDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "localized_item_deleted")
        case x: io.flow.v0.models.OrganizationUpserted => jsObjectOrganizationUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "organization_upserted")
        case x: io.flow.v0.models.OrganizationDeleted => jsObjectOrganizationDeleted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "organization_deleted")
        case x: io.flow.v0.models.TrackingLabelEventUpserted => jsObjectTrackingLabelEventUpserted(x) ++ play.api.libs.json.Json.obj("discriminator" -> "tracking_label_event_upserted")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiEvent: play.api.libs.json.Writes[Event] = {
      new play.api.libs.json.Writes[io.flow.v0.models.Event] {
        def writes(obj: io.flow.v0.models.Event) = {
          jsObjectEvent(obj)
        }
      }
    }

    implicit def jsonReadsApiExpandableItemFunction: play.api.libs.json.Reads[ExpandableItemFunction] = new play.api.libs.json.Reads[ExpandableItemFunction] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableItemFunction] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "item_function" => js.validate[io.flow.v0.models.ItemFunction]
              case "item_function_reference" => js.validate[io.flow.v0.models.ItemFunctionReference]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.ExpandableItemFunctionUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectExpandableItemFunction(obj: io.flow.v0.models.ExpandableItemFunction) = {
      obj match {
        case x: io.flow.v0.models.ItemFunction => jsObjectItemFunction(x) ++ play.api.libs.json.Json.obj("discriminator" -> "item_function")
        case x: io.flow.v0.models.ItemFunctionReference => jsObjectItemFunctionReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "item_function_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiExpandableItemFunction: play.api.libs.json.Writes[ExpandableItemFunction] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExpandableItemFunction] {
        def writes(obj: io.flow.v0.models.ExpandableItemFunction) = {
          jsObjectExpandableItemFunction(obj)
        }
      }
    }

    implicit def jsonReadsApiExpandableOrganization: play.api.libs.json.Reads[ExpandableOrganization] = new play.api.libs.json.Reads[ExpandableOrganization] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableOrganization] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "organization" => js.validate[io.flow.v0.models.Organization]
              case "organization_reference" => js.validate[io.flow.v0.models.OrganizationReference]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.ExpandableOrganizationUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectExpandableOrganization(obj: io.flow.v0.models.ExpandableOrganization) = {
      obj match {
        case x: io.flow.v0.models.Organization => jsObjectOrganization(x) ++ play.api.libs.json.Json.obj("discriminator" -> "organization")
        case x: io.flow.v0.models.OrganizationReference => jsObjectOrganizationReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "organization_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiExpandableOrganization: play.api.libs.json.Writes[ExpandableOrganization] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExpandableOrganization] {
        def writes(obj: io.flow.v0.models.ExpandableOrganization) = {
          jsObjectExpandableOrganization(obj)
        }
      }
    }

    implicit def jsonReadsApiExpandableSubcatalog: play.api.libs.json.Reads[ExpandableSubcatalog] = new play.api.libs.json.Reads[ExpandableSubcatalog] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableSubcatalog] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "subcatalog" => js.validate[io.flow.v0.models.Subcatalog]
              case "subcatalog_reference" => js.validate[io.flow.v0.models.SubcatalogReference]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.ExpandableSubcatalogUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectExpandableSubcatalog(obj: io.flow.v0.models.ExpandableSubcatalog) = {
      obj match {
        case x: io.flow.v0.models.Subcatalog => jsObjectSubcatalog(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog")
        case x: io.flow.v0.models.SubcatalogReference => jsObjectSubcatalogReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "subcatalog_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiExpandableSubcatalog: play.api.libs.json.Writes[ExpandableSubcatalog] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExpandableSubcatalog] {
        def writes(obj: io.flow.v0.models.ExpandableSubcatalog) = {
          jsObjectExpandableSubcatalog(obj)
        }
      }
    }

    implicit def jsonReadsApiExpandableUser: play.api.libs.json.Reads[ExpandableUser] = new play.api.libs.json.Reads[ExpandableUser] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[ExpandableUser] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "user" => js.validate[io.flow.v0.models.User]
              case "user_reference" => js.validate[io.flow.v0.models.UserReference]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.ExpandableUserUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectExpandableUser(obj: io.flow.v0.models.ExpandableUser) = {
      obj match {
        case x: io.flow.v0.models.User => jsObjectUser(x) ++ play.api.libs.json.Json.obj("discriminator" -> "user")
        case x: io.flow.v0.models.UserReference => jsObjectUserReference(x) ++ play.api.libs.json.Json.obj("discriminator" -> "user_reference")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiExpandableUser: play.api.libs.json.Writes[ExpandableUser] = {
      new play.api.libs.json.Writes[io.flow.v0.models.ExpandableUser] {
        def writes(obj: io.flow.v0.models.ExpandableUser) = {
          jsObjectExpandableUser(obj)
        }
      }
    }

    implicit def jsonReadsApiInventoryStrategy: play.api.libs.json.Reads[InventoryStrategy] = new play.api.libs.json.Reads[InventoryStrategy] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[InventoryStrategy] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "inventory_backorder" => js.validate[io.flow.v0.models.InventoryBackorder]
              case "inventory_stock" => js.validate[io.flow.v0.models.InventoryStock]
              case "inventory_unlimited" => js.validate[io.flow.v0.models.InventoryUnlimited]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.InventoryStrategyUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectInventoryStrategy(obj: io.flow.v0.models.InventoryStrategy) = {
      obj match {
        case x: io.flow.v0.models.InventoryBackorder => jsObjectInventoryBackorder(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_backorder")
        case x: io.flow.v0.models.InventoryStock => jsObjectInventoryStock(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_stock")
        case x: io.flow.v0.models.InventoryUnlimited => jsObjectInventoryUnlimited(x) ++ play.api.libs.json.Json.obj("discriminator" -> "inventory_unlimited")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiInventoryStrategy: play.api.libs.json.Writes[InventoryStrategy] = {
      new play.api.libs.json.Writes[io.flow.v0.models.InventoryStrategy] {
        def writes(obj: io.flow.v0.models.InventoryStrategy) = {
          jsObjectInventoryStrategy(obj)
        }
      }
    }

    implicit def jsonReadsApiTierRuleOutcome: play.api.libs.json.Reads[TierRuleOutcome] = new play.api.libs.json.Reads[TierRuleOutcome] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[TierRuleOutcome] = {
        (js \ "discriminator").validate[String] match {
          case play.api.libs.json.JsError(msg) => play.api.libs.json.JsError(msg)
          case play.api.libs.json.JsSuccess(discriminator, _) => {
            discriminator match {
              case "amount_margin" => js.validate[io.flow.v0.models.AmountMargin]
              case "at_cost" => js.validate[io.flow.v0.models.AtCost]
              case "flat_rate" => js.validate[io.flow.v0.models.FlatRate]
              case "free_shipping" => js.validate[io.flow.v0.models.FreeShipping]
              case "percent_margin" => js.validate[io.flow.v0.models.PercentMargin]
              case other => play.api.libs.json.JsSuccess(io.flow.v0.models.TierRuleOutcomeUndefinedType(other))
            }
          }
        }
      }
    }

    def jsObjectTierRuleOutcome(obj: io.flow.v0.models.TierRuleOutcome) = {
      obj match {
        case x: io.flow.v0.models.AmountMargin => jsObjectAmountMargin(x) ++ play.api.libs.json.Json.obj("discriminator" -> "amount_margin")
        case x: io.flow.v0.models.AtCost => jsObjectAtCost(x) ++ play.api.libs.json.Json.obj("discriminator" -> "at_cost")
        case x: io.flow.v0.models.FlatRate => jsObjectFlatRate(x) ++ play.api.libs.json.Json.obj("discriminator" -> "flat_rate")
        case x: io.flow.v0.models.FreeShipping => jsObjectFreeShipping(x) ++ play.api.libs.json.Json.obj("discriminator" -> "free_shipping")
        case x: io.flow.v0.models.PercentMargin => jsObjectPercentMargin(x) ++ play.api.libs.json.Json.obj("discriminator" -> "percent_margin")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesApiTierRuleOutcome: play.api.libs.json.Writes[TierRuleOutcome] = {
      new play.api.libs.json.Writes[io.flow.v0.models.TierRuleOutcome] {
        def writes(obj: io.flow.v0.models.TierRuleOutcome) = {
          jsObjectTierRuleOutcome(obj)
        }
      }
    }
  }
}

